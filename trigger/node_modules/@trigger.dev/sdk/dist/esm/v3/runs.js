import { accessoryAttributes, apiClientManager, flattenAttributes, isRequestOptions, mergeRequestOptions, } from "@trigger.dev/core/v3";
import { apiClientMissingError } from "./shared.js";
import { tracer } from "./tracer.js";
import { resolvePresignedPacketUrl } from "@trigger.dev/core/v3/utils/ioSerialization";
export const runs = {
    replay: replayRun,
    cancel: cancelRun,
    retrieve: retrieveRun,
    list: listRuns,
    reschedule: rescheduleRun,
    poll,
};
function listRuns(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    const apiClient = apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const $requestOptions = listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions);
    if (typeof paramsOrProjectRef === "string") {
        if (isRequestOptions(paramsOrOptions)) {
            return apiClient.listProjectRuns(paramsOrProjectRef, {}, $requestOptions);
        }
        else {
            return apiClient.listProjectRuns(paramsOrProjectRef, paramsOrOptions, $requestOptions);
        }
    }
    return apiClient.listRuns(paramsOrProjectRef, $requestOptions);
}
function listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    if (typeof paramsOrProjectRef === "string") {
        if (isRequestOptions(paramsOrOptions)) {
            return mergeRequestOptions({
                tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...accessoryAttributes({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, paramsOrOptions);
        }
        else {
            return mergeRequestOptions({
                tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...flattenAttributes(paramsOrOptions, "queryParams"),
                    ...accessoryAttributes({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, requestOptions);
        }
    }
    return mergeRequestOptions({
        tracer,
        name: "runs.list()",
        icon: "runs",
        attributes: {
            ...flattenAttributes(paramsOrProjectRef, "queryParams"),
        },
    }, isRequestOptions(paramsOrOptions) ? paramsOrOptions : requestOptions);
}
function retrieveRun(runId, requestOptions) {
    const apiClient = apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const $requestOptions = mergeRequestOptions({
        tracer,
        name: "runs.retrieve()",
        icon: "runs",
        attributes: {
            runId: typeof runId === "string" ? runId : runId.id,
            ...accessoryAttributes({
                items: [
                    {
                        text: typeof runId === "string" ? runId : runId.id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    const $runId = typeof runId === "string" ? runId : runId.id;
    return apiClient.retrieveRun($runId, $requestOptions).then((retrievedRun) => {
        return resolvePayloadAndOutputUrls(retrievedRun);
    });
}
async function resolvePayloadAndOutputUrls(run) {
    const resolvedRun = { ...run };
    if (run.payloadPresignedUrl && run.outputPresignedUrl) {
        const [payload, output] = await Promise.all([
            resolvePresignedPacketUrl(run.payloadPresignedUrl, tracer),
            resolvePresignedPacketUrl(run.outputPresignedUrl, tracer),
        ]);
        resolvedRun.payload = payload;
        resolvedRun.output = output;
    }
    else if (run.payloadPresignedUrl) {
        resolvedRun.payload = await resolvePresignedPacketUrl(run.payloadPresignedUrl, tracer);
    }
    else if (run.outputPresignedUrl) {
        resolvedRun.output = await resolvePresignedPacketUrl(run.outputPresignedUrl, tracer);
    }
    return resolvedRun;
}
function replayRun(runId, requestOptions) {
    const apiClient = apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const $requestOptions = mergeRequestOptions({
        tracer,
        name: "runs.replay()",
        icon: "runs",
        attributes: {
            runId,
            ...accessoryAttributes({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.replayRun(runId, $requestOptions);
}
function cancelRun(runId, requestOptions) {
    const apiClient = apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const $requestOptions = mergeRequestOptions({
        tracer,
        name: "runs.cancel()",
        icon: "runs",
        attributes: {
            runId,
            ...accessoryAttributes({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.cancelRun(runId, $requestOptions);
}
function rescheduleRun(runId, body, requestOptions) {
    const apiClient = apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const $requestOptions = mergeRequestOptions({
        tracer,
        name: "runs.reschedule()",
        icon: "runs",
        attributes: {
            runId,
            ...accessoryAttributes({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.rescheduleRun(runId, body, $requestOptions);
}
const MAX_POLL_ATTEMPTS = 500;
async function poll(runId, options, requestOptions) {
    let attempts = 0;
    while (attempts++ < MAX_POLL_ATTEMPTS) {
        const run = await runs.retrieve(runId, requestOptions);
        if (run.isCompleted) {
            return run;
        }
        await new Promise((resolve) => setTimeout(resolve, options?.pollIntervalMs ?? 1000));
    }
    throw new Error(`Run ${typeof runId === "string" ? runId : runId.id} did not complete after ${MAX_POLL_ATTEMPTS} attempts`);
}
//# sourceMappingURL=runs.js.map