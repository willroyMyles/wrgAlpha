import { runLocalStorage } from "./runLocalStorage.js";
import { slugifyId } from "./utils.js";
/** A [Job](https://trigger.dev/docs/documentation/concepts/jobs) is used to define the [Trigger](https://trigger.dev/docs/documentation/concepts/triggers), metadata, and what happens when it runs. */
export class Job {
    options;
    client;
    constructor(options) {
        this.options = options;
        this.#validate();
    }
    /**
     * Attaches the job to a client. This is called automatically when you define a job using `client.defineJob()`.
     */
    attachToClient(client) {
        client.attach(this);
        return this;
    }
    get id() {
        return slugifyId(this.options.id);
    }
    get enabled() {
        return typeof this.options.enabled === "boolean" ? this.options.enabled : true;
    }
    get name() {
        return this.options.name;
    }
    get trigger() {
        return this.options.trigger;
    }
    get version() {
        return this.options.version;
    }
    get logLevel() {
        return this.options.logLevel;
    }
    get integrations() {
        return Object.keys(this.options.integrations ?? {}).reduce((acc, key) => {
            const integration = this.options.integrations[key];
            if (!integration) {
                return acc;
            }
            acc[key] = {
                id: integration.id,
                metadata: integration.metadata,
                authSource: integration.authSource,
            };
            return acc;
        }, {});
    }
    toJSON() {
        // @ts-ignore
        const internal = this.options.__internal;
        return {
            id: this.id,
            name: this.name,
            version: this.version,
            event: this.trigger.event,
            trigger: this.trigger.toJSON(),
            integrations: this.integrations,
            startPosition: "latest", // this is deprecated, leaving this for now to make sure newer clients work with older servers
            enabled: this.enabled,
            preprocessRuns: this.trigger.preprocessRuns,
            internal,
            concurrencyLimit: typeof this.options.concurrencyLimit === "number"
                ? this.options.concurrencyLimit
                : typeof this.options.concurrencyLimit === "object"
                    ? { id: this.options.concurrencyLimit.id, limit: this.options.concurrencyLimit.limit }
                    : undefined,
        };
    }
    async invoke(param1, param2 = undefined, param3 = undefined) {
        const triggerClient = this.client;
        if (!triggerClient) {
            throw new Error("Cannot invoke a job that is not attached to a client. Make sure you attach the job to a client before invoking it.");
        }
        const runStore = runLocalStorage.getStore();
        if (typeof param1 === "string") {
            if (!runStore) {
                throw new Error("Cannot invoke a job from outside of a run when passing a cacheKey. Make sure you are running the job from within a run or use the invoke method without the cacheKey.");
            }
            const options = param3 ?? {};
            return await runStore.io.runTask(param1, async (task) => {
                const result = await triggerClient.invokeJob(this.id, param2, {
                    idempotencyKey: task.idempotencyKey,
                    ...options,
                });
                task.outputProperties = [
                    {
                        label: "Run",
                        text: result.id,
                        url: `/orgs/${runStore.ctx.organization.slug}/projects/${runStore.ctx.project.slug}/jobs/${this.id}/runs/${result.id}/trigger`,
                    },
                ];
                return result;
            }, {
                name: `Manually Invoke '${this.name}'`,
                params: param2,
                properties: [
                    {
                        label: "Job",
                        text: this.id,
                        url: `/orgs/${runStore.ctx.organization.slug}/projects/${runStore.ctx.project.slug}/jobs/${this.id}`,
                    },
                    {
                        label: "Env",
                        text: runStore.ctx.environment.slug,
                    },
                ],
            });
        }
        if (runStore) {
            throw new Error("Cannot invoke a job from within a run without a cacheKey.");
        }
        return await triggerClient.invokeJob(this.id, param1, param2);
    }
    async invokeAndWaitForCompletion(cacheKey, payload, timeoutInSeconds = 60 * 60, // 1 hour
    options = {}) {
        const triggerClient = this.client;
        if (!triggerClient) {
            throw new Error("Cannot invoke a job that is not attached to a client. Make sure you attach the job to a client before invoking it.");
        }
        const runStore = runLocalStorage.getStore();
        if (!runStore) {
            throw new Error("Cannot invoke a job from outside of a run using invokeAndWaitForCompletion. Make sure you are running the job from within a run or use the invoke method instead.");
        }
        const { io, ctx } = runStore;
        return (await io.runTask(cacheKey, async (task) => {
            const parsedPayload = this.trigger.event.parseInvokePayload
                ? this.trigger.event.parseInvokePayload(payload)
                    ? payload
                    : undefined
                : payload;
            const result = await triggerClient.invokeJob(this.id, parsedPayload, {
                idempotencyKey: task.idempotencyKey,
                callbackUrl: task.callbackUrl ?? undefined,
                ...options,
            });
            task.outputProperties = [
                {
                    label: "Run",
                    text: result.id,
                    url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}/runs/${result.id}/trigger`,
                },
            ];
            return {}; // we don't want to return anything here, we just want to wait for the callback
        }, {
            name: `Manually Invoke '${this.name}' and wait for completion`,
            params: payload,
            properties: [
                {
                    label: "Job",
                    text: this.id,
                    url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}`,
                },
                {
                    label: "Env",
                    text: ctx.environment.slug,
                },
            ],
            callback: {
                enabled: true,
                timeoutInSeconds,
            },
        }));
    }
    async batchInvokeAndWaitForCompletion(cacheKey, batch) {
        const runStore = runLocalStorage.getStore();
        if (!runStore) {
            throw new Error("Cannot invoke a job from outside of a run using batchInvokeAndWaitForCompletion.");
        }
        // If there are no items in the batch, return an empty array
        if (batch.length === 0) {
            return [];
        }
        // If there are too many items in the batch, throw an error
        if (batch.length > 25) {
            throw new Error(`Cannot batch invoke more than 25 items. You tried to batch invoke ${batch.length} items.`);
        }
        const { io, ctx } = runStore;
        const results = await io.parallel(cacheKey, batch, async (item, index) => {
            return (await this.invokeAndWaitForCompletion(String(index), item.payload, item.timeoutInSeconds ?? 60 * 60, item.options));
        }, {
            name: `Batch Invoke '${this.name}'`,
            properties: [
                {
                    label: "Job",
                    text: this.id,
                    url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}`,
                },
                {
                    label: "Env",
                    text: ctx.environment.slug,
                },
            ],
        });
        return results;
    }
    // Make sure the id is valid (must only contain alphanumeric characters and dashes)
    // Make sure the version is valid (must be a valid semver version)
    #validate() {
        if (!this.version.match(/^(\d+)\.(\d+)\.(\d+)$/)) {
            throw new Error(`Invalid job version: "${this.version}". Job versions must be valid semver versions.`);
        }
    }
}
//# sourceMappingURL=job.js.map