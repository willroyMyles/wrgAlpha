import { DeserializedJson, EphemeralEventDispatcherRequestBody, GetRunOptionsWithTaskDetails, GetRunsOptions, InvokeOptions, NormalizedResponse, Prettify, RegisterTriggerBodyV2, ScheduleMetadata, SendEvent, SendEventOptions, StatusUpdate } from "@trigger.dev/core";
import { LogLevel } from "@trigger.dev/core/logger";
import { ConcurrencyLimit, ConcurrencyLimitOptions } from "./concurrencyLimit.js";
import { EndpointOptions, HttpEndpoint } from "./httpEndpoint.js";
import { TriggerIntegration } from "./integrations.js";
import { Job, JobOptions } from "./job.js";
import { KeyValueStore } from "./store/keyValueStore.js";
import { DynamicTrigger, DynamicTriggerOptions } from "./triggers/dynamic.js";
import { ExternalSource } from "./triggers/externalSource.js";
import { DynamicIntervalOptions, DynamicSchedule } from "./triggers/scheduled.js";
import { WebhookSource } from "./triggers/webhook.js";
import { type EventSpecification, type NotificationsEventEmitter, type Trigger, type TriggerContext } from "./types.js";
export type TriggerClientOptions = {
    /** The `id` property is used to uniquely identify the client.
     */
    id: string;
    /** The `apiKey` property is the API Key for your Trigger.dev environment. We
        recommend using an environment variable to store your API Key. */
    apiKey?: string;
    /** The `apiUrl` property is an optional property that specifies the API URL. You
        only need to specify this if you are not using Trigger.dev Cloud and are
        running your own Trigger.dev instance. */
    apiUrl?: string;
    /** The `logLevel` property is an optional property that specifies the level of
        logging for the TriggerClient. The level is inherited by all Jobs that use this Client, unless they also specify a `logLevel`. */
    logLevel?: LogLevel;
    /** Very verbose log messages, defaults to false. */
    verbose?: boolean;
    /** Default is unset and off. If set to true it will log to the server's console as well as the Trigger.dev platform */
    ioLogLocalEnabled?: boolean;
};
export type AuthResolverResult = {
    type: "apiKey" | "oauth";
    token: string;
    additionalFields?: Record<string, string>;
};
export type TriggerAuthResolver = (ctx: TriggerContext, integration: TriggerIntegration) => Promise<AuthResolverResult | void | undefined>;
/** A [TriggerClient](https://trigger.dev/docs/documentation/concepts/client-adaptors) is used to connect to a specific [Project](https://trigger.dev/docs/documentation/concepts/projects) by using an [API Key](https://trigger.dev/docs/documentation/concepts/environments-apikeys). */
export declare class TriggerClient {
    #private;
    id: string;
    constructor(options: Prettify<TriggerClientOptions>);
    on: <E extends keyof import("./types.js").NotificationEvents>(event: E, listener: import("./types.js").NotificationEvents[E]) => NotificationsEventEmitter;
    handleRequest(request: Request, timeOrigin?: number): Promise<NormalizedResponse>;
    defineJob<TTrigger extends Trigger<EventSpecification<any>>, TIntegrations extends Record<string, TriggerIntegration> = {}, TOutput extends any = any>(options: JobOptions<TTrigger, TIntegrations, TOutput>): Job<TTrigger, TIntegrations, TOutput>;
    defineAuthResolver(integration: TriggerIntegration, resolver: TriggerAuthResolver): TriggerClient;
    defineDynamicSchedule(options: DynamicIntervalOptions): DynamicSchedule;
    defineDynamicTrigger<TEventSpec extends EventSpecification<any>, TExternalSource extends ExternalSource<any, any, any>>(options: DynamicTriggerOptions<TEventSpec, TExternalSource>): DynamicTrigger<TEventSpec, TExternalSource>;
    /**
     * An [HTTP endpoint](https://trigger.dev/docs/documentation/concepts/http-endpoints) allows you to create a [HTTP Trigger](https://trigger.dev/docs/documentation/concepts/triggers/http), which means you can trigger your Jobs from any webhooks.
     * @param options The Endpoint options
     * @returns An HTTP Endpoint, that can be used to create an HTTP Trigger.
     * @link https://trigger.dev/docs/documentation/concepts/http-endpoints
     */
    defineHttpEndpoint(options: EndpointOptions, suppressWarnings?: boolean): HttpEndpoint<EventSpecification<Request, Request>>;
    defineConcurrencyLimit(options: ConcurrencyLimitOptions): ConcurrencyLimit;
    attach(job: Job<Trigger<any>, any>): void;
    attachDynamicTrigger(trigger: DynamicTrigger<any, any>): void;
    attachJobToDynamicTrigger(job: Job<Trigger<any>, any>, trigger: DynamicTrigger<any, any>): void;
    attachSource(options: {
        key: string;
        source: ExternalSource<any, any>;
        event: EventSpecification<any>;
        params: any;
        options?: Record<string, string[]>;
    }): void;
    attachDynamicSchedule(key: string): void;
    attachDynamicScheduleToJob(key: string, job: Job<Trigger<any>, any>): void;
    attachWebhook<TIntegration extends TriggerIntegration, TParams extends any, TConfig extends Record<string, string[]>>(options: {
        key: string;
        source: WebhookSource<TIntegration, TParams, TConfig>;
        event: EventSpecification<any>;
        params: any;
        config: TConfig;
    }): void;
    registerTrigger(id: string, key: string, options: RegisterTriggerBodyV2, idempotencyKey?: string): Promise<{
        options: {
            event: {
                desired: string[];
                missing: string[];
                orphaned: string[];
            };
        } & Record<string, {
            desired: string[];
            missing: string[];
            orphaned: string[];
        }>;
        source: {
            key: string;
            secret: string;
            active: boolean;
            channel: {
                type: "HTTP";
                url: string;
            } | {
                type: "SMTP";
            } | {
                type: "SQS";
            };
            params?: any;
            data?: DeserializedJson | undefined;
            clientId?: string | undefined;
        };
        id: string;
        dynamicTriggerId?: string | undefined;
    }>;
    getAuth(id: string): Promise<{
        type: "oauth2" | "apiKey";
        accessToken: string;
        scopes?: string[] | undefined;
        additionalFields?: Record<string, string> | undefined;
    } | undefined>;
    /** You can call this function from anywhere in your backend to send an event. The other way to send an event is by using [`io.sendEvent()`](https://trigger.dev/docs/sdk/io/sendevent) from inside a `run()` function.
     * @param event The event to send.
     * @param options Options for sending the event.
     * @returns A promise that resolves to the event details
     */
    sendEvent(event: SendEvent, options?: SendEventOptions): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[]) & (string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }>;
    /** You can call this function from anywhere in your backend to send multiple events. The other way to send multiple events is by using [`io.sendEvents()`](https://trigger.dev/docs/sdk/io/sendevents) from inside a `run()` function.
     * @param events The events to send.
     * @param options Options for sending the events.
     * @returns A promise that resolves to an array of event details
     */
    sendEvents(events: SendEvent[], options?: SendEventOptions): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[]) & (string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }[]>;
    cancelEvent(eventId: string): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[]) & (string | number | boolean | {
            [key: string]: DeserializedJson;
        } | DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }>;
    cancelRunsForEvent(eventId: string): Promise<{
        cancelledRunIds: string[];
        failedToCancelRunIds: string[];
    }>;
    updateStatus(runId: string, id: string, status: StatusUpdate): Promise<{
        label: string;
        key: string;
        history: {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
        }[];
        data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
        state?: "loading" | "success" | "failure" | undefined;
    }>;
    registerSchedule(id: string, key: string, schedule: ScheduleMetadata): Promise<{
        id: string;
        schedule: {
            options: {
                cron: string;
            };
            type: "cron";
            accountId?: string | undefined;
            metadata?: any;
        } | {
            options: {
                seconds: number;
            };
            type: "interval";
            accountId?: string | undefined;
            metadata?: any;
        };
        active: boolean;
        metadata?: any;
    }>;
    unregisterSchedule(id: string, key: string): Promise<{
        ok: boolean;
    }>;
    getEvent(eventId: string): Promise<{
        name: string;
        id: string;
        updatedAt: Date;
        runs: {
            status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
            id: string;
            startedAt?: Date | null | undefined;
            completedAt?: Date | null | undefined;
        }[];
        createdAt: Date;
    }>;
    getRun(runId: string, options?: GetRunOptionsWithTaskDetails): Promise<{
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
        tasks: import("@trigger.dev/core").RunTaskWithSubtasks[];
        statuses: {
            label: string;
            key: string;
            history: {
                label?: string | undefined;
                state?: "loading" | "success" | "failure" | undefined;
                data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            }[];
            data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            state?: "loading" | "success" | "failure" | undefined;
        }[];
        output?: any;
        nextCursor?: string | undefined;
    }>;
    cancelRun(runId: string): Promise<{
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
        tasks: import("@trigger.dev/core").RunTaskWithSubtasks[];
        statuses: {
            label: string;
            key: string;
            history: {
                label?: string | undefined;
                state?: "loading" | "success" | "failure" | undefined;
                data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            }[];
            data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            state?: "loading" | "success" | "failure" | undefined;
        }[];
        output?: any;
        nextCursor?: string | undefined;
    }>;
    getRuns(jobSlug: string, options?: GetRunsOptions): Promise<{
        runs: {
            status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
            id: string;
            startedAt: Date | null;
            completedAt: Date | null;
            updatedAt: Date | null;
        }[];
        nextCursor?: string | undefined;
    }>;
    getRunStatuses(runId: string): Promise<{
        statuses: {
            label: string;
            key: string;
            history: {
                label?: string | undefined;
                state?: "loading" | "success" | "failure" | undefined;
                data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            }[];
            data?: Record<string, import("@trigger.dev/core").SerializableJson> | undefined;
            state?: "loading" | "success" | "failure" | undefined;
        }[];
        run: {
            status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
            id: string;
            output?: any;
        };
    }>;
    invokeJob(jobId: string, payload: any, options?: InvokeOptions): Promise<{
        id: string;
    }>;
    cancelRunsForJob(jobId: string): Promise<{
        cancelledRunIds: string[];
        failedToCancelRunIds: string[];
    }>;
    createEphemeralEventDispatcher(payload: EphemeralEventDispatcherRequestBody): Promise<{
        id: string;
    }>;
    get store(): {
        env: KeyValueStore;
    };
    authorized(apiKey?: string | null): "authorized" | "unauthorized" | "missing-client" | "missing-header";
    apiKey(): string | undefined;
}
