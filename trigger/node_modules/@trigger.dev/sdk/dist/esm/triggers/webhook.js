import { deepMergeFilters, } from "@trigger.dev/core";
import { slugifyId } from "../utils.js";
import { createHash } from "node:crypto";
export class WebhookSource {
    options;
    constructor(options) {
        this.options = options;
    }
    async generateEvents(request, client, ctx) {
        return this.options.generateEvents({
            request,
            client,
            ctx,
        });
    }
    filter(params, config) {
        return this.options.filter?.(params, config) ?? {};
    }
    properties(params) {
        return this.options.properties?.(params) ?? [];
    }
    get crud() {
        return this.options.crud;
    }
    async register(params, registerEvent, io, ctx) {
        if (!this.options.register) {
            return;
        }
        const updates = await this.options.register({
            ...registerEvent,
            params,
        }, io, ctx);
        return updates;
    }
    async verify(request, client, ctx) {
        if (this.options.verify) {
            const clonedRequest = request.clone();
            return this.options.verify({ request: clonedRequest, client, ctx });
        }
        return { success: true };
    }
    #shortHash(str) {
        const hash = createHash("sha1").update(str).digest("hex");
        return hash.slice(0, 7);
    }
    key(params) {
        const parts = ["webhook"];
        parts.push(this.options.key(params));
        parts.push(this.integration.id);
        return `${this.options.id}-${this.#shortHash(parts.join(""))}`;
    }
    get integration() {
        return this.options.integration;
    }
    get integrationConfig() {
        return {
            id: this.integration.id,
            metadata: this.integration.metadata,
        };
    }
    get id() {
        return this.options.id;
    }
    get version() {
        return this.options.version;
    }
}
export class WebhookTrigger {
    options;
    constructor(options) {
        this.options = options;
    }
    get event() {
        return this.options.event;
    }
    get source() {
        return this.options.source;
    }
    get key() {
        return slugifyId(this.options.source.key(this.options.params));
    }
    toJSON() {
        return {
            type: "static",
            title: "Webhook",
            rule: {
                event: this.event.name,
                payload: deepMergeFilters(this.options.source.filter(this.options.params, this.options.config), this.event.filter ?? {}),
                source: this.event.source,
            },
            properties: this.options.source.properties(this.options.params),
            link: `http-endpoints/${this.key}`,
        };
    }
    filter(eventFilter) {
        const { event, ...optionsWithoutEvent } = this.options;
        const { filter, ...eventWithoutFilter } = event;
        return new WebhookTrigger({
            ...optionsWithoutEvent,
            event: {
                ...eventWithoutFilter,
                filter: deepMergeFilters(filter ?? {}, eventFilter),
            },
        });
    }
    attachToJob(triggerClient, job) {
        triggerClient.defineHttpEndpoint({
            id: this.key,
            source: "trigger.dev",
            icon: this.event.icon,
            verify: async () => ({ success: true }),
        }, true);
        triggerClient.attachWebhook({
            key: this.key,
            source: this.options.source,
            event: this.options.event,
            params: this.options.params,
            config: this.options.config,
        });
    }
    get preprocessRuns() {
        return true;
    }
    async verifyPayload(payload) {
        return { success: true };
    }
}
//# sourceMappingURL=webhook.js.map