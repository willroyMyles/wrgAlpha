import { CachedTask, ConnectionAuth, CronOptions, EventFilter, FetchPollOperation, FetchRequestInit, FetchRetryOptions, FetchTimeoutOptions, InitialStatusUpdate, IntervalOptions, RunTaskOptions, SendEvent, SendEventOptions, ServerTask, UpdateTriggerSourceBodyV2, UpdateWebhookBody } from "@trigger.dev/core";
import { LogLevel, Logger } from "@trigger.dev/core/logger";
import { ApiClient } from "./apiClient.js";
import { IntegrationTaskKey } from "./integrations.js";
import { TriggerStatus } from "./status.js";
import { TriggerClient } from "./triggerClient.js";
import { DynamicTrigger } from "./triggers/dynamic.js";
import { ExternalSource, ExternalSourceParams } from "./triggers/externalSource.js";
import { DynamicSchedule } from "./triggers/scheduled.js";
import { EventSpecification, TaskLogger, TriggerContext, WaitForEventResult } from "./types.js";
import { z } from "zod";
import { KeyValueStore } from "./store/keyValueStore.js";
export type IOTask = ServerTask;
export type IOOptions = {
    id: string;
    jobId: string;
    apiClient: ApiClient;
    client: TriggerClient;
    context: TriggerContext;
    timeOrigin: number;
    logger?: Logger;
    logLevel?: LogLevel;
    jobLogger?: Logger;
    jobLogLevel: LogLevel;
    cachedTasks?: Array<CachedTask>;
    cachedTasksCursor?: string;
    yieldedExecutions?: Array<string>;
    noopTasksSet?: string;
    serverVersion?: string | null;
    executionTimeout?: number;
};
type JsonPrimitive = string | number | boolean | null | undefined | Date | symbol;
type JsonArray = Json[];
type JsonRecord<T> = {
    [Property in keyof T]: Json;
};
export type Json<T = any> = JsonPrimitive | JsonArray | JsonRecord<T>;
export type RunTaskErrorCallback = (error: unknown, task: IOTask, io: IO) => {
    retryAt?: Date;
    error?: Error;
    jitter?: number;
    skipRetrying?: boolean;
} | Error | undefined | void;
export type IOStats = {
    initialCachedTasks: number;
    lazyLoadedCachedTasks: number;
    executedTasks: number;
    cachedTaskHits: number;
    cachedTaskMisses: number;
    noopCachedTaskHits: number;
    noopCachedTaskMisses: number;
};
export interface OutputSerializer {
    serialize(value: any): string;
    deserialize<T>(value: string): T;
}
export declare class JSONOutputSerializer implements OutputSerializer {
    serialize(value: any): string;
    deserialize(value?: string): any;
}
export type BackgroundFetchResponse<T> = {
    status: number;
    data: T;
    headers: Record<string, string>;
};
export declare class IO {
    #private;
    private _id;
    private _jobId;
    private _apiClient;
    private _triggerClient;
    private _logger;
    private _jobLogger?;
    private _jobLogLevel;
    private _cachedTasks;
    private _taskStorage;
    private _cachedTasksCursor?;
    private _context;
    private _yieldedExecutions;
    private _noopTasksBloomFilter;
    private _stats;
    private _serverVersion;
    private _timeOrigin;
    private _executionTimeout?;
    private _outputSerializer;
    private _visitedCacheKeys;
    private _envStore;
    private _jobStore;
    private _runStore;
    get stats(): IOStats;
    constructor(options: IOOptions);
    /** Used to send log messages to the [Run log](https://trigger.dev/docs/documentation/guides/viewing-runs). */
    get logger(): IOLogger;
    /** `io.random()` is identical to `Math.random()` when called without options but ensures your random numbers are not regenerated on resume or retry. It will return a pseudo-random floating-point number between optional `min` (default: 0, inclusive) and `max` (default: 1, exclusive). Can optionally `round` to the nearest integer.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param min Sets the lower bound (inclusive). Can't be higher than `max`.
     * @param max Sets the upper bound (exclusive). Can't be lower than `min`.
     * @param round Controls rounding to the nearest integer. Any `max` integer will become inclusive when enabled. Rounding with floating-point bounds may cause unexpected skew and boundary inclusivity.
     */
    random(cacheKey: string | any[], { min, max, round, }?: {
        min?: number;
        max?: number;
        round?: boolean;
    }): Promise<number>;
    /** `io.wait()` waits for the specified amount of time before continuing the Job. Delays work even if you're on a serverless platform with timeouts, or if your server goes down. They utilize [resumability](https://trigger.dev/docs/documentation/concepts/resumability) to ensure that the Run can be resumed after the delay.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param seconds The number of seconds to wait. This can be very long, serverless timeouts are not an issue.
     */
    wait(cacheKey: string | any[], seconds: number): Promise<void>;
    waitForEvent<T extends z.ZodTypeAny = z.ZodTypeAny>(cacheKey: string | any[], event: {
        name: string;
        schema?: T;
        filter?: EventFilter;
        source?: string;
        contextFilter?: EventFilter;
        accountId?: string;
    }, options?: {
        timeoutInSeconds?: number;
    }): Promise<WaitForEventResult<z.output<T>>>;
    /** `io.waitForRequest()` allows you to pause the execution of a run until the url provided in the callback is POSTed to.
     *  This is useful for integrating with external services that require a callback URL to be provided, or if you want to be able to wait until an action is performed somewhere else in your system.
     *  @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     *  @param callback A callback function that will provide the unique URL to POST to.
     *  @param options Options for the callback.
     *  @param options.timeoutInSeconds How long to wait for the request to be POSTed to the callback URL before timing out. Defaults to 1hr.
     *  @returns The POSTed request JSON body.
     *  @example
     * ```ts
      const result = await io.waitForRequest<{ message: string }>(
        "wait-for-request",
        async (url, task) => {
          // Save the URL somewhere so you can POST to it later
          // Or send it to an external service that will POST to it
        },
        { timeoutInSeconds: 60 } // wait 60 seconds
      );
      * ```
     */
    waitForRequest<T extends Json<T> | unknown = unknown>(cacheKey: string | any[], callback: (url: string) => Promise<unknown>, options?: {
        timeoutInSeconds?: number;
    }): Promise<T>;
    /** `io.createStatus()` allows you to set a status with associated data during the Run. Statuses can be used by your UI using the react package
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param initialStatus The initial status you want this status to have. You can update it during the rub using the returned object.
     * @returns a TriggerStatus object that you can call `update()` on, to update the status.
     * @example
     * ```ts
     * client.defineJob(
    //...
      run: async (payload, io, ctx) => {
        const generatingImages = await io.createStatus("generating-images", {
          label: "Generating Images",
          state: "loading",
          data: {
            progress: 0.1,
          },
        });
  
        //...do stuff
  
        await generatingImages.update("completed-generation", {
          label: "Generated images",
          state: "success",
          data: {
            progress: 1.0,
            urls: ["http://..."]
          },
        });
  
      //...
    });
     * ```
    */
    createStatus(cacheKey: IntegrationTaskKey, initialStatus: InitialStatusUpdate): Promise<TriggerStatus>;
    /** `io.backgroundFetch()` fetches data from a URL that can take longer that the serverless timeout. The actual `fetch` request is performed on the Trigger.dev platform, and the response is sent back to you.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param url The URL to fetch from.
     * @param requestInit The options for the request
     * @param retry The options for retrying the request if it fails
     * An object where the key is a status code pattern and the value is a retrying strategy.
     * Supported patterns are:
     * - Specific status codes: 429
     * - Ranges: 500-599
     * - Wildcards: 2xx, 3xx, 4xx, 5xx
     */
    backgroundFetch<TResponseData>(cacheKey: string | any[], url: string, requestInit?: FetchRequestInit, options?: {
        retry?: FetchRetryOptions;
        timeout?: FetchTimeoutOptions;
    }): Promise<TResponseData>;
    /** `io.backgroundPoll()` will fetch data from a URL on an interval. The actual `fetch` requests are performed on the Trigger.dev server, so you don't have to worry about serverless function timeouts.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param params The options for the background poll
     * @param params.url The URL to fetch from.
     * @param params.requestInit The options for the request, like headers and method
     * @param params.responseFilter An [EventFilter](https://trigger.dev/docs/documentation/guides/event-filter) that allows you to specify when to stop polling.
     * @param params.interval The interval in seconds to poll the URL in seconds. Defaults to 10 seconds which is the minimum.
     * @param params.timeout The timeout in seconds for each request in seconds. Defaults to 10 minutes. Minimum is 60 seconds and max is 1 hour
     * @param params.requestTimeout An optional object that allows you to timeout individual fetch requests
     * @param params.requestTimeout An optional object that allows you to timeout individual fetch requests
     * @param params.requestTimeout.durationInMs The duration in milliseconds to timeout the request
     *
     * @example
     * ```ts
     * const result = await io.backgroundPoll<{ id: string; status: string; }>("poll", {
        url: `http://localhost:3030/api/v1/runs/${run.id}`,
        requestInit: {
          headers: {
            Accept: "application/json",
            Authorization: redactString`Bearer ${process.env["TRIGGER_API_KEY"]!}`,
          },
        },
        interval: 10,
        timeout: 600,
        responseFilter: {
          status: [200],
          body: {
            status: ["SUCCESS"],
          },
        },
      });
      * ```
     */
    backgroundPoll<TResponseData>(cacheKey: string | any[], params: FetchPollOperation): Promise<TResponseData>;
    /** `io.backgroundFetchResponse()` fetches data from a URL that can take longer that the serverless timeout. The actual `fetch` request is performed on the Trigger.dev platform, and the response is sent back to you.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param url The URL to fetch from.
     * @param requestInit The options for the request
     * @param retry The options for retrying the request if it fails
     * An object where the key is a status code pattern and the value is a retrying strategy.
     * Supported patterns are:
     * - Specific status codes: 429
     * - Ranges: 500-599
     * - Wildcards: 2xx, 3xx, 4xx, 5xx
     */
    backgroundFetchResponse<TResponseData>(cacheKey: string | any[], url: string, requestInit?: FetchRequestInit, options?: {
        retry?: FetchRetryOptions;
        timeout?: FetchTimeoutOptions;
    }): Promise<BackgroundFetchResponse<TResponseData>>;
    /** `io.sendEvent()` allows you to send an event from inside a Job run. The sent event will trigger any Jobs that are listening for that event (based on the name).
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param event The event to send. The event name must match the name of the event that your Jobs are listening for.
     * @param options Options for sending the event.
     */
    sendEvent(cacheKey: string | any[], event: SendEvent, options?: SendEventOptions): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[]) & (string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: import("@trigger.dev/core").DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }>;
    /** `io.sendEvents()` allows you to send multiple events from inside a Job run. The sent events will trigger any Jobs that are listening for those events (based on the name).
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param event The events to send. The event names must match the names of the events that your Jobs are listening for.
     * @param options Options for sending the events.
     */
    sendEvents(cacheKey: string | any[], events: SendEvent[], options?: SendEventOptions): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[]) & (string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: import("@trigger.dev/core").DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }[]>;
    getEvent(cacheKey: string | any[], id: string): Promise<{
        name: string;
        id: string;
        updatedAt: Date;
        runs: {
            status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
            id: string;
            startedAt?: Date | null | undefined;
            completedAt?: Date | null | undefined;
        }[];
        createdAt: Date;
    }>;
    /** `io.cancelEvent()` allows you to cancel an event that was previously sent with `io.sendEvent()`. This will prevent any Jobs from running that are listening for that event if the event was sent with a delay
     * @param cacheKey
     * @param eventId
     * @returns
     */
    cancelEvent(cacheKey: string | any[], eventId: string): Promise<{
        name: string;
        payload: ((string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[]) & (string | number | boolean | {
            [key: string]: import("@trigger.dev/core").DeserializedJson;
        } | import("@trigger.dev/core").DeserializedJson[] | undefined)) | null;
        id: string;
        timestamp: Date;
        context?: import("@trigger.dev/core").DeserializedJson | undefined;
        deliverAt?: Date | null | undefined;
        deliveredAt?: Date | null | undefined;
        cancelledAt?: Date | null | undefined;
    }>;
    updateSource(cacheKey: string | any[], options: {
        key: string;
    } & UpdateTriggerSourceBodyV2): Promise<{
        id: string;
        key: string;
    }>;
    updateWebhook(cacheKey: string | any[], options: {
        key: string;
    } & UpdateWebhookBody): Promise<{
        id: string;
        key: string;
    }>;
    /** `io.registerInterval()` allows you to register a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that will trigger any jobs it's attached to on a regular interval.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to register a new schedule on.
     * @param id A unique id for the interval. This is used to identify and unregister the interval later.
     * @param options The options for the interval.
     * @returns A promise that has information about the interval.
     * @deprecated Use `DynamicSchedule.register` instead.
     */
    registerInterval(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string, options: IntervalOptions): Promise<{
        id: string;
        schedule: {
            options: {
                cron: string;
            };
            type: "cron";
            accountId?: string | undefined;
            metadata?: any;
        } | {
            options: {
                seconds: number;
            };
            type: "interval";
            accountId?: string | undefined;
            metadata?: any;
        };
        active: boolean;
        metadata?: any;
    }>;
    /** `io.unregisterInterval()` allows you to unregister a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that was previously registered with `io.registerInterval()`.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to unregister a schedule on.
     * @param id A unique id for the interval. This is used to identify and unregister the interval later.
     * @deprecated Use `DynamicSchedule.unregister` instead.
     */
    unregisterInterval(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string): Promise<{
        ok: boolean;
    }>;
    /** `io.registerCron()` allows you to register a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that will trigger any jobs it's attached to on a regular CRON schedule.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to register a new schedule on.
     * @param id A unique id for the schedule. This is used to identify and unregister the schedule later.
     * @param options The options for the CRON schedule.
     * @deprecated Use `DynamicSchedule.register` instead.
     */
    registerCron(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string, options: CronOptions): Promise<{
        id: string;
        schedule: {
            options: {
                cron: string;
            };
            type: "cron";
            accountId?: string | undefined;
            metadata?: any;
        } | {
            options: {
                seconds: number;
            };
            type: "interval";
            accountId?: string | undefined;
            metadata?: any;
        };
        active: boolean;
        metadata?: any;
    }>;
    /** `io.unregisterCron()` allows you to unregister a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that was previously registered with `io.registerCron()`.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to unregister a schedule on.
     * @param id A unique id for the interval. This is used to identify and unregister the interval later.
     * @deprecated Use `DynamicSchedule.unregister` instead.
     */
    unregisterCron(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string): Promise<{
        ok: boolean;
    }>;
    /** `io.registerTrigger()` allows you to register a [DynamicTrigger](https://trigger.dev/docs/sdk/dynamictrigger) with the specified trigger params.
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param trigger The [DynamicTrigger](https://trigger.dev/docs/sdk/dynamictrigger) to register.
     * @param id A unique id for the trigger. This is used to identify and unregister the trigger later.
     * @param params The params for the trigger.
     * @deprecated Use `DynamicTrigger.register` instead.
     */
    registerTrigger<TTrigger extends DynamicTrigger<EventSpecification<any>, ExternalSource<any, any, any>>>(cacheKey: string | any[], trigger: TTrigger, id: string, params: ExternalSourceParams<TTrigger["source"]>): Promise<{
        id: string;
        key: string;
    } | undefined>;
    getAuth(cacheKey: string | any[], clientId?: string): Promise<ConnectionAuth | undefined>;
    parallel<T extends Json<T> | void, TItem>(cacheKey: string | any[], items: Array<TItem>, callback: (item: TItem, index: number) => Promise<T>, options?: Pick<RunTaskOptions, "name" | "properties">): Promise<Array<T>>;
    /** `io.runTask()` allows you to run a [Task](https://trigger.dev/docs/documentation/concepts/tasks) from inside a Job run. A Task is a resumable unit of a Run that can be retried, resumed and is logged. [Integrations](https://trigger.dev/docs/integrations) use Tasks internally to perform their actions.
     *
     * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.
     * @param callback The callback that will be called when the Task is run. The callback receives the Task and the IO as parameters.
     * @param options The options of how you'd like to run and log the Task.
     * @param onError The callback that will be called when the Task fails. The callback receives the error, the Task and the IO as parameters. If you wish to retry then return an object with a `retryAt` property.
     * @returns A Promise that resolves with the returned value of the callback.
     */
    runTask<T extends Json<T> | void>(cacheKey: string | any[], callback: (task: ServerTask, io: IO) => Promise<T>, options?: RunTaskOptions & {
        parseOutput?: (output: unknown) => T;
    }, onError?: RunTaskErrorCallback): Promise<T>;
    /**
     * `io.yield()` allows you to yield execution of the current run and resume it in a new function execution. Similar to `io.wait()` but does not create a task and resumes execution immediately.
     */
    yield(cacheKey: string): void;
    /**
     * `io.brb()` is an alias of `io.yield()`
     */
    brb: (cacheKey: string) => void;
    /** `io.try()` allows you to run Tasks and catch any errors that are thrown, it's similar to a normal `try/catch` block but works with [io.runTask()](https://trigger.dev/docs/sdk/io/runtask).
     * A regular `try/catch` block on its own won't work as expected with Tasks. Internally `runTask()` throws some special errors to control flow execution. This is necessary to deal with resumability, serverless timeouts, and retrying Tasks.
     * @param tryCallback The code you wish to run
     * @param catchCallback Thhis will be called if the Task fails. The callback receives the error
     * @returns A Promise that resolves with the returned value or the error
     */
    try<TResult, TCatchResult>(tryCallback: () => Promise<TResult>, catchCallback: (error: unknown) => Promise<TCatchResult>): Promise<TResult | TCatchResult>;
    get store(): {
        env: KeyValueStore;
        job: KeyValueStore;
        run: KeyValueStore;
    };
}
type CallbackFunction = (level: "DEBUG" | "INFO" | "WARN" | "ERROR" | "LOG", message: string, properties?: Record<string, any>) => Promise<void>;
export declare class IOLogger implements TaskLogger {
    private callback;
    constructor(callback: CallbackFunction);
    /** Log: essential messages */
    log(message: string, properties?: Record<string, any>): Promise<void>;
    /** For debugging: the least important log level */
    debug(message: string, properties?: Record<string, any>): Promise<void>;
    /** Info: the second least important log level */
    info(message: string, properties?: Record<string, any>): Promise<void>;
    /** Warnings: the third most important log level  */
    warn(message: string, properties?: Record<string, any>): Promise<void>;
    /** Error: The second most important log level */
    error(message: string, properties?: Record<string, any>): Promise<void>;
}
export {};
