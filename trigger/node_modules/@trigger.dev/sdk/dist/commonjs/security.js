"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyRequestSignature = verifyRequestSignature;
exports.verifyHmacSha256 = verifyHmacSha256;
const node_crypto_1 = __importDefault(require("node:crypto"));
/** Easily verify webhook payloads when they're using common signing methods. */
async function verifyRequestSignature({ request, headerName, headerEncoding = "hex", secret, algorithm, }) {
    if (!secret) {
        return {
            success: false,
            reason: "Missing secret â€“ you've probably not set an environment variable.",
        };
    }
    const headerValue = request.headers.get(headerName);
    if (!headerValue) {
        return { success: false, reason: "Missing header" };
    }
    switch (algorithm) {
        case "sha256":
            const success = verifyHmacSha256(headerValue, headerEncoding, secret, await request.text());
            if (success) {
                return {
                    success,
                };
            }
            else {
                return { success: false, reason: "Failed sha256 verification" };
            }
        default:
            throw new Error(`Unsupported algorithm: ${algorithm}`);
    }
}
function verifyHmacSha256(headerValue, headerEncoding, secret, body) {
    const bodyDigest = node_crypto_1.default.createHmac("sha256", secret).update(body).digest(headerEncoding);
    const signature = headerValue?.replace("hmac-sha256=", "").replace("sha256=", "") ?? "";
    return signature === bodyDigest;
}
//# sourceMappingURL=security.js.map