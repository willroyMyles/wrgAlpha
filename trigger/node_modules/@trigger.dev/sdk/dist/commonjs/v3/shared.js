"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunPromise = exports.SubtaskUnwrapError = void 0;
exports.queue = queue;
exports.createTask = createTask;
exports.trigger = trigger;
exports.triggerAndWait = triggerAndWait;
exports.batchTriggerAndWait = batchTriggerAndWait;
exports.triggerAndPoll = triggerAndPoll;
exports.batchTrigger = batchTrigger;
exports.apiClientMissingError = apiClientMissingError;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const v3_1 = require("@trigger.dev/core/v3");
const idempotencyKeys_js_1 = require("./idempotencyKeys.js");
const runs_js_1 = require("./runs.js");
const tracer_js_1 = require("./tracer.js");
function queue(options) {
    return options;
}
class SubtaskUnwrapError extends Error {
    taskId;
    runId;
    cause;
    constructor(taskId, runId, subtaskError) {
        if (subtaskError instanceof Error) {
            super(`Error in ${taskId}: ${subtaskError.message}`, { cause: subtaskError });
            this.name = "SubtaskUnwrapError";
        }
        else {
            super(`Error in ${taskId}`, { cause: subtaskError });
            this.name = "SubtaskUnwrapError";
        }
        this.taskId = taskId;
        this.runId = runId;
    }
}
exports.SubtaskUnwrapError = SubtaskUnwrapError;
class TaskRunPromise extends Promise {
    taskId;
    constructor(executor, taskId) {
        super(executor);
        this.taskId = taskId;
    }
    unwrap() {
        return this.then((result) => {
            if (result.ok) {
                return result.output;
            }
            else {
                throw new SubtaskUnwrapError(this.taskId, result.id, result.error);
            }
        });
    }
}
exports.TaskRunPromise = TaskRunPromise;
function createTask(params) {
    const customQueue = params.queue
        ? queue({
            name: params.queue?.name ?? `task/${params.id}`,
            ...params.queue,
        })
        : undefined;
    const task = {
        id: params.id,
        trigger: async (payload, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await trigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.trigger()`
                : `trigger()`, params.id, payload, {
                queue: customQueue,
                ...options,
            });
        },
        batchTrigger: async (items) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTrigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTrigger()`
                : `batchTrigger()`, params.id, items, undefined, customQueue);
        },
        triggerAndWait: (payload, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return new TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal(taskMetadata && taskMetadata.exportName
                    ? `${taskMetadata.exportName}.triggerAndWait()`
                    : `triggerAndWait()`, params.id, payload, {
                    queue: customQueue,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTriggerAndWait_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTriggerAndWait()`
                : `batchTriggerAndWait()`, params.id, items, undefined, customQueue);
        },
    };
    v3_1.taskCatalog.registerTaskMetadata({
        id: params.id,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: params.machine,
        fns: {
            run: params.run,
            init: params.init,
            cleanup: params.cleanup,
            middleware: params.middleware,
            handleError: params.handleError,
            onSuccess: params.onSuccess,
            onFailure: params.onFailure,
            onStart: params.onStart,
        },
    });
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const handle = await tasks.trigger<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * const run = await runs.retrieve(handle);
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.
 */
async function trigger(id, payload, options, requestOptions) {
    return await trigger_internal("tasks.trigger()", id, payload, options, requestOptions);
}
/**
 * Trigger a task with the given payload, and wait for the result. Returns the result of the task run
 * @param id - The id of the task to trigger
 * @param payload
 * @param options - Options for the task run
 * @returns TaskRunResult
 * @example
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 * const result = await tasks.triggerAndWait("my-task", { foo: "bar" });
 *
 * if (result.ok) {
 *  console.log(result.output);
 * } else {
 *  console.error(result.error);
 * }
 * ```
 */
function triggerAndWait(id, payload, options, requestOptions) {
    return new TaskRunPromise((resolve, reject) => {
        triggerAndWait_internal("tasks.triggerAndWait()", id, payload, options, requestOptions)
            .then((result) => {
            resolve(result);
        })
            .catch((error) => {
            reject(error);
        });
    }, id);
}
/**
 * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.
 * @param id - The id of the task to trigger
 * @param items
 * @returns BatchResult
 * @example
 *
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 *
 * const result = await tasks.batchTriggerAndWait("my-task", [
 *  { payload: { foo: "bar" } },
 *  { payload: { foo: "baz" } },
 * ]);
 *
 * for (const run of result.runs) {
 *  if (run.ok) {
 *    console.log(run.output);
 *  } else {
 *    console.error(run.error);
 *  }
 * }
 * ```
 */
async function batchTriggerAndWait(id, items, requestOptions) {
    return await batchTriggerAndWait_internal("tasks.batchTriggerAndWait()", id, items, requestOptions);
}
/**
 * Trigger a task by its identifier with the given payload and poll until the run is completed.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const run = await tasks.triggerAndPoll<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {Run} The completed run, either successful or failed.
 */
async function triggerAndPoll(id, payload, options, requestOptions) {
    const handle = await trigger(id, payload, options, requestOptions);
    return runs_js_1.runs.poll(handle, options, requestOptions);
}
async function batchTrigger(id, items, requestOptions) {
    return await batchTrigger_internal("tasks.batchTrigger()", id, items, requestOptions);
}
async function trigger_internal(name, id, payload, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const payloadPacket = await (0, v3_1.stringifyIO)(payload);
    const handle = await apiClient.triggerTask(id, {
        payload: payloadPacket.data,
        options: {
            queue: options?.queue,
            concurrencyKey: options?.concurrencyKey,
            test: v3_1.taskContext.ctx?.run.isTest,
            payloadType: payloadPacket.dataType,
            idempotencyKey: await makeKey(options?.idempotencyKey),
            delay: options?.delay,
            ttl: options?.ttl,
            tags: options?.tags,
            maxAttempts: options?.maxAttempts,
            parentAttempt: v3_1.taskContext.ctx?.attempt.id,
        },
    }, {
        spanParentAsLink: true,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        attributes: {
            [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: "publish",
            ["messaging.client_id"]: v3_1.taskContext.worker?.id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "trigger.dev",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
        onResponseBody: (body, span) => {
            body &&
                typeof body === "object" &&
                !Array.isArray(body) &&
                "id" in body &&
                typeof body.id === "string" &&
                span.setAttribute("messaging.message.id", body.id);
        },
        ...requestOptions,
    });
    return handle;
}
async function batchTrigger_internal(name, id, items, requestOptions, queue) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const response = await apiClient.batchTriggerTask(id, {
        items: await Promise.all(items.map(async (item) => {
            const payloadPacket = await (0, v3_1.stringifyIO)(item.payload);
            return {
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ?? queue,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    idempotencyKey: await makeKey(item.options?.idempotencyKey),
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    parentAttempt: v3_1.taskContext.ctx?.attempt.id,
                },
            };
        })),
    }, { spanParentAsLink: true }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        attributes: {
            [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: "publish",
            ["messaging.client_id"]: v3_1.taskContext.worker?.id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "trigger.dev",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.batchId,
        runs: response.runs.map((id) => ({ id })),
    };
    return handle;
}
async function triggerAndWait_internal(name, id, payload, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("triggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    const payloadPacket = await (0, v3_1.stringifyIO)(payload);
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.triggerTask(id, {
            payload: payloadPacket.data,
            options: {
                dependentAttempt: ctx.attempt.id,
                lockToVersion: v3_1.taskContext.worker?.version, // Lock to current version because we're waiting for it to finish
                queue: options?.queue,
                concurrencyKey: options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                idempotencyKey: await makeKey(options?.idempotencyKey),
                delay: options?.delay,
                ttl: options?.ttl,
                tags: options?.tags,
                maxAttempts: options?.maxAttempts,
            },
        }, {}, requestOptions);
        span.setAttribute("messaging.message.id", response.id);
        if (options?.idempotencyKey) {
            // If an idempotency key is provided, we can check if the result is already available
            const result = await apiClient.getRunResult(response.id);
            if (result) {
                v3_1.logger.log(`Result reused from previous task run with idempotency key '${options.idempotencyKey}'.`, {
                    runId: response.id,
                    idempotencyKey: options.idempotencyKey,
                });
                return await handleTaskRunExecutionResult(result);
            }
        }
        const result = await v3_1.runtime.waitForTask({
            id: response.id,
            ctx,
        });
        return await handleTaskRunExecutionResult(result);
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: "publish",
            ["messaging.client_id"]: v3_1.taskContext.worker?.id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "trigger.dev",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function batchTriggerAndWait_internal(name, id, items, requestOptions, queue) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw apiClientMissingError();
    }
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.batchTriggerTask(id, {
            items: await Promise.all(items.map(async (item) => {
                const payloadPacket = await (0, v3_1.stringifyIO)(item.payload);
                return {
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue ?? queue,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        idempotencyKey: await makeKey(item.options?.idempotencyKey),
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                    },
                };
            })),
            dependentAttempt: ctx.attempt.id,
        }, {}, requestOptions);
        span.setAttribute("messaging.message.id", response.batchId);
        const getBatchResults = async () => {
            // We need to check if the results are already available, but only if any of the items options has an idempotency key
            const hasIdempotencyKey = items.some((item) => item.options?.idempotencyKey);
            if (hasIdempotencyKey) {
                const results = await apiClient.getBatchResults(response.batchId);
                if (results) {
                    return results;
                }
            }
            return {
                id: response.batchId,
                items: [],
            };
        };
        const existingResults = await getBatchResults();
        const incompleteRuns = response.runs.filter((runId) => !existingResults.items.some((item) => item.id === runId));
        if (incompleteRuns.length === 0) {
            v3_1.logger.log(`Results reused from previous task runs because of the provided idempotency keys.`);
            // All runs are already completed
            const runs = await handleBatchTaskRunExecutionResult(existingResults.items);
            return {
                id: existingResults.id,
                runs,
            };
        }
        const result = await v3_1.runtime.waitForBatch({
            id: response.batchId,
            runs: incompleteRuns,
            ctx,
        });
        // Combine the already completed runs with the newly completed runs, ordered by the original order
        const combinedItems = [];
        for (const runId of response.runs) {
            const existingItem = existingResults.items.find((item) => item.id === runId);
            if (existingItem) {
                combinedItems.push(existingItem);
            }
            else {
                const newItem = result.items.find((item) => item.id === runId);
                if (newItem) {
                    combinedItems.push(newItem);
                }
            }
        }
        const runs = await handleBatchTaskRunExecutionResult(combinedItems);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ["messaging.batch.message_count"]: items.length,
            [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: "publish",
            ["messaging.client_id"]: v3_1.taskContext.worker?.id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: id,
            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: "trigger.dev",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function handleBatchTaskRunExecutionResult(items) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item);
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item);
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleTaskRunExecutionResult(execution) {
    if (execution.ok) {
        const outputPacket = { data: execution.output, dataType: execution.outputType };
        const importedPacket = await (0, v3_1.conditionallyImportPacket)(outputPacket, tracer_js_1.tracer);
        return {
            ok: true,
            id: execution.id,
            output: await (0, v3_1.parsePacket)(importedPacket),
        };
    }
    else {
        return {
            ok: false,
            id: execution.id,
            error: (0, v3_1.createErrorTaskError)(execution.error),
        };
    }
}
function apiClientMissingError() {
    const hasBaseUrl = !!v3_1.apiClientManager.baseURL;
    const hasAccessToken = !!v3_1.apiClientManager.accessToken;
    if (!hasBaseUrl && !hasAccessToken) {
        return `You need to set the TRIGGER_API_URL and TRIGGER_SECRET_KEY environment variables.`;
    }
    else if (!hasBaseUrl) {
        return `You need to set the TRIGGER_API_URL environment variable.`;
    }
    else if (!hasAccessToken) {
        return `You need to set the TRIGGER_SECRET_KEY environment variable.`;
    }
    return `Unknown error`;
}
async function makeKey(idempotencyKey) {
    if (!idempotencyKey) {
        return;
    }
    if ((0, idempotencyKeys_js_1.isIdempotencyKey)(idempotencyKey)) {
        return idempotencyKey;
    }
    return await idempotencyKeys_js_1.idempotencyKeys.create(idempotencyKey, { scope: "global" });
}
//# sourceMappingURL=shared.js.map