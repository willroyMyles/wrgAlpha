"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runs = void 0;
const v3_1 = require("@trigger.dev/core/v3");
const shared_js_1 = require("./shared.js");
const tracer_js_1 = require("./tracer.js");
const ioSerialization_1 = require("@trigger.dev/core/v3/utils/ioSerialization");
exports.runs = {
    replay: replayRun,
    cancel: cancelRun,
    retrieve: retrieveRun,
    list: listRuns,
    reschedule: rescheduleRun,
    poll,
};
function listRuns(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw (0, shared_js_1.apiClientMissingError)();
    }
    const $requestOptions = listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions);
    if (typeof paramsOrProjectRef === "string") {
        if ((0, v3_1.isRequestOptions)(paramsOrOptions)) {
            return apiClient.listProjectRuns(paramsOrProjectRef, {}, $requestOptions);
        }
        else {
            return apiClient.listProjectRuns(paramsOrProjectRef, paramsOrOptions, $requestOptions);
        }
    }
    return apiClient.listRuns(paramsOrProjectRef, $requestOptions);
}
function listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    if (typeof paramsOrProjectRef === "string") {
        if ((0, v3_1.isRequestOptions)(paramsOrOptions)) {
            return (0, v3_1.mergeRequestOptions)({
                tracer: tracer_js_1.tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, paramsOrOptions);
        }
        else {
            return (0, v3_1.mergeRequestOptions)({
                tracer: tracer_js_1.tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...(0, v3_1.flattenAttributes)(paramsOrOptions, "queryParams"),
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, requestOptions);
        }
    }
    return (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.list()",
        icon: "runs",
        attributes: {
            ...(0, v3_1.flattenAttributes)(paramsOrProjectRef, "queryParams"),
        },
    }, (0, v3_1.isRequestOptions)(paramsOrOptions) ? paramsOrOptions : requestOptions);
}
function retrieveRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw (0, shared_js_1.apiClientMissingError)();
    }
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.retrieve()",
        icon: "runs",
        attributes: {
            runId: typeof runId === "string" ? runId : runId.id,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: typeof runId === "string" ? runId : runId.id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    const $runId = typeof runId === "string" ? runId : runId.id;
    return apiClient.retrieveRun($runId, $requestOptions).then((retrievedRun) => {
        return resolvePayloadAndOutputUrls(retrievedRun);
    });
}
async function resolvePayloadAndOutputUrls(run) {
    const resolvedRun = { ...run };
    if (run.payloadPresignedUrl && run.outputPresignedUrl) {
        const [payload, output] = await Promise.all([
            (0, ioSerialization_1.resolvePresignedPacketUrl)(run.payloadPresignedUrl, tracer_js_1.tracer),
            (0, ioSerialization_1.resolvePresignedPacketUrl)(run.outputPresignedUrl, tracer_js_1.tracer),
        ]);
        resolvedRun.payload = payload;
        resolvedRun.output = output;
    }
    else if (run.payloadPresignedUrl) {
        resolvedRun.payload = await (0, ioSerialization_1.resolvePresignedPacketUrl)(run.payloadPresignedUrl, tracer_js_1.tracer);
    }
    else if (run.outputPresignedUrl) {
        resolvedRun.output = await (0, ioSerialization_1.resolvePresignedPacketUrl)(run.outputPresignedUrl, tracer_js_1.tracer);
    }
    return resolvedRun;
}
function replayRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw (0, shared_js_1.apiClientMissingError)();
    }
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.replay()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.replayRun(runId, $requestOptions);
}
function cancelRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw (0, shared_js_1.apiClientMissingError)();
    }
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.cancel()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.cancelRun(runId, $requestOptions);
}
function rescheduleRun(runId, body, requestOptions) {
    const apiClient = v3_1.apiClientManager.client;
    if (!apiClient) {
        throw (0, shared_js_1.apiClientMissingError)();
    }
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.reschedule()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.rescheduleRun(runId, body, $requestOptions);
}
const MAX_POLL_ATTEMPTS = 500;
async function poll(runId, options, requestOptions) {
    let attempts = 0;
    while (attempts++ < MAX_POLL_ATTEMPTS) {
        const run = await exports.runs.retrieve(runId, requestOptions);
        if (run.isCompleted) {
            return run;
        }
        await new Promise((resolve) => setTimeout(resolve, options?.pollIntervalMs ?? 1000));
    }
    throw new Error(`Run ${typeof runId === "string" ? runId : runId.id} did not complete after ${MAX_POLL_ATTEMPTS} attempts`);
}
//# sourceMappingURL=runs.js.map