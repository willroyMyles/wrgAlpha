"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicTrigger = void 0;
const core_1 = require("@trigger.dev/core");
const utils_js_1 = require("../utils.js");
const runLocalStorage_js_1 = require("../runLocalStorage.js");
/** `DynamicTrigger` allows you to define a trigger that can be configured dynamically at runtime. */
class DynamicTrigger {
    #client;
    #options;
    source;
    /** `DynamicTrigger` allows you to define a trigger that can be configured dynamically at runtime.
     * @param client The `TriggerClient` instance to use for registering the trigger.
     * @param options The options for the dynamic trigger.
     * */
    constructor(client, options) {
        this.#client = client;
        this.#options = options;
        this.source = options.source;
        client.attachDynamicTrigger(this);
    }
    toJSON() {
        return {
            type: "dynamic",
            id: this.#options.id,
        };
    }
    get id() {
        return this.#options.id;
    }
    get event() {
        return this.#options.event;
    }
    // @internal
    registeredTriggerForParams(params, options = {}) {
        const key = (0, utils_js_1.slugifyId)(this.source.key(params));
        return {
            rule: {
                event: this.event.name,
                source: this.event.source,
                payload: (0, core_1.deepMergeFilters)(this.source.filter(params), this.event.filter ?? {}, options.filter ?? {}),
            },
            source: {
                version: "2",
                key,
                channel: this.source.channel,
                params,
                //todo add other options here
                options: {
                    event: typeof this.event.name === "string" ? [this.event.name] : this.event.name,
                },
                integration: {
                    id: this.source.integration.id,
                    metadata: this.source.integration.metadata,
                    authSource: this.source.integration.authSource,
                },
            },
            accountId: options.accountId,
        };
    }
    /** Use this method to register a new configuration with the DynamicTrigger.
     * @param key The key for the configuration. This will be used to identify the configuration when it is triggered.
     * @param params The params for the configuration.
     * @param options Options for the configuration.
     * @param options.accountId The accountId to associate with the configuration.
     * @param options.filter The filter to use for the configuration.
     *
     */
    async register(key, params, options = {}) {
        const runStore = runLocalStorage_js_1.runLocalStorage.getStore();
        if (!runStore) {
            return this.#client.registerTrigger(this.id, key, this.registeredTriggerForParams(params, options));
        }
        const { io } = runStore;
        return await io.runTask([key, "register"], async (task) => {
            return this.#client.registerTrigger(this.id, key, this.registeredTriggerForParams(params, options), task.idempotencyKey);
        }, {
            name: "Register Dynamic Trigger",
            properties: [
                { label: "Dynamic Trigger ID", text: this.id },
                { label: "ID", text: key },
            ],
            params: params,
        });
    }
    attachToJob(triggerClient, job) {
        triggerClient.attachJobToDynamicTrigger(job, this);
    }
    get preprocessRuns() {
        return true;
    }
    async verifyPayload(payload) {
        return { success: true };
    }
}
exports.DynamicTrigger = DynamicTrigger;
//# sourceMappingURL=dynamic.js.map