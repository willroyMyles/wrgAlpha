"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvokeTrigger = void 0;
exports.invokeTrigger = invokeTrigger;
const errors_js_1 = require("../errors.js");
const formatSchemaErrors_js_1 = require("../utils/formatSchemaErrors.js");
class InvokeTrigger {
    #options;
    constructor(options) {
        this.#options = options;
    }
    toJSON() {
        return {
            type: "invoke",
        };
    }
    get event() {
        return {
            name: "invoke",
            title: "Manual Invoke",
            source: "trigger.dev",
            examples: this.#options.examples ?? [],
            icon: "trigger",
            parsePayload: (rawPayload) => {
                if (this.#options.schema) {
                    const results = this.#options.schema.safeParse(rawPayload);
                    if (!results.success) {
                        throw new errors_js_1.ParsedPayloadSchemaError((0, formatSchemaErrors_js_1.formatSchemaErrors)(results.error.issues));
                    }
                    return results.data;
                }
                return rawPayload;
            },
            parseInvokePayload: (rawPayload) => {
                if (this.#options.schema) {
                    const results = this.#options.schema.safeParse(rawPayload);
                    if (!results.success) {
                        throw new errors_js_1.ParsedPayloadSchemaError((0, formatSchemaErrors_js_1.formatSchemaErrors)(results.error.issues));
                    }
                    return results.data;
                }
                return rawPayload;
            },
        };
    }
    attachToJob(triggerClient, job) { }
    get preprocessRuns() {
        return false;
    }
    async verifyPayload() {
        return { success: true };
    }
}
exports.InvokeTrigger = InvokeTrigger;
function invokeTrigger(options) {
    return new InvokeTrigger(options ?? {});
}
//# sourceMappingURL=invokeTrigger.js.map