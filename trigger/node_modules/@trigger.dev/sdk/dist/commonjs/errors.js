"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorWithTask = exports.ParsedPayloadSchemaError = exports.AutoYieldRateLimitError = exports.AutoYieldWithCompletedTaskExecutionError = exports.AutoYieldExecutionError = exports.YieldExecutionError = exports.CanceledWithTaskError = exports.RetryWithTaskError = exports.ResumeWithParallelTaskError = exports.ResumeWithTaskError = void 0;
exports.isTriggerError = isTriggerError;
class ResumeWithTaskError {
    task;
    constructor(task) {
        this.task = task;
    }
}
exports.ResumeWithTaskError = ResumeWithTaskError;
class ResumeWithParallelTaskError {
    task;
    childErrors;
    constructor(task, childErrors) {
        this.task = task;
        this.childErrors = childErrors;
    }
}
exports.ResumeWithParallelTaskError = ResumeWithParallelTaskError;
class RetryWithTaskError {
    cause;
    task;
    retryAt;
    constructor(cause, task, retryAt) {
        this.cause = cause;
        this.task = task;
        this.retryAt = retryAt;
    }
}
exports.RetryWithTaskError = RetryWithTaskError;
class CanceledWithTaskError {
    task;
    constructor(task) {
        this.task = task;
    }
}
exports.CanceledWithTaskError = CanceledWithTaskError;
class YieldExecutionError {
    key;
    constructor(key) {
        this.key = key;
    }
}
exports.YieldExecutionError = YieldExecutionError;
class AutoYieldExecutionError {
    location;
    timeRemaining;
    timeElapsed;
    constructor(location, timeRemaining, timeElapsed) {
        this.location = location;
        this.timeRemaining = timeRemaining;
        this.timeElapsed = timeElapsed;
    }
}
exports.AutoYieldExecutionError = AutoYieldExecutionError;
class AutoYieldWithCompletedTaskExecutionError {
    id;
    properties;
    data;
    output;
    constructor(id, properties, data, output) {
        this.id = id;
        this.properties = properties;
        this.data = data;
        this.output = output;
    }
}
exports.AutoYieldWithCompletedTaskExecutionError = AutoYieldWithCompletedTaskExecutionError;
class AutoYieldRateLimitError {
    resetAtTimestamp;
    constructor(resetAtTimestamp) {
        this.resetAtTimestamp = resetAtTimestamp;
    }
}
exports.AutoYieldRateLimitError = AutoYieldRateLimitError;
class ParsedPayloadSchemaError {
    schemaErrors;
    constructor(schemaErrors) {
        this.schemaErrors = schemaErrors;
    }
}
exports.ParsedPayloadSchemaError = ParsedPayloadSchemaError;
/** Use this function if you're using a `try/catch` block to catch errors.
 * It checks if a thrown error is a special internal error that you should ignore.
 * If this returns `true` then you must rethrow the error: `throw err;`
 * @param err The error to check
 * @returns `true` if the error is a Trigger Error, `false` otherwise.
 */
function isTriggerError(err) {
    return (err instanceof ResumeWithTaskError ||
        err instanceof RetryWithTaskError ||
        err instanceof CanceledWithTaskError ||
        err instanceof YieldExecutionError ||
        err instanceof AutoYieldExecutionError ||
        err instanceof AutoYieldWithCompletedTaskExecutionError ||
        err instanceof AutoYieldRateLimitError ||
        err instanceof ResumeWithParallelTaskError);
}
// This error isn't an internal error but it can be used by the user to figure out which task caused the error
class ErrorWithTask extends Error {
    cause;
    constructor(cause, message) {
        super(message);
        this.cause = cause;
    }
}
exports.ErrorWithTask = ErrorWithTask;
//# sourceMappingURL=errors.js.map