"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrismaExtension = void 0;
exports.prismaExtension = prismaExtension;
const build_1 = require("@trigger.dev/core/v3/build");
const node_assert_1 = __importDefault(require("node:assert"));
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const BINARY_TARGET = "linux-arm64-openssl-3.0.x";
function prismaExtension(options) {
    return new PrismaExtension(options);
}
class PrismaExtension {
    options;
    moduleExternals;
    name = "PrismaExtension";
    _resolvedSchemaPath;
    constructor(options) {
        this.options = options;
        this.moduleExternals = ["@prisma/client", "@prisma/engines"];
    }
    externalsForTarget(target) {
        if (target === "dev") {
            return [];
        }
        return this.moduleExternals;
    }
    async onBuildStart(context) {
        if (context.target === "dev") {
            return;
        }
        // Resolve the path to the prisma schema, relative to the config.directory
        this._resolvedSchemaPath = (0, node_path_1.resolve)(context.workingDir, this.options.schema);
        context.logger.debug(`Resolved the prisma schema to: ${this._resolvedSchemaPath}`);
        // Check that the prisma schema exists
        if (!(0, node_fs_1.existsSync)(this._resolvedSchemaPath)) {
            throw new Error(`PrismaExtension could not find the prisma schema at ${this._resolvedSchemaPath}. Make sure the path is correct: ${this.options.schema}, relative to the working dir ${context.workingDir}`);
        }
    }
    async onBuildComplete(context, manifest) {
        if (context.target === "dev") {
            return;
        }
        (0, node_assert_1.default)(this._resolvedSchemaPath, "Resolved schema path is not set");
        context.logger.debug("Looking for @prisma/client in the externals", {
            externals: manifest.externals,
        });
        const prismaExternal = manifest.externals?.find((external) => external.name === "@prisma/client");
        const version = prismaExternal?.version ?? this.options.version;
        if (!version) {
            throw new Error(`PrismaExtension could not determine the version of @prisma/client. It's possible that the @prisma/client was not used in the project. If this isn't the case, please provide a version in the PrismaExtension options.`);
        }
        context.logger.debug(`PrismaExtension is generating the Prisma client for version ${version}`);
        const usingSchemaFolder = (0, node_path_1.dirname)(this._resolvedSchemaPath).endsWith("schema");
        const commands = [];
        let prismaDir;
        const generatorFlags = [];
        if (this.options.clientGenerator) {
            generatorFlags.push(`--generator=${this.options.clientGenerator}`);
        }
        if (this.options.typedSql) {
            generatorFlags.push(`--sql`);
            const prismaDir = usingSchemaFolder
                ? (0, node_path_1.dirname)((0, node_path_1.dirname)(this._resolvedSchemaPath))
                : (0, node_path_1.dirname)(this._resolvedSchemaPath);
            context.logger.debug(`Using typedSql`);
            // Find all the files prisma/sql/*.sql
            const sqlFiles = await (0, promises_1.readdir)((0, node_path_1.join)(prismaDir, "sql")).then((files) => files.filter((file) => file.endsWith(".sql")));
            context.logger.debug(`Found sql files`, {
                sqlFiles,
            });
            const sqlDestinationPath = (0, node_path_1.join)(manifest.outputPath, "prisma", "sql");
            for (const file of sqlFiles) {
                const destination = (0, node_path_1.join)(sqlDestinationPath, file);
                const source = (0, node_path_1.join)(prismaDir, "sql", file);
                context.logger.debug(`Copying the sql from ${source} to ${destination}`);
                await (0, promises_1.cp)(source, destination);
            }
        }
        if (usingSchemaFolder) {
            const schemaDir = (0, node_path_1.dirname)(this._resolvedSchemaPath);
            prismaDir = (0, node_path_1.dirname)(schemaDir);
            context.logger.debug(`Using the schema folder: ${schemaDir}`);
            // Find all the files in schemaDir that end with .prisma (excluding the schema.prisma file)
            const prismaFiles = await (0, promises_1.readdir)(schemaDir).then((files) => files.filter((file) => file.endsWith(".prisma")));
            context.logger.debug(`Found prisma files in the schema folder`, {
                prismaFiles,
            });
            const schemaDestinationPath = (0, node_path_1.join)(manifest.outputPath, "prisma", "schema");
            const allPrismaFiles = [...prismaFiles];
            for (const file of allPrismaFiles) {
                const destination = (0, node_path_1.join)(schemaDestinationPath, file);
                const source = (0, node_path_1.join)(schemaDir, file);
                context.logger.debug(`Copying the prisma schema from ${source} to ${destination}`);
                await (0, promises_1.cp)(source, destination);
            }
            commands.push(`${(0, build_1.binaryForRuntime)(manifest.runtime)} node_modules/prisma/build/index.js generate ${generatorFlags.join(" ")}` // Don't add the --schema flag or this will fail
            );
        }
        else {
            prismaDir = (0, node_path_1.dirname)(this._resolvedSchemaPath);
            // Now we need to add a layer that:
            // Copies the prisma schema to the build outputPath
            // Adds the `prisma` CLI dependency to the dependencies
            // Adds the `prisma generate` command, which generates the Prisma client
            const schemaDestinationPath = (0, node_path_1.join)(manifest.outputPath, "prisma", "schema.prisma");
            // Copy the prisma schema to the build output path
            context.logger.debug(`Copying the prisma schema from ${this._resolvedSchemaPath} to ${schemaDestinationPath}`);
            await (0, promises_1.cp)(this._resolvedSchemaPath, schemaDestinationPath);
            commands.push(`${(0, build_1.binaryForRuntime)(manifest.runtime)} node_modules/prisma/build/index.js generate --schema=./prisma/schema.prisma ${generatorFlags.join(" ")}`);
        }
        const env = {};
        if (this.options.migrate) {
            // Copy the migrations directory to the build output path
            const migrationsDir = (0, node_path_1.join)(prismaDir, "migrations");
            const migrationsDestinationPath = (0, node_path_1.join)(manifest.outputPath, "prisma", "migrations");
            context.logger.debug(`Copying the prisma migrations from ${migrationsDir} to ${migrationsDestinationPath}`);
            await (0, promises_1.cp)(migrationsDir, migrationsDestinationPath, { recursive: true });
            commands.push(`${(0, build_1.binaryForRuntime)(manifest.runtime)} node_modules/prisma/build/index.js migrate deploy`);
        }
        env.DATABASE_URL = manifest.deploy.env?.DATABASE_URL;
        if (this.options.directUrlEnvVarName) {
            env[this.options.directUrlEnvVarName] =
                manifest.deploy.env?.[this.options.directUrlEnvVarName] ??
                    process.env[this.options.directUrlEnvVarName];
            if (!env[this.options.directUrlEnvVarName]) {
                context.logger.warn(`prismaExtension could not resolve the ${this.options.directUrlEnvVarName} environment variable. Make sure you add it to your environment variables or provide it as an environment variable to the deploy CLI command. See our docs for more info: https://trigger.dev/docs/deploy-environment-variables`);
            }
        }
        else {
            env.DIRECT_URL = manifest.deploy.env?.DIRECT_URL;
            env.DIRECT_DATABASE_URL = manifest.deploy.env?.DIRECT_DATABASE_URL;
        }
        if (!env.DATABASE_URL) {
            context.logger.warn(`prismaExtension could not resolve the DATABASE_URL environment variable. Make sure you add it to your environment variables. See our docs for more info: https://trigger.dev/docs/deploy-environment-variables`);
        }
        context.logger.debug(`Adding the prisma layer with the following commands`, {
            commands,
            env,
            dependencies: {
                prisma: version,
            },
        });
        context.addLayer({
            id: "prisma",
            commands,
            dependencies: {
                prisma: version,
            },
            build: {
                env,
            },
        });
    }
}
exports.PrismaExtension = PrismaExtension;
//# sourceMappingURL=prisma.js.map