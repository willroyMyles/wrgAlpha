"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.additionalFiles = additionalFiles;
const node_path_1 = require("node:path");
const tinyglobby_1 = require("tinyglobby");
const promises_1 = require("node:fs/promises");
function additionalFiles(options) {
    return {
        name: "additionalFiles",
        async onBuildComplete(context, manifest) {
            // Copy any static assets to the destination
            const staticAssets = await findStaticAssetFiles(options.files ?? [], manifest.outputPath, {
                cwd: context.workingDir,
            });
            for (const { assets, matcher } of staticAssets) {
                if (assets.length === 0) {
                    console.warn("No files found for matcher", matcher);
                }
            }
            await copyStaticAssets(staticAssets);
        },
    };
}
async function findStaticAssetFiles(matchers, destinationPath, options) {
    const result = [];
    for (const matcher of matchers) {
        const assets = await findStaticAssetsForMatcher(matcher, destinationPath, options);
        result.push({ matcher, assets });
    }
    return result;
}
async function findStaticAssetsForMatcher(matcher, destinationPath, options) {
    const result = [];
    const files = await (0, tinyglobby_1.glob)({
        patterns: [matcher],
        cwd: options?.cwd,
        ignore: options?.ignore ?? [],
        onlyFiles: true,
        absolute: true,
    });
    let matches = 0;
    for (const file of files) {
        matches++;
        const pathInsideDestinationDir = (0, node_path_1.relative)(options?.cwd ?? process.cwd(), file)
            .split(node_path_1.posix.sep)
            .filter((p) => p !== "..")
            .join(node_path_1.posix.sep);
        const relativeDestinationPath = (0, node_path_1.join)(destinationPath, pathInsideDestinationDir);
        result.push({
            source: file,
            destination: relativeDestinationPath,
        });
    }
    return result;
}
async function copyStaticAssets(staticAssetFiles) {
    for (const { assets } of staticAssetFiles) {
        for (const { source, destination } of assets) {
            await (0, promises_1.mkdir)((0, node_path_1.dirname)(destination), { recursive: true });
            await (0, promises_1.copyFile)(source, destination);
        }
    }
}
//# sourceMappingURL=additionalFiles.js.map