import { z } from "zod";
export declare const stringPatternMatchers: readonly [z.ZodObject<{
    $endsWith: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $endsWith: string;
}, {
    $endsWith: string;
}>, z.ZodObject<{
    $startsWith: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $startsWith: string;
}, {
    $startsWith: string;
}>, z.ZodObject<{
    $ignoreCaseEquals: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $ignoreCaseEquals: string;
}, {
    $ignoreCaseEquals: string;
}>];
declare const EventMatcherSchema: z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodNumber, "many">, z.ZodArray<z.ZodBoolean, "many">, z.ZodArray<z.ZodUnion<[z.ZodObject<{
    $endsWith: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $endsWith: string;
}, {
    $endsWith: string;
}>, z.ZodObject<{
    $startsWith: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $startsWith: string;
}, {
    $startsWith: string;
}>, z.ZodObject<{
    $ignoreCaseEquals: z.ZodString;
}, "strip", z.ZodTypeAny, {
    $ignoreCaseEquals: string;
}, {
    $ignoreCaseEquals: string;
}>, z.ZodObject<{
    $exists: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    $exists: boolean;
}, {
    $exists: boolean;
}>, z.ZodObject<{
    $isNull: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    $isNull: boolean;
}, {
    $isNull: boolean;
}>, z.ZodObject<{
    $anythingBut: z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>;
}, "strip", z.ZodTypeAny, {
    $anythingBut: string | number | boolean;
}, {
    $anythingBut: string | number | boolean;
}>, z.ZodObject<{
    $anythingBut: z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodNumber, "many">, z.ZodArray<z.ZodBoolean, "many">]>;
}, "strip", z.ZodTypeAny, {
    $anythingBut: (string[] | number[] | boolean[]) & (string[] | number[] | boolean[] | undefined);
}, {
    $anythingBut: (string[] | number[] | boolean[]) & (string[] | number[] | boolean[] | undefined);
}>, z.ZodObject<{
    $gt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    $gt: number;
}, {
    $gt: number;
}>, z.ZodObject<{
    $lt: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    $lt: number;
}, {
    $lt: number;
}>, z.ZodObject<{
    $gte: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    $gte: number;
}, {
    $gte: number;
}>, z.ZodObject<{
    $lte: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    $lte: number;
}, {
    $lte: number;
}>, z.ZodObject<{
    $between: z.ZodTuple<[z.ZodNumber, z.ZodNumber], null>;
}, "strip", z.ZodTypeAny, {
    $between: [number, number];
}, {
    $between: [number, number];
}>, z.ZodObject<{
    $includes: z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>;
}, "strip", z.ZodTypeAny, {
    $includes: string | number | boolean;
}, {
    $includes: string | number | boolean;
}>, z.ZodObject<{
    $not: z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>;
}, "strip", z.ZodTypeAny, {
    $not: string | number | boolean;
}, {
    $not: string | number | boolean;
}>]>, "many">]>;
type EventMatcher = z.infer<typeof EventMatcherSchema>;
/** A filter for matching against data */
export type EventFilter = {
    [key: string]: EventMatcher | EventFilter;
};
export declare const EventFilterSchema: z.ZodType<EventFilter>;
export declare const EventRuleSchema: z.ZodObject<{
    event: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>;
    source: z.ZodString;
    payload: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
    context: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
}, "strip", z.ZodTypeAny, {
    event: (string | string[]) & (string | string[] | undefined);
    source: string;
    payload?: EventFilter | undefined;
    context?: EventFilter | undefined;
}, {
    event: (string | string[]) & (string | string[] | undefined);
    source: string;
    payload?: EventFilter | undefined;
    context?: EventFilter | undefined;
}>;
export type EventRule = z.infer<typeof EventRuleSchema>;
export {};
