"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunJobBodySchema = exports.AutoYieldConfigSchema = exports.RunSourceContextSchema = exports.RuntimeEnvironmentTypeSchema = exports.DeliverEventResponseSchema = exports.SendBulkEventsBodySchema = exports.SendEventBodySchema = exports.SendEventOptionsSchema = exports.ApiEventLogSchema = exports.RawEventSchema = exports.ExecuteJobHeadersSchema = exports.ExecuteJobRunMetadataSchema = exports.EndpointHeadersSchema = exports.GetEndpointIndexResponseSchema = exports.EndpointIndexErrorSchema = exports.IndexEndpointResponseSchema = exports.DynamicTriggerEndpointMetadataSchema = exports.WebhookContextMetadataSchema = exports.WebhookMetadataSchema = exports.SourceMetadataV2Schema = exports.JobMetadataSchema = exports.ConcurrencyLimitOptionsSchema = exports.QueueOptionsSchema = exports.ValidateResponseSchema = exports.ValidateErrorResponseSchema = exports.ValidateSuccessResponseSchema = exports.PongResponseSchema = exports.PongErrorResponseSchema = exports.PongSuccessResponseSchema = exports.WebhookSourceRequestHeadersSchema = exports.HttpEndpointRequestHeadersSchema = exports.HttpSourceRequestHeadersSchema = exports.HandleTriggerSourceSchema = exports.TriggerSourceSchema = exports.RegisterSourceEventSchemaV2 = exports.RegisterSourceEventSchemaV1 = exports.RegisterTriggerSourceSchema = exports.REGISTER_SOURCE_EVENT_V2 = exports.REGISTER_SOURCE_EVENT_V1 = exports.RegisterWebhookPayloadSchema = exports.RegisterWebhookSourceSchema = exports.DELIVER_WEBHOOK_REQUEST = exports.REGISTER_WEBHOOK = exports.RegisterSourceChannelBodySchema = exports.RegisterSQSTriggerSourceBodySchema = exports.RegisterSMTPTriggerSourceBodySchema = exports.RegisterHTTPTriggerSourceBodySchema = exports.UpdateWebhookBodySchema = exports.UpdateTriggerSourceBodyV2Schema = exports.UpdateTriggerSourceBodyV1Schema = void 0;
exports.KeyValueStoreResponseBodySchema = exports.EphemeralEventDispatcherResponseBodySchema = exports.EphemeralEventDispatcherRequestBodySchema = exports.InvokeOptionsSchema = exports.InvokeJobRequestBodySchema = exports.InvokeJobResponseSchema = exports.GetRunStatusesSchema = exports.CreateExternalConnectionBodySchema = exports.RegisterScheduleResponseBodySchema = exports.RegisterScheduleBodySchema = exports.InitializeCronScheduleBodySchema = exports.RegisterIntervalScheduleBodySchema = exports.InitializeTriggerBodySchema = exports.RegisterTriggerBodySchemaV2 = exports.RegisterTriggerBodySchemaV1 = exports.WebhookDeliveryResponseSchema = exports.HttpSourceResponseSchema = exports.NormalizedResponseSchema = exports.NormalizedRequestSchema = exports.FailTaskBodyInputSchema = exports.CompleteTaskBodyV2InputSchema = exports.CompleteTaskBodyInputSchema = exports.RunTaskResponseWithCachedTasksBodySchema = exports.RunTaskBodyOutputSchema = exports.RunTaskBodyInputSchema = exports.RunTaskOptionsSchema = exports.RetryOptionsSchema = exports.RedactSchema = exports.LogMessageSchema = exports.RedactStringSchema = exports.CreateRunResponseBodySchema = exports.PreprocessRunResponseSchema = exports.PreprocessRunBodySchema = exports.RunJobResponseSchema = exports.RunJobResumeWithParallelTaskSchema = exports.RunJobErrorResponseSchema = exports.RunJobSuccessSchema = exports.RunJobCanceledWithTaskSchema = exports.RunJobRetryWithTaskSchema = exports.RunJobResumeWithTaskSchema = exports.RunJobUnresolvedAuthErrorSchema = exports.RunJobInvalidPayloadErrorSchema = exports.RunJobAutoYieldRateLimitErrorSchema = exports.RunJobAutoYieldWithCompletedTaskExecutionErrorSchema = exports.RunJobAutoYieldExecutionErrorSchema = exports.AutoYieldMetadataSchema = exports.RunJobYieldExecutionErrorSchema = exports.RunJobErrorSchema = void 0;
exports.parseEndpointIndexStats = parseEndpointIndexStats;
const zod_1 = require("zod");
const addMissingVersionField_js_1 = require("./addMissingVersionField.js");
const errors_js_1 = require("./errors.js");
const eventFilter_js_1 = require("./eventFilter.js");
const integrations_js_1 = require("./integrations.js");
const json_js_1 = require("./json.js");
const properties_js_1 = require("./properties.js");
const schedules_js_1 = require("./schedules.js");
const tasks_js_1 = require("./tasks.js");
const triggers_js_1 = require("./triggers.js");
const runs_js_1 = require("./runs.js");
const statuses_js_1 = require("./statuses.js");
const requestFilter_js_1 = require("./requestFilter.js");
exports.UpdateTriggerSourceBodyV1Schema = zod_1.z.object({
    registeredEvents: zod_1.z.array(zod_1.z.string()),
    secret: zod_1.z.string().optional(),
    data: json_js_1.SerializableJsonSchema.optional(),
});
exports.UpdateTriggerSourceBodyV2Schema = zod_1.z.object({
    secret: zod_1.z.string().optional(),
    data: json_js_1.SerializableJsonSchema.optional(),
    options: zod_1.z
        .object({
        event: zod_1.z.array(zod_1.z.string()),
    })
        .and(zod_1.z.record(zod_1.z.string(), zod_1.z.array(zod_1.z.string())).optional()),
});
exports.UpdateWebhookBodySchema = zod_1.z.discriminatedUnion("active", [
    zod_1.z.object({
        active: zod_1.z.literal(false),
    }),
    zod_1.z.object({
        active: zod_1.z.literal(true),
        config: zod_1.z.record(zod_1.z.string().array()),
    }),
]);
exports.RegisterHTTPTriggerSourceBodySchema = zod_1.z.object({
    type: zod_1.z.literal("HTTP"),
    url: zod_1.z.string().url(),
});
exports.RegisterSMTPTriggerSourceBodySchema = zod_1.z.object({
    type: zod_1.z.literal("SMTP"),
});
exports.RegisterSQSTriggerSourceBodySchema = zod_1.z.object({
    type: zod_1.z.literal("SQS"),
});
exports.RegisterSourceChannelBodySchema = zod_1.z.discriminatedUnion("type", [
    exports.RegisterHTTPTriggerSourceBodySchema,
    exports.RegisterSMTPTriggerSourceBodySchema,
    exports.RegisterSQSTriggerSourceBodySchema,
]);
exports.REGISTER_WEBHOOK = "dev.trigger.webhook.register";
exports.DELIVER_WEBHOOK_REQUEST = "dev.trigger.webhook.deliver";
exports.RegisterWebhookSourceSchema = zod_1.z.object({
    key: zod_1.z.string(),
    params: zod_1.z.any(),
    config: zod_1.z.any(),
    active: zod_1.z.boolean(),
    secret: zod_1.z.string(),
    url: zod_1.z.string(),
    data: json_js_1.DeserializedJsonSchema.optional(),
    clientId: zod_1.z.string().optional(),
});
exports.RegisterWebhookPayloadSchema = zod_1.z.object({
    active: zod_1.z.boolean(),
    params: zod_1.z.any().optional(),
    config: zod_1.z.object({
        current: zod_1.z.record(zod_1.z.string().array()),
        desired: zod_1.z.record(zod_1.z.string().array()),
    }),
    // from HTTP Endpoint
    url: zod_1.z.string(),
    secret: zod_1.z.string(),
});
exports.REGISTER_SOURCE_EVENT_V1 = "dev.trigger.source.register";
exports.REGISTER_SOURCE_EVENT_V2 = "dev.trigger.source.register.v2";
exports.RegisterTriggerSourceSchema = zod_1.z.object({
    key: zod_1.z.string(),
    params: zod_1.z.any(),
    active: zod_1.z.boolean(),
    secret: zod_1.z.string(),
    data: json_js_1.DeserializedJsonSchema.optional(),
    channel: exports.RegisterSourceChannelBodySchema,
    clientId: zod_1.z.string().optional(),
});
const SourceEventOptionSchema = zod_1.z.object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
});
exports.RegisterSourceEventSchemaV1 = zod_1.z.object({
    /** The id of the source */
    id: zod_1.z.string(),
    source: exports.RegisterTriggerSourceSchema,
    events: zod_1.z.array(zod_1.z.string()),
    missingEvents: zod_1.z.array(zod_1.z.string()),
    orphanedEvents: zod_1.z.array(zod_1.z.string()),
    dynamicTriggerId: zod_1.z.string().optional(),
});
const RegisteredOptionsDiffSchema = zod_1.z.object({
    desired: zod_1.z.array(zod_1.z.string()),
    missing: zod_1.z.array(zod_1.z.string()),
    orphaned: zod_1.z.array(zod_1.z.string()),
});
const RegisterSourceEventOptionsSchema = zod_1.z
    .object({
    event: RegisteredOptionsDiffSchema,
})
    .and(zod_1.z.record(zod_1.z.string(), RegisteredOptionsDiffSchema));
exports.RegisterSourceEventSchemaV2 = zod_1.z.object({
    /** The id of the source */
    id: zod_1.z.string(),
    source: exports.RegisterTriggerSourceSchema,
    options: RegisterSourceEventOptionsSchema,
    dynamicTriggerId: zod_1.z.string().optional(),
});
exports.TriggerSourceSchema = zod_1.z.object({
    id: zod_1.z.string(),
    key: zod_1.z.string(),
});
const HttpSourceResponseMetadataSchema = json_js_1.DeserializedJsonSchema;
exports.HandleTriggerSourceSchema = zod_1.z.object({
    key: zod_1.z.string(),
    secret: zod_1.z.string(),
    data: zod_1.z.any(),
    params: zod_1.z.any(),
    auth: integrations_js_1.ConnectionAuthSchema.optional(),
    metadata: HttpSourceResponseMetadataSchema.optional(),
});
exports.HttpSourceRequestHeadersSchema = zod_1.z.object({
    "x-ts-key": zod_1.z.string(),
    "x-ts-dynamic-id": zod_1.z.string().optional(),
    "x-ts-secret": zod_1.z.string(),
    "x-ts-data": zod_1.z.string().transform((s) => JSON.parse(s)),
    "x-ts-params": zod_1.z.string().transform((s) => JSON.parse(s)),
    "x-ts-http-url": zod_1.z.string(),
    "x-ts-http-method": zod_1.z.string(),
    "x-ts-http-headers": zod_1.z.string().transform((s) => zod_1.z.record(zod_1.z.string()).parse(JSON.parse(s))),
    "x-ts-auth": zod_1.z
        .string()
        .optional()
        .transform((s) => {
        if (s === undefined)
            return;
        const json = JSON.parse(s);
        return integrations_js_1.ConnectionAuthSchema.parse(json);
    }),
    "x-ts-metadata": zod_1.z
        .string()
        .optional()
        .transform((s) => {
        if (s === undefined)
            return;
        const json = JSON.parse(s);
        return json_js_1.DeserializedJsonSchema.parse(json);
    }),
});
exports.HttpEndpointRequestHeadersSchema = zod_1.z.object({
    "x-ts-key": zod_1.z.string(),
    "x-ts-http-url": zod_1.z.string(),
    "x-ts-http-method": zod_1.z.string(),
    "x-ts-http-headers": zod_1.z.string().transform((s) => zod_1.z.record(zod_1.z.string()).parse(JSON.parse(s))),
});
exports.WebhookSourceRequestHeadersSchema = zod_1.z.object({
    "x-ts-key": zod_1.z.string(),
    "x-ts-dynamic-id": zod_1.z.string().optional(),
    "x-ts-secret": zod_1.z.string(),
    "x-ts-params": zod_1.z.string().transform((s) => JSON.parse(s)),
    "x-ts-http-url": zod_1.z.string(),
    "x-ts-http-method": zod_1.z.string(),
    "x-ts-http-headers": zod_1.z.string().transform((s) => zod_1.z.record(zod_1.z.string()).parse(JSON.parse(s))),
});
exports.PongSuccessResponseSchema = zod_1.z.object({
    ok: zod_1.z.literal(true),
    triggerVersion: zod_1.z.string().optional(),
    triggerSdkVersion: zod_1.z.string().optional(),
});
exports.PongErrorResponseSchema = zod_1.z.object({
    ok: zod_1.z.literal(false),
    error: zod_1.z.string(),
    triggerVersion: zod_1.z.string().optional(),
    triggerSdkVersion: zod_1.z.string().optional(),
});
exports.PongResponseSchema = zod_1.z.discriminatedUnion("ok", [
    exports.PongSuccessResponseSchema,
    exports.PongErrorResponseSchema,
]);
exports.ValidateSuccessResponseSchema = zod_1.z.object({
    ok: zod_1.z.literal(true),
    endpointId: zod_1.z.string(),
    triggerVersion: zod_1.z.string().optional(),
});
exports.ValidateErrorResponseSchema = zod_1.z.object({
    ok: zod_1.z.literal(false),
    error: zod_1.z.string(),
    triggerVersion: zod_1.z.string().optional(),
});
exports.ValidateResponseSchema = zod_1.z.discriminatedUnion("ok", [
    exports.ValidateSuccessResponseSchema,
    exports.ValidateErrorResponseSchema,
]);
exports.QueueOptionsSchema = zod_1.z.object({
    name: zod_1.z.string(),
    maxConcurrent: zod_1.z.number().optional(),
});
exports.ConcurrencyLimitOptionsSchema = zod_1.z.object({
    id: zod_1.z.string(),
    limit: zod_1.z.number(),
});
exports.JobMetadataSchema = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string(),
    version: zod_1.z.string(),
    event: triggers_js_1.EventSpecificationSchema,
    trigger: triggers_js_1.TriggerMetadataSchema,
    integrations: zod_1.z.record(integrations_js_1.IntegrationConfigSchema),
    internal: zod_1.z.boolean().default(false),
    enabled: zod_1.z.boolean(),
    startPosition: zod_1.z.enum(["initial", "latest"]),
    preprocessRuns: zod_1.z.boolean(),
    concurrencyLimit: exports.ConcurrencyLimitOptionsSchema.or(zod_1.z.number().int().positive()).optional(),
});
const SourceMetadataV1Schema = zod_1.z.object({
    version: zod_1.z.literal("1"),
    channel: zod_1.z.enum(["HTTP", "SQS", "SMTP"]),
    integration: integrations_js_1.IntegrationConfigSchema,
    key: zod_1.z.string(),
    params: zod_1.z.any(),
    events: zod_1.z.array(zod_1.z.string()),
    registerSourceJob: zod_1.z
        .object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
    })
        .optional(),
});
exports.SourceMetadataV2Schema = zod_1.z.object({
    version: zod_1.z.literal("2"),
    channel: zod_1.z.enum(["HTTP", "SQS", "SMTP"]),
    integration: integrations_js_1.IntegrationConfigSchema,
    key: zod_1.z.string(),
    params: zod_1.z.any(),
    options: zod_1.z.record(zod_1.z.array(zod_1.z.string())),
    registerSourceJob: zod_1.z
        .object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
    })
        .optional(),
});
const SourceMetadataSchema = zod_1.z.preprocess(addMissingVersionField_js_1.addMissingVersionField, zod_1.z.discriminatedUnion("version", [SourceMetadataV1Schema, exports.SourceMetadataV2Schema]));
exports.WebhookMetadataSchema = zod_1.z.object({
    key: zod_1.z.string(),
    params: zod_1.z.any(),
    config: zod_1.z.record(zod_1.z.array(zod_1.z.string())),
    integration: integrations_js_1.IntegrationConfigSchema,
    httpEndpoint: zod_1.z.object({
        id: zod_1.z.string(),
    }),
});
exports.WebhookContextMetadataSchema = zod_1.z.object({
    params: zod_1.z.any(),
    config: zod_1.z.record(zod_1.z.string().array()),
    secret: zod_1.z.string(),
});
exports.DynamicTriggerEndpointMetadataSchema = zod_1.z.object({
    id: zod_1.z.string(),
    jobs: zod_1.z.array(exports.JobMetadataSchema.pick({ id: true, version: true })),
    registerSourceJob: zod_1.z
        .object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
    })
        .optional(),
});
const HttpEndpointMetadataSchema = zod_1.z.object({
    id: zod_1.z.string(),
    version: zod_1.z.string(),
    enabled: zod_1.z.boolean(),
    title: zod_1.z.string().optional(),
    icon: zod_1.z.string().optional(),
    properties: zod_1.z.array(properties_js_1.DisplayPropertySchema).optional(),
    event: triggers_js_1.EventSpecificationSchema,
    immediateResponseFilter: requestFilter_js_1.RequestFilterSchema.optional(),
    skipTriggeringRuns: zod_1.z.boolean().optional(),
    source: zod_1.z.string(),
});
exports.IndexEndpointResponseSchema = zod_1.z.object({
    jobs: zod_1.z.array(exports.JobMetadataSchema),
    sources: zod_1.z.array(SourceMetadataSchema),
    webhooks: zod_1.z.array(exports.WebhookMetadataSchema).optional(),
    dynamicTriggers: zod_1.z.array(exports.DynamicTriggerEndpointMetadataSchema),
    dynamicSchedules: zod_1.z.array(schedules_js_1.RegisterDynamicSchedulePayloadSchema),
    httpEndpoints: zod_1.z.array(HttpEndpointMetadataSchema).optional(),
});
exports.EndpointIndexErrorSchema = zod_1.z.object({
    message: zod_1.z.string(),
    raw: zod_1.z.any().optional(),
});
const IndexEndpointStatsSchema = zod_1.z.object({
    jobs: zod_1.z.number(),
    sources: zod_1.z.number(),
    webhooks: zod_1.z.number().optional(),
    dynamicTriggers: zod_1.z.number(),
    dynamicSchedules: zod_1.z.number(),
    disabledJobs: zod_1.z.number().default(0),
    httpEndpoints: zod_1.z.number().default(0),
});
function parseEndpointIndexStats(stats) {
    if (stats === null || stats === undefined) {
        return;
    }
    return IndexEndpointStatsSchema.parse(stats);
}
exports.GetEndpointIndexResponseSchema = zod_1.z.discriminatedUnion("status", [
    zod_1.z.object({
        status: zod_1.z.literal("PENDING"),
        updatedAt: zod_1.z.coerce.date(),
    }),
    zod_1.z.object({
        status: zod_1.z.literal("STARTED"),
        updatedAt: zod_1.z.coerce.date(),
    }),
    zod_1.z.object({
        status: zod_1.z.literal("SUCCESS"),
        stats: IndexEndpointStatsSchema,
        updatedAt: zod_1.z.coerce.date(),
    }),
    zod_1.z.object({
        status: zod_1.z.literal("FAILURE"),
        error: exports.EndpointIndexErrorSchema,
        updatedAt: zod_1.z.coerce.date(),
    }),
]);
exports.EndpointHeadersSchema = zod_1.z.object({
    "trigger-version": zod_1.z.string().optional(),
    "trigger-sdk-version": zod_1.z.string().optional(),
});
exports.ExecuteJobRunMetadataSchema = zod_1.z.object({
    successSubscription: zod_1.z.boolean().optional(),
    failedSubscription: zod_1.z.boolean().optional(),
});
exports.ExecuteJobHeadersSchema = exports.EndpointHeadersSchema.extend({
    "x-trigger-run-metadata": zod_1.z
        .preprocess((val) => typeof val === "string" && JSON.parse(val), exports.ExecuteJobRunMetadataSchema)
        .optional(),
});
exports.RawEventSchema = zod_1.z.object({
    /** The `name` property must exactly match any subscriptions you want to
        trigger. */
    name: zod_1.z.string(),
    /** The `payload` property will be sent to any matching Jobs and will appear
        as the `payload` param of the `run()` function. You can leave this
        parameter out if you just want to trigger a Job without any input data. */
    payload: zod_1.z.any(),
    /** The optional `context` property will be sent to any matching Jobs and will
        be passed through as the `context.event.context` param of the `run()`
        function. This is optional but can be useful if you want to pass through
        some additional context to the Job. */
    context: zod_1.z.any().optional(),
    /** The `id` property uniquely identify this particular event. If unset it
        will be set automatically using `ulid`. */
    id: zod_1.z.string().default(() => globalThis.crypto.randomUUID()),
    /** This is optional, it defaults to the current timestamp. Usually you would
        only set this if you have a timestamp that you wish to pass through, e.g.
        you receive a timestamp from a service and you want the same timestamp to
        be used in your Job. */
    timestamp: zod_1.z.coerce.date().optional(),
    /** This is optional, it defaults to "trigger.dev". It can be useful to set
        this as you can filter events using this in the `eventTrigger()`. */
    source: zod_1.z.string().optional(),
    /** This is optional, it defaults to "JSON". If your event is actually a request,
        with a url, headers, method and rawBody you can use "REQUEST" */
    payloadType: zod_1.z.union([zod_1.z.literal("JSON"), zod_1.z.literal("REQUEST")]).optional(),
});
/** The event that was sent */
exports.ApiEventLogSchema = zod_1.z.object({
    /** The `id` of the event that was sent.
     */
    id: zod_1.z.string(),
    /** The `name` of the event that was sent. */
    name: zod_1.z.string(),
    /** The `payload` of the event that was sent */
    payload: json_js_1.DeserializedJsonSchema,
    /** The `context` of the event that was sent. Is `undefined` if no context was
        set when sending the event. */
    context: json_js_1.DeserializedJsonSchema.optional().nullable(),
    /** The `timestamp` of the event that was sent */
    timestamp: zod_1.z.coerce.date(),
    /** The timestamp when the event will be delivered to any matching Jobs. Is
        `undefined` if `deliverAt` or `deliverAfter` wasn't set when sending the
        event. */
    deliverAt: zod_1.z.coerce.date().optional().nullable(),
    /** The timestamp when the event was delivered. Is `undefined` if `deliverAt`
        or `deliverAfter` were set when sending the event. */
    deliveredAt: zod_1.z.coerce.date().optional().nullable(),
    /** The timestamp when the event was cancelled. Is `undefined` if the event
     * wasn't cancelled. */
    cancelledAt: zod_1.z.coerce.date().optional().nullable(),
});
/** Options to control the delivery of the event */
exports.SendEventOptionsSchema = zod_1.z.object({
    /** An optional Date when you want the event to trigger Jobs. The event will
        be sent to the platform immediately but won't be acted upon until the
        specified time. */
    deliverAt: zod_1.z.coerce.date().optional(),
    /** An optional number of seconds you want to wait for the event to trigger
        any relevant Jobs. The event will be sent to the platform immediately but
        won't be delivered until after the elapsed number of seconds. */
    deliverAfter: zod_1.z.number().int().optional(),
    /** This optional param will be used by Trigger.dev Connect, which
        is coming soon. */
    accountId: zod_1.z.string().optional(),
});
exports.SendEventBodySchema = zod_1.z.object({
    event: exports.RawEventSchema,
    options: exports.SendEventOptionsSchema.optional(),
});
exports.SendBulkEventsBodySchema = zod_1.z.object({
    events: exports.RawEventSchema.array(),
    options: exports.SendEventOptionsSchema.optional(),
});
exports.DeliverEventResponseSchema = zod_1.z.object({
    deliveredAt: zod_1.z.string().datetime(),
});
exports.RuntimeEnvironmentTypeSchema = zod_1.z.enum([
    "PRODUCTION",
    "STAGING",
    "DEVELOPMENT",
    "PREVIEW",
]);
exports.RunSourceContextSchema = zod_1.z.object({
    id: zod_1.z.string(),
    metadata: zod_1.z.any(),
});
exports.AutoYieldConfigSchema = zod_1.z.object({
    startTaskThreshold: zod_1.z.number(),
    beforeExecuteTaskThreshold: zod_1.z.number(),
    beforeCompleteTaskThreshold: zod_1.z.number(),
    afterCompleteTaskThreshold: zod_1.z.number(),
});
exports.RunJobBodySchema = zod_1.z.object({
    event: exports.ApiEventLogSchema,
    job: zod_1.z.object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
    }),
    run: zod_1.z.object({
        id: zod_1.z.string(),
        isTest: zod_1.z.boolean(),
        isRetry: zod_1.z.boolean().default(false),
        startedAt: zod_1.z.coerce.date(),
    }),
    environment: zod_1.z.object({
        id: zod_1.z.string(),
        slug: zod_1.z.string(),
        type: exports.RuntimeEnvironmentTypeSchema,
    }),
    organization: zod_1.z.object({
        id: zod_1.z.string(),
        title: zod_1.z.string(),
        slug: zod_1.z.string(),
    }),
    project: zod_1.z
        .object({
        id: zod_1.z.string(),
        name: zod_1.z.string(),
        slug: zod_1.z.string(),
    })
        .optional(),
    account: zod_1.z
        .object({
        id: zod_1.z.string(),
        metadata: zod_1.z.any(),
    })
        .optional(),
    source: exports.RunSourceContextSchema.optional(),
    tasks: zod_1.z.array(tasks_js_1.CachedTaskSchema).optional(),
    cachedTaskCursor: zod_1.z.string().optional(),
    noopTasksSet: zod_1.z.string().optional(),
    connections: zod_1.z.record(integrations_js_1.ConnectionAuthSchema).optional(),
    yieldedExecutions: zod_1.z.string().array().optional(),
    runChunkExecutionLimit: zod_1.z.number().optional(),
    autoYieldConfig: exports.AutoYieldConfigSchema.optional(),
});
exports.RunJobErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("ERROR"),
    error: errors_js_1.ErrorWithStackSchema,
    task: tasks_js_1.TaskSchema.optional(),
});
exports.RunJobYieldExecutionErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("YIELD_EXECUTION"),
    key: zod_1.z.string(),
});
exports.AutoYieldMetadataSchema = zod_1.z.object({
    location: zod_1.z.string(),
    timeRemaining: zod_1.z.number(),
    timeElapsed: zod_1.z.number(),
    limit: zod_1.z.number().optional(),
});
exports.RunJobAutoYieldExecutionErrorSchema = exports.AutoYieldMetadataSchema.extend({
    status: zod_1.z.literal("AUTO_YIELD_EXECUTION"),
});
exports.RunJobAutoYieldWithCompletedTaskExecutionErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("AUTO_YIELD_EXECUTION_WITH_COMPLETED_TASK"),
    id: zod_1.z.string(),
    properties: zod_1.z.array(properties_js_1.DisplayPropertySchema).optional(),
    output: zod_1.z.string().optional(),
    data: exports.AutoYieldMetadataSchema,
});
exports.RunJobAutoYieldRateLimitErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("AUTO_YIELD_RATE_LIMIT"),
    reset: zod_1.z.coerce.number(),
});
exports.RunJobInvalidPayloadErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("INVALID_PAYLOAD"),
    errors: zod_1.z.array(errors_js_1.SchemaErrorSchema),
});
exports.RunJobUnresolvedAuthErrorSchema = zod_1.z.object({
    status: zod_1.z.literal("UNRESOLVED_AUTH_ERROR"),
    issues: zod_1.z.record(zod_1.z.object({ id: zod_1.z.string(), error: zod_1.z.string() })),
});
exports.RunJobResumeWithTaskSchema = zod_1.z.object({
    status: zod_1.z.literal("RESUME_WITH_TASK"),
    task: tasks_js_1.TaskSchema,
});
exports.RunJobRetryWithTaskSchema = zod_1.z.object({
    status: zod_1.z.literal("RETRY_WITH_TASK"),
    task: tasks_js_1.TaskSchema,
    error: errors_js_1.ErrorWithStackSchema,
    retryAt: zod_1.z.coerce.date(),
});
exports.RunJobCanceledWithTaskSchema = zod_1.z.object({
    status: zod_1.z.literal("CANCELED"),
    task: tasks_js_1.TaskSchema,
});
exports.RunJobSuccessSchema = zod_1.z.object({
    status: zod_1.z.literal("SUCCESS"),
    output: json_js_1.DeserializedJsonSchema.optional(),
});
exports.RunJobErrorResponseSchema = zod_1.z.union([
    exports.RunJobAutoYieldExecutionErrorSchema,
    exports.RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,
    exports.RunJobYieldExecutionErrorSchema,
    exports.RunJobAutoYieldRateLimitErrorSchema,
    exports.RunJobErrorSchema,
    exports.RunJobUnresolvedAuthErrorSchema,
    exports.RunJobInvalidPayloadErrorSchema,
    exports.RunJobResumeWithTaskSchema,
    exports.RunJobRetryWithTaskSchema,
    exports.RunJobCanceledWithTaskSchema,
]);
exports.RunJobResumeWithParallelTaskSchema = zod_1.z.object({
    status: zod_1.z.literal("RESUME_WITH_PARALLEL_TASK"),
    task: tasks_js_1.TaskSchema,
    childErrors: zod_1.z.array(exports.RunJobErrorResponseSchema),
});
exports.RunJobResponseSchema = zod_1.z.discriminatedUnion("status", [
    exports.RunJobAutoYieldExecutionErrorSchema,
    exports.RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,
    exports.RunJobYieldExecutionErrorSchema,
    exports.RunJobAutoYieldRateLimitErrorSchema,
    exports.RunJobErrorSchema,
    exports.RunJobUnresolvedAuthErrorSchema,
    exports.RunJobInvalidPayloadErrorSchema,
    exports.RunJobResumeWithTaskSchema,
    exports.RunJobResumeWithParallelTaskSchema,
    exports.RunJobRetryWithTaskSchema,
    exports.RunJobCanceledWithTaskSchema,
    exports.RunJobSuccessSchema,
]);
exports.PreprocessRunBodySchema = zod_1.z.object({
    event: exports.ApiEventLogSchema,
    job: zod_1.z.object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
    }),
    run: zod_1.z.object({
        id: zod_1.z.string(),
        isTest: zod_1.z.boolean(),
    }),
    environment: zod_1.z.object({
        id: zod_1.z.string(),
        slug: zod_1.z.string(),
        type: exports.RuntimeEnvironmentTypeSchema,
    }),
    organization: zod_1.z.object({
        id: zod_1.z.string(),
        title: zod_1.z.string(),
        slug: zod_1.z.string(),
    }),
    account: zod_1.z
        .object({
        id: zod_1.z.string(),
        metadata: zod_1.z.any(),
    })
        .optional(),
});
exports.PreprocessRunResponseSchema = zod_1.z.object({
    abort: zod_1.z.boolean(),
    properties: zod_1.z.array(properties_js_1.DisplayPropertySchema).optional(),
});
const CreateRunResponseOkSchema = zod_1.z.object({
    ok: zod_1.z.literal(true),
    data: zod_1.z.object({
        id: zod_1.z.string(),
    }),
});
const CreateRunResponseErrorSchema = zod_1.z.object({
    ok: zod_1.z.literal(false),
    error: zod_1.z.string(),
});
exports.CreateRunResponseBodySchema = zod_1.z.discriminatedUnion("ok", [
    CreateRunResponseOkSchema,
    CreateRunResponseErrorSchema,
]);
exports.RedactStringSchema = zod_1.z.object({
    __redactedString: zod_1.z.literal(true),
    strings: zod_1.z.array(zod_1.z.string()),
    interpolations: zod_1.z.array(zod_1.z.string()),
});
exports.LogMessageSchema = zod_1.z.object({
    level: zod_1.z.enum(["DEBUG", "INFO", "WARN", "ERROR"]),
    message: zod_1.z.string(),
    data: json_js_1.SerializableJsonSchema.optional(),
});
exports.RedactSchema = zod_1.z.object({
    paths: zod_1.z.array(zod_1.z.string()),
});
exports.RetryOptionsSchema = zod_1.z.object({
    /** The maximum number of times to retry the request. */
    limit: zod_1.z.number().optional(),
    /** The exponential factor to use when calculating the next retry time. */
    factor: zod_1.z.number().optional(),
    /** The minimum amount of time to wait before retrying the request. */
    minTimeoutInMs: zod_1.z.number().optional(),
    /** The maximum amount of time to wait before retrying the request. */
    maxTimeoutInMs: zod_1.z.number().optional(),
    /** Whether to randomize the retry time. */
    randomize: zod_1.z.boolean().optional(),
});
exports.RunTaskOptionsSchema = zod_1.z.object({
    /** The name of the Task is required. This is displayed on the Task in the logs. */
    name: zod_1.z.string().optional(),
    /** The Task will wait and only start at the specified Date  */
    delayUntil: zod_1.z.coerce.date().optional(),
    /** Retry options */
    retry: exports.RetryOptionsSchema.optional(),
    /** The icon for the Task, it will appear in the logs.
     *  You can use the name of a company in lowercase, e.g. "github".
     *  Or any icon name that [Tabler Icons](https://tabler-icons.io/) supports. */
    icon: zod_1.z.string().optional(),
    /** The key for the Task that you want to appear in the logs */
    displayKey: zod_1.z.string().optional(),
    /** A description of the Task */
    description: zod_1.z.string().optional(),
    /** Properties that are displayed in the logs */
    properties: zod_1.z.array(properties_js_1.DisplayPropertySchema).optional(),
    /** The input params to the Task, will be displayed in the logs  */
    params: zod_1.z.any(),
    /** The style of the log entry. */
    style: properties_js_1.StyleSchema.optional(),
    /** Allows you to expose a `task.callbackUrl` to use in your tasks. Enabling this feature will cause the task to return the data sent to the callbackUrl instead of the usual async callback result. */
    callback: zod_1.z
        .object({
        /** Causes the task to wait for and return the data of the first request sent to `task.callbackUrl`. */
        enabled: zod_1.z.boolean(),
        /** Time to wait for the first request to `task.callbackUrl`. Default: One hour. */
        timeoutInSeconds: zod_1.z.number(),
    })
        .partial()
        .optional(),
    /** Allows you to link the Integration connection in the logs. This is handled automatically in integrations.  */
    connectionKey: zod_1.z.string().optional(),
    /** An operation you want to perform on the Trigger.dev platform, current only "fetch", "fetch-response", and "fetch-poll" is supported. If you wish to `fetch` use [`io.backgroundFetch()`](https://trigger.dev/docs/sdk/io/backgroundfetch) instead. */
    operation: zod_1.z.enum(["fetch", "fetch-response", "fetch-poll"]).optional(),
    /** A No Operation means that the code won't be executed. This is used internally to implement features like [io.wait()](https://trigger.dev/docs/sdk/io/wait).  */
    noop: zod_1.z.boolean().default(false),
    redact: exports.RedactSchema.optional(),
    parallel: zod_1.z.boolean().optional(),
});
exports.RunTaskBodyInputSchema = exports.RunTaskOptionsSchema.extend({
    idempotencyKey: zod_1.z.string(),
    parentId: zod_1.z.string().optional(),
});
exports.RunTaskBodyOutputSchema = exports.RunTaskBodyInputSchema.extend({
    properties: zod_1.z.array(properties_js_1.DisplayPropertySchema.partial()).optional(),
    params: json_js_1.DeserializedJsonSchema.optional().nullable(),
    callback: zod_1.z
        .object({
        enabled: zod_1.z.boolean(),
        timeoutInSeconds: zod_1.z.number().default(3600),
    })
        .optional(),
});
exports.RunTaskResponseWithCachedTasksBodySchema = zod_1.z.object({
    task: tasks_js_1.ServerTaskSchema,
    cachedTasks: zod_1.z
        .object({
        tasks: zod_1.z.array(tasks_js_1.CachedTaskSchema),
        cursor: zod_1.z.string().optional(),
    })
        .optional(),
});
exports.CompleteTaskBodyInputSchema = exports.RunTaskBodyInputSchema.pick({
    properties: true,
    description: true,
    params: true,
}).extend({
    output: json_js_1.SerializableJsonSchema.optional().transform((v) => v ? json_js_1.DeserializedJsonSchema.parse(JSON.parse(JSON.stringify(v))) : {}),
});
exports.CompleteTaskBodyV2InputSchema = exports.RunTaskBodyInputSchema.pick({
    properties: true,
    description: true,
    params: true,
}).extend({
    output: zod_1.z.string().optional(),
});
exports.FailTaskBodyInputSchema = zod_1.z.object({
    error: errors_js_1.ErrorWithStackSchema,
});
exports.NormalizedRequestSchema = zod_1.z.object({
    headers: zod_1.z.record(zod_1.z.string()),
    method: zod_1.z.string(),
    query: zod_1.z.record(zod_1.z.string()),
    url: zod_1.z.string(),
    body: zod_1.z.any(),
});
exports.NormalizedResponseSchema = zod_1.z.object({
    status: zod_1.z.number(),
    body: zod_1.z.any(),
    headers: zod_1.z.record(zod_1.z.string()).optional(),
});
exports.HttpSourceResponseSchema = zod_1.z.object({
    response: exports.NormalizedResponseSchema,
    events: zod_1.z.array(exports.RawEventSchema),
    metadata: HttpSourceResponseMetadataSchema.optional(),
});
exports.WebhookDeliveryResponseSchema = zod_1.z.object({
    response: exports.NormalizedResponseSchema,
    verified: zod_1.z.boolean(),
    error: zod_1.z.string().optional(),
});
exports.RegisterTriggerBodySchemaV1 = zod_1.z.object({
    rule: eventFilter_js_1.EventRuleSchema,
    source: SourceMetadataV1Schema,
});
exports.RegisterTriggerBodySchemaV2 = zod_1.z.object({
    rule: eventFilter_js_1.EventRuleSchema,
    source: exports.SourceMetadataV2Schema,
    accountId: zod_1.z.string().optional(),
});
exports.InitializeTriggerBodySchema = zod_1.z.object({
    id: zod_1.z.string(),
    params: zod_1.z.any(),
    accountId: zod_1.z.string().optional(),
    metadata: zod_1.z.any().optional(),
});
const RegisterCommonScheduleBodySchema = zod_1.z.object({
    /** A unique id for the schedule. This is used to identify and unregister the schedule later. */
    id: zod_1.z.string(),
    /** Any additional metadata about the schedule. */
    metadata: zod_1.z.any(),
    /** An optional Account ID to associate with runs triggered by this schedule */
    accountId: zod_1.z.string().optional(),
});
exports.RegisterIntervalScheduleBodySchema = RegisterCommonScheduleBodySchema.merge(schedules_js_1.IntervalMetadataSchema);
exports.InitializeCronScheduleBodySchema = RegisterCommonScheduleBodySchema.merge(schedules_js_1.CronMetadataSchema);
exports.RegisterScheduleBodySchema = zod_1.z.discriminatedUnion("type", [
    exports.RegisterIntervalScheduleBodySchema,
    exports.InitializeCronScheduleBodySchema,
]);
exports.RegisterScheduleResponseBodySchema = zod_1.z.object({
    id: zod_1.z.string(),
    schedule: schedules_js_1.ScheduleMetadataSchema,
    metadata: zod_1.z.any(),
    active: zod_1.z.boolean(),
});
exports.CreateExternalConnectionBodySchema = zod_1.z.object({
    accessToken: zod_1.z.string(),
    type: zod_1.z.enum(["oauth2"]),
    scopes: zod_1.z.array(zod_1.z.string()).optional(),
    metadata: zod_1.z.any(),
});
exports.GetRunStatusesSchema = zod_1.z.object({
    run: zod_1.z.object({ id: zod_1.z.string(), status: runs_js_1.RunStatusSchema, output: zod_1.z.any().optional() }),
    statuses: zod_1.z.array(statuses_js_1.JobRunStatusRecordSchema),
});
exports.InvokeJobResponseSchema = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.InvokeJobRequestBodySchema = zod_1.z.object({
    payload: zod_1.z.any(),
    context: zod_1.z.any().optional(),
    options: zod_1.z
        .object({
        accountId: zod_1.z.string().optional(),
        callbackUrl: zod_1.z.string().optional(),
    })
        .optional(),
});
exports.InvokeOptionsSchema = zod_1.z.object({
    accountId: zod_1.z.string().optional(),
    idempotencyKey: zod_1.z.string().optional(),
    context: zod_1.z.any().optional(),
    callbackUrl: zod_1.z.string().optional(),
});
exports.EphemeralEventDispatcherRequestBodySchema = zod_1.z.object({
    url: zod_1.z.string(),
    name: zod_1.z.string().or(zod_1.z.array(zod_1.z.string())),
    source: zod_1.z.string().optional(),
    filter: eventFilter_js_1.EventFilterSchema.optional(),
    contextFilter: eventFilter_js_1.EventFilterSchema.optional(),
    accountId: zod_1.z.string().optional(),
    timeoutInSeconds: zod_1.z
        .number()
        .int()
        .positive()
        .min(10)
        .max(60 * 60 * 24 * 365)
        .default(3600),
});
exports.EphemeralEventDispatcherResponseBodySchema = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.KeyValueStoreResponseBodySchema = zod_1.z.discriminatedUnion("action", [
    zod_1.z.object({
        action: zod_1.z.literal("DELETE"),
        key: zod_1.z.string(),
        deleted: zod_1.z.boolean(),
    }),
    zod_1.z.object({
        action: zod_1.z.literal("GET"),
        key: zod_1.z.string(),
        value: zod_1.z.string().optional(),
    }),
    zod_1.z.object({
        action: zod_1.z.literal("HAS"),
        key: zod_1.z.string(),
        has: zod_1.z.boolean(),
    }),
    zod_1.z.object({
        action: zod_1.z.literal("SET"),
        key: zod_1.z.string(),
        value: zod_1.z.string().optional(),
    }),
]);
//# sourceMappingURL=api.js.map