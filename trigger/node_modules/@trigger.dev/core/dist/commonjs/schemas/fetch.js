"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchPollOperationSchema = exports.FetchOperationSchema = exports.FetchTimeoutOptionsSchema = exports.FetchRetryOptionsSchema = exports.FetchRequestInitSchema = exports.FetchRetryStrategySchema = exports.FetchRetryBackoffStrategySchema = exports.FetchRetryHeadersStrategySchema = void 0;
const zod_1 = require("zod");
const api_js_1 = require("./api.js");
const eventFilter_js_1 = require("./eventFilter.js");
const requestFilter_js_1 = require("./requestFilter.js");
exports.FetchRetryHeadersStrategySchema = zod_1.z.object({
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: zod_1.z.literal("headers"),
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: zod_1.z.string(),
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: zod_1.z.string(),
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: zod_1.z.string(),
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: eventFilter_js_1.EventFilterSchema.optional(),
    /** The format of the `resetHeader` value. */
    resetFormat: zod_1.z
        .enum([
        "unix_timestamp",
        "unix_timestamp_in_ms",
        "iso_8601",
        "iso_8601_duration_openai_variant",
    ])
        .default("unix_timestamp"),
});
/** The `backoff` strategy retries the request with an exponential backoff. */
exports.FetchRetryBackoffStrategySchema = api_js_1.RetryOptionsSchema.extend({
    /** The `backoff` strategy retries the request with an exponential backoff. */
    strategy: zod_1.z.literal("backoff"),
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: eventFilter_js_1.EventFilterSchema.optional(),
});
exports.FetchRetryStrategySchema = zod_1.z.discriminatedUnion("strategy", [
    exports.FetchRetryHeadersStrategySchema,
    exports.FetchRetryBackoffStrategySchema,
]);
/** The options for a fetch request */
exports.FetchRequestInitSchema = zod_1.z.object({
    /** The HTTP method to use for the request. */
    method: zod_1.z.string().optional(),
    /** Any headers to send with the request. Note that you can use [redactString](https://trigger.dev/docs/sdk/redactString) to prevent sensitive information from being stored (e.g. in the logs), like API keys and tokens. */
    headers: zod_1.z.record(zod_1.z.union([zod_1.z.string(), api_js_1.RedactStringSchema])).optional(),
    /** The body of the request. */
    body: zod_1.z.union([zod_1.z.string(), zod_1.z.instanceof(ArrayBuffer)]).optional(),
});
exports.FetchRetryOptionsSchema = zod_1.z.record(exports.FetchRetryStrategySchema);
exports.FetchTimeoutOptionsSchema = zod_1.z.object({
    durationInMs: zod_1.z.number(),
    retry: api_js_1.RetryOptionsSchema.optional(),
});
exports.FetchOperationSchema = zod_1.z.object({
    url: zod_1.z.string(),
    requestInit: exports.FetchRequestInitSchema.optional(),
    retry: zod_1.z.record(exports.FetchRetryStrategySchema).optional(),
    timeout: exports.FetchTimeoutOptionsSchema.optional(),
});
exports.FetchPollOperationSchema = zod_1.z.object({
    url: zod_1.z.string(),
    interval: zod_1.z.number().int().positive().min(10).max(600).default(10), // defaults to 10 seconds
    timeout: zod_1.z.number().int().positive().min(30).max(3600).default(600), // defaults to 10 minutes
    responseFilter: requestFilter_js_1.ResponseFilterSchema,
    requestInit: exports.FetchRequestInitSchema.optional(),
    requestTimeout: exports.FetchTimeoutOptionsSchema.optional(),
});
//# sourceMappingURL=fetch.js.map