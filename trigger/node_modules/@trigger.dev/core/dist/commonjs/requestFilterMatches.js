"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestFilterMatches = requestFilterMatches;
exports.responseFilterMatches = responseFilterMatches;
const eventFilterMatches_js_1 = require("./eventFilterMatches.js");
async function requestFilterMatches(request, filter) {
    const clonedRequest = request.clone();
    if (!requestMethodMatches(clonedRequest.method, filter.method)) {
        return false;
    }
    const headersObj = Object.fromEntries(clonedRequest.headers.entries());
    if (filter.headers && !(0, eventFilterMatches_js_1.eventFilterMatches)(headersObj, filter.headers)) {
        return false;
    }
    const searchParams = new URL(clonedRequest.url).searchParams;
    const searchParamsObject = {};
    for (const [key, value] of searchParams.entries()) {
        searchParamsObject[key] = value;
    }
    if (filter.query && !(0, eventFilterMatches_js_1.eventFilterMatches)(searchParamsObject, filter.query)) {
        return false;
    }
    try {
        const json = await clonedRequest.json();
        if (filter.body && !(0, eventFilterMatches_js_1.eventFilterMatches)(json, filter.body)) {
            return false;
        }
    }
    catch (e) {
        if (filter.body) {
            return false;
        }
    }
    return true;
}
async function responseFilterMatches(response, filter) {
    if (filter.headers && !(0, eventFilterMatches_js_1.eventFilterMatches)(response.headers, filter.headers)) {
        return { match: false };
    }
    try {
        const json = await response.json();
        if (filter.body && !(0, eventFilterMatches_js_1.eventFilterMatches)(json, filter.body)) {
            return { match: false, body: json };
        }
        else {
            return { match: true, body: json };
        }
    }
    catch (e) {
        if (filter.body) {
            return { match: false, body: undefined };
        }
    }
    return { match: true, body: undefined };
}
function requestMethodMatches(method, filter) {
    if (!filter) {
        return true;
    }
    return filter.includes(method);
}
//# sourceMappingURL=requestFilterMatches.js.map