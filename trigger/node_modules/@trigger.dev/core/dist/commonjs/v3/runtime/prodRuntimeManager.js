"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProdRuntimeManager = void 0;
const clock_api_js_1 = require("../clock-api.js");
class ProdRuntimeManager {
    ipc;
    options;
    _taskWaits = new Map();
    _batchWaits = new Map();
    _waitForDuration;
    constructor(ipc, options = {}) {
        this.ipc = ipc;
        this.options = options;
    }
    disable() {
        // do nothing
    }
    async waitForDuration(ms) {
        const now = Date.now();
        const resume = new Promise((resolve, reject) => {
            this._waitForDuration = { resolve, reject };
        });
        await this.ipc.send("WAIT_FOR_DURATION", {
            ms,
            now,
            waitThresholdInMs: this.waitThresholdInMs,
        });
        await resume;
    }
    resumeAfterDuration() {
        if (!this._waitForDuration) {
            return;
        }
        // Resets the clock to the current time
        clock_api_js_1.clock.reset();
        this._waitForDuration.resolve();
        this._waitForDuration = undefined;
    }
    async waitUntil(date) {
        return this.waitForDuration(date.getTime() - Date.now());
    }
    async waitForTask(params) {
        const promise = new Promise((resolve) => {
            this._taskWaits.set(params.id, { resolve });
        });
        await this.ipc.send("WAIT_FOR_TASK", {
            friendlyId: params.id,
        });
        const result = await promise;
        clock_api_js_1.clock.reset();
        return result;
    }
    async waitForBatch(params) {
        if (!params.runs.length) {
            return Promise.resolve({ id: params.id, items: [] });
        }
        const promise = Promise.all(params.runs.map((runId) => {
            return new Promise((resolve, reject) => {
                this._taskWaits.set(runId, { resolve });
            });
        }));
        await this.ipc.send("WAIT_FOR_BATCH", {
            batchFriendlyId: params.id,
            runFriendlyIds: params.runs,
        });
        const results = await promise;
        clock_api_js_1.clock.reset();
        return {
            id: params.id,
            items: results,
        };
    }
    resumeTask(completion) {
        const wait = this._taskWaits.get(completion.id);
        if (!wait) {
            return;
        }
        wait.resolve(completion);
        this._taskWaits.delete(completion.id);
    }
    get waitThresholdInMs() {
        return this.options.waitThresholdInMs ?? 30_000;
    }
}
exports.ProdRuntimeManager = ProdRuntimeManager;
//# sourceMappingURL=prodRuntimeManager.js.map