"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevRuntimeManager = void 0;
const timers_js_1 = require("../utils/timers.js");
class DevRuntimeManager {
    _taskWaits = new Map();
    _batchWaits = new Map();
    _pendingCompletionNotifications = new Map();
    disable() {
        // do nothing
    }
    async waitForDuration(ms) {
        await (0, timers_js_1.unboundedTimeout)(ms);
    }
    async waitUntil(date) {
        return this.waitForDuration(date.getTime() - Date.now());
    }
    async waitForTask(params) {
        const pendingCompletion = this._pendingCompletionNotifications.get(params.id);
        if (pendingCompletion) {
            this._pendingCompletionNotifications.delete(params.id);
            return pendingCompletion;
        }
        const promise = new Promise((resolve) => {
            this._taskWaits.set(params.id, { resolve });
        });
        return await promise;
    }
    async waitForBatch(params) {
        if (!params.runs.length) {
            return Promise.resolve({ id: params.id, items: [] });
        }
        const promise = Promise.all(params.runs.map((runId) => {
            return new Promise((resolve, reject) => {
                const pendingCompletion = this._pendingCompletionNotifications.get(runId);
                if (pendingCompletion) {
                    this._pendingCompletionNotifications.delete(runId);
                    resolve(pendingCompletion);
                    return;
                }
                this._taskWaits.set(runId, { resolve });
            });
        }));
        const results = await promise;
        return {
            id: params.id,
            items: results,
        };
    }
    resumeTask(completion, runId) {
        const wait = this._taskWaits.get(runId);
        if (!wait) {
            // We need to store the completion in case the task is awaited later
            this._pendingCompletionNotifications.set(runId, completion);
            return;
        }
        wait.resolve(completion);
        this._taskWaits.delete(runId);
    }
}
exports.DevRuntimeManager = DevRuntimeManager;
//# sourceMappingURL=devRuntimeManager.js.map