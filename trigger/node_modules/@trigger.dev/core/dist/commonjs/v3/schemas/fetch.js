"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchRetryOptions = exports.FetchTimeoutOptions = exports.FetchRetryByStatusOptions = exports.FetchRetryStrategy = exports.FetchRetryBackoffStrategy = exports.FetchRetryHeadersStrategy = void 0;
const zod_1 = require("zod");
const schemas_js_1 = require("./schemas.js");
const eventFilter_js_1 = require("./eventFilter.js");
exports.FetchRetryHeadersStrategy = zod_1.z.object({
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: zod_1.z.literal("headers"),
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: zod_1.z.string(),
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: zod_1.z.string(),
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: zod_1.z.string(),
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: eventFilter_js_1.EventFilter.optional(),
    /** The format of the `resetHeader` value. */
    resetFormat: zod_1.z
        .enum([
        "unix_timestamp",
        "unix_timestamp_in_ms",
        "iso_8601",
        "iso_8601_duration_openai_variant",
    ])
        .default("unix_timestamp")
        .optional(),
});
exports.FetchRetryBackoffStrategy = schemas_js_1.RetryOptions.extend({
    /** The `backoff` strategy retries the request with an exponential backoff. */
    strategy: zod_1.z.literal("backoff"),
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: eventFilter_js_1.EventFilter.optional(),
});
exports.FetchRetryStrategy = zod_1.z.discriminatedUnion("strategy", [
    exports.FetchRetryHeadersStrategy,
    exports.FetchRetryBackoffStrategy,
]);
exports.FetchRetryByStatusOptions = zod_1.z.record(zod_1.z.string(), exports.FetchRetryStrategy);
exports.FetchTimeoutOptions = zod_1.z.object({
    /** The maximum time to wait for the request to complete. */
    durationInMs: zod_1.z.number().optional(),
    retry: schemas_js_1.RetryOptions.optional(),
});
exports.FetchRetryOptions = zod_1.z.object({
    /** The retrying strategy for specific status codes. */
    byStatus: exports.FetchRetryByStatusOptions.optional(),
    /** The timeout options for the request. */
    timeout: schemas_js_1.RetryOptions.optional(),
    /**
     * The retrying strategy for connection errors.
     */
    connectionError: schemas_js_1.RetryOptions.optional(),
});
//# sourceMappingURL=fetch.js.map