"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportEnvironmentVariablesRequestBody = exports.UpdateEnvironmentVariableRequestBody = exports.CreateEnvironmentVariableRequestBody = exports.ListRunResponse = exports.ListRunResponseItem = exports.RetrieveRunResponse = exports.RelatedRunDetails = exports.TriggerFunction = exports.RunScheduleDetails = exports.RunEnvironmentDetails = exports.AttemptStatus = exports.RunStatus = exports.TimezonesResult = exports.ListScheduleOptions = exports.ListSchedulesResult = exports.DeletedScheduleObject = exports.ScheduleObject = exports.ScheduleGenerator = exports.UpdateScheduleOptions = exports.CreateScheduleOptions = exports.ScheduledTaskPayload = exports.ScheduleType = exports.CanceledRunResponse = exports.ReplayRunResponse = exports.CreateUploadPayloadUrlResponseBody = exports.GetDeploymentResponseBody = exports.FailDeploymentResponseBody = exports.FailDeploymentRequestBody = exports.DeploymentErrorData = exports.InitializeDeploymentRequestBody = exports.InitializeDeploymentResponseBody = exports.ExternalBuildData = exports.FinalizeDeploymentRequestBody = exports.StartDeploymentIndexingResponseBody = exports.StartDeploymentIndexingRequestBody = exports.GetEnvironmentVariablesResponseBody = exports.RescheduleRunRequestBody = exports.AddTagsRequestBody = exports.GetBatchResponseBody = exports.BatchTriggerTaskResponse = exports.BatchTriggerTaskRequestBody = exports.TriggerTaskResponse = exports.TriggerTaskRequestBody = exports.RunTags = exports.CreateBackgroundWorkerResponse = exports.CreateBackgroundWorkerRequestBody = exports.GetProjectEnvResponse = exports.GetProjectsResponseBody = exports.GetProjectResponseBody = exports.WhoAmIResponseSchema = void 0;
exports.EnvironmentVariables = exports.EnvironmentVariable = exports.EnvironmentVariableValue = exports.EnvironmentVariableResponseBody = void 0;
const zod_1 = require("zod");
const resources_js_1 = require("./resources.js");
const schemas_js_1 = require("./schemas.js");
const common_js_1 = require("./common.js");
exports.WhoAmIResponseSchema = zod_1.z.object({
    userId: zod_1.z.string(),
    email: zod_1.z.string().email(),
    dashboardUrl: zod_1.z.string(),
});
exports.GetProjectResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    externalRef: zod_1.z.string(),
    name: zod_1.z.string(),
    slug: zod_1.z.string(),
    createdAt: zod_1.z.coerce.date(),
    organization: zod_1.z.object({
        id: zod_1.z.string(),
        title: zod_1.z.string(),
        slug: zod_1.z.string(),
        createdAt: zod_1.z.coerce.date(),
    }),
});
exports.GetProjectsResponseBody = zod_1.z.array(exports.GetProjectResponseBody);
exports.GetProjectEnvResponse = zod_1.z.object({
    apiKey: zod_1.z.string(),
    name: zod_1.z.string(),
    apiUrl: zod_1.z.string(),
    projectId: zod_1.z.string(),
});
exports.CreateBackgroundWorkerRequestBody = zod_1.z.object({
    localOnly: zod_1.z.boolean(),
    metadata: resources_js_1.BackgroundWorkerMetadata,
    supportsLazyAttempts: zod_1.z.boolean().optional(),
});
exports.CreateBackgroundWorkerResponse = zod_1.z.object({
    id: zod_1.z.string(),
    version: zod_1.z.string(),
    contentHash: zod_1.z.string(),
});
//an array of 1, 2, or 3 strings
const RunTag = zod_1.z.string().max(64, "Tags must be less than 64 characters");
exports.RunTags = zod_1.z.union([RunTag, RunTag.array()]);
exports.TriggerTaskRequestBody = zod_1.z.object({
    payload: zod_1.z.any(),
    context: zod_1.z.any(),
    options: zod_1.z
        .object({
        dependentAttempt: zod_1.z.string().optional(),
        parentAttempt: zod_1.z.string().optional(),
        dependentBatch: zod_1.z.string().optional(),
        parentBatch: zod_1.z.string().optional(),
        lockToVersion: zod_1.z.string().optional(),
        queue: schemas_js_1.QueueOptions.optional(),
        concurrencyKey: zod_1.z.string().optional(),
        idempotencyKey: zod_1.z.string().optional(),
        test: zod_1.z.boolean().optional(),
        payloadType: zod_1.z.string().optional(),
        delay: zod_1.z.string().or(zod_1.z.coerce.date()).optional(),
        ttl: zod_1.z.string().or(zod_1.z.number().nonnegative().int()).optional(),
        tags: exports.RunTags.optional(),
        maxAttempts: zod_1.z.number().int().optional(),
    })
        .optional(),
});
exports.TriggerTaskResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.BatchTriggerTaskRequestBody = zod_1.z.object({
    items: exports.TriggerTaskRequestBody.array(),
    dependentAttempt: zod_1.z.string().optional(),
});
exports.BatchTriggerTaskResponse = zod_1.z.object({
    batchId: zod_1.z.string(),
    runs: zod_1.z.string().array(),
});
exports.GetBatchResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    items: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        taskRunId: zod_1.z.string(),
        status: zod_1.z.enum(["PENDING", "CANCELED", "COMPLETED", "FAILED"]),
    })),
});
exports.AddTagsRequestBody = zod_1.z.object({
    tags: exports.RunTags,
});
exports.RescheduleRunRequestBody = zod_1.z.object({
    delay: zod_1.z.string().or(zod_1.z.coerce.date()),
});
exports.GetEnvironmentVariablesResponseBody = zod_1.z.object({
    variables: zod_1.z.record(zod_1.z.string()),
});
exports.StartDeploymentIndexingRequestBody = zod_1.z.object({
    imageReference: zod_1.z.string(),
    selfHosted: zod_1.z.boolean().optional(),
});
exports.StartDeploymentIndexingResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    contentHash: zod_1.z.string(),
});
exports.FinalizeDeploymentRequestBody = zod_1.z.object({
    imageReference: zod_1.z.string(),
    selfHosted: zod_1.z.boolean().optional(),
});
exports.ExternalBuildData = zod_1.z.object({
    buildId: zod_1.z.string(),
    buildToken: zod_1.z.string(),
    projectId: zod_1.z.string(),
});
exports.InitializeDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    contentHash: zod_1.z.string(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    imageTag: zod_1.z.string(),
    externalBuildData: exports.ExternalBuildData.optional().nullable(),
    registryHost: zod_1.z.string().optional(),
});
exports.InitializeDeploymentRequestBody = zod_1.z.object({
    contentHash: zod_1.z.string(),
    userId: zod_1.z.string().optional(),
    registryHost: zod_1.z.string().optional(),
    selfHosted: zod_1.z.boolean().optional(),
    namespace: zod_1.z.string().optional(),
});
exports.DeploymentErrorData = zod_1.z.object({
    name: zod_1.z.string(),
    message: zod_1.z.string(),
    stack: zod_1.z.string().optional(),
    stderr: zod_1.z.string().optional(),
});
exports.FailDeploymentRequestBody = zod_1.z.object({
    error: exports.DeploymentErrorData,
});
exports.FailDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.GetDeploymentResponseBody = zod_1.z.object({
    id: zod_1.z.string(),
    status: zod_1.z.enum([
        "PENDING",
        "BUILDING",
        "DEPLOYING",
        "DEPLOYED",
        "FAILED",
        "CANCELED",
        "TIMED_OUT",
    ]),
    contentHash: zod_1.z.string(),
    shortCode: zod_1.z.string(),
    version: zod_1.z.string(),
    imageReference: zod_1.z.string().nullish(),
    errorData: exports.DeploymentErrorData.nullish(),
    worker: zod_1.z
        .object({
        id: zod_1.z.string(),
        version: zod_1.z.string(),
        tasks: zod_1.z.array(zod_1.z.object({
            id: zod_1.z.string(),
            slug: zod_1.z.string(),
            filePath: zod_1.z.string(),
            exportName: zod_1.z.string(),
        })),
    })
        .optional(),
});
exports.CreateUploadPayloadUrlResponseBody = zod_1.z.object({
    presignedUrl: zod_1.z.string(),
});
exports.ReplayRunResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.CanceledRunResponse = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.ScheduleType = zod_1.z.union([zod_1.z.literal("DECLARATIVE"), zod_1.z.literal("IMPERATIVE")]);
exports.ScheduledTaskPayload = zod_1.z.object({
    /** The schedule id associated with this run (you can have many schedules for the same task).
      You can use this to remove the schedule, update it, etc */
    scheduleId: zod_1.z.string(),
    /** The type of schedule – `"DECLARATIVE"` or `"IMPERATIVE"`.
     *
     * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.
     *
     * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.
     */
    type: exports.ScheduleType,
    /** When the task was scheduled to run.
     * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.
     *
     * This date is UTC. To output it as a string with a timezone you would do this:
     * ```ts
     * const formatted = payload.timestamp.toLocaleString("en-US", {
          timeZone: payload.timezone,
      });
      ```  */
    timestamp: zod_1.z.date(),
    /** When the task was last run (it has been).
      This can be undefined if it's never been run. This date is UTC. */
    lastTimestamp: zod_1.z.date().optional(),
    /** You can optionally provide an external id when creating the schedule.
      Usually you would use a userId or some other unique identifier.
      This defaults to undefined if you didn't provide one. */
    externalId: zod_1.z.string().optional(),
    /** The IANA timezone the schedule is set to. The default is UTC.
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     */
    timezone: zod_1.z.string(),
    /** The next 5 dates this task is scheduled to run */
    upcoming: zod_1.z.array(zod_1.z.date()),
});
exports.CreateScheduleOptions = zod_1.z.object({
    /** The id of the task you want to attach to. */
    task: zod_1.z.string(),
    /**  The schedule in CRON format.
     *
     * ```txt
  *    *    *    *    *    *
  ┬    ┬    ┬    ┬    ┬
  │    │    │    │    |
  │    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)
  │    │    │    └───── month (1 - 12)
  │    │    └────────── day of month (1 - 31, L)
  │    └─────────────── hour (0 - 23)
  └──────────────────── minute (0 - 59)
     * ```
  
  "L" means the last. In the "day of week" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.
  
     */
    cron: zod_1.z.string(),
    /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.
     *
     * This is required to prevent you from creating duplicate schedules. */
    deduplicationKey: zod_1.z.string(),
    /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.
     *
     * This allows you to have per-user CRON tasks.
     */
    externalId: zod_1.z.string().optional(),
    /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.
     * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.
     *
     * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.
     *
     * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones
     *
     * @example "America/New_York", "Europe/London", "Asia/Tokyo", "Africa/Cairo"
     *
     */
    timezone: zod_1.z.string().optional(),
});
exports.UpdateScheduleOptions = exports.CreateScheduleOptions.omit({ deduplicationKey: true });
exports.ScheduleGenerator = zod_1.z.object({
    type: zod_1.z.literal("CRON"),
    expression: zod_1.z.string(),
    description: zod_1.z.string(),
});
exports.ScheduleObject = zod_1.z.object({
    id: zod_1.z.string(),
    type: exports.ScheduleType,
    task: zod_1.z.string(),
    active: zod_1.z.boolean(),
    deduplicationKey: zod_1.z.string().nullish(),
    externalId: zod_1.z.string().nullish(),
    generator: exports.ScheduleGenerator,
    timezone: zod_1.z.string(),
    nextRun: zod_1.z.coerce.date().nullish(),
    environments: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        userName: zod_1.z.string().nullish(),
    })),
});
exports.DeletedScheduleObject = zod_1.z.object({
    id: zod_1.z.string(),
});
exports.ListSchedulesResult = zod_1.z.object({
    data: zod_1.z.array(exports.ScheduleObject),
    pagination: zod_1.z.object({
        currentPage: zod_1.z.number(),
        totalPages: zod_1.z.number(),
        count: zod_1.z.number(),
    }),
});
exports.ListScheduleOptions = zod_1.z.object({
    page: zod_1.z.number().optional(),
    perPage: zod_1.z.number().optional(),
});
exports.TimezonesResult = zod_1.z.object({
    timezones: zod_1.z.array(zod_1.z.string()),
});
exports.RunStatus = zod_1.z.enum([
    /// Task hasn't been deployed yet but is waiting to be executed
    "WAITING_FOR_DEPLOY",
    /// Task is waiting to be executed by a worker
    "QUEUED",
    /// Task is currently being executed by a worker
    "EXECUTING",
    /// Task has failed and is waiting to be retried
    "REATTEMPTING",
    /// Task has been paused by the system, and will be resumed by the system
    "FROZEN",
    /// Task has been completed successfully
    "COMPLETED",
    /// Task has been canceled by the user
    "CANCELED",
    /// Task has been completed with errors
    "FAILED",
    /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage
    "CRASHED",
    /// Task was interrupted during execution, mostly this happens in development environments
    "INTERRUPTED",
    /// Task has failed to complete, due to an error in the system
    "SYSTEM_FAILURE",
    /// Task has been scheduled to run at a specific time
    "DELAYED",
    /// Task has expired and won't be executed
    "EXPIRED",
]);
exports.AttemptStatus = zod_1.z.enum([
    "PENDING",
    "EXECUTING",
    "PAUSED",
    "COMPLETED",
    "FAILED",
    "CANCELED",
]);
exports.RunEnvironmentDetails = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string(),
    user: zod_1.z.string().optional(),
});
exports.RunScheduleDetails = zod_1.z.object({
    id: zod_1.z.string(),
    externalId: zod_1.z.string().optional(),
    deduplicationKey: zod_1.z.string().optional(),
    generator: exports.ScheduleGenerator,
});
exports.TriggerFunction = zod_1.z.enum([
    "triggerAndWait",
    "trigger",
    "batchTriggerAndWait",
    "batchTrigger",
]);
const CommonRunFields = {
    id: zod_1.z.string(),
    status: exports.RunStatus,
    taskIdentifier: zod_1.z.string(),
    idempotencyKey: zod_1.z.string().optional(),
    version: zod_1.z.string().optional(),
    isQueued: zod_1.z.boolean(),
    isExecuting: zod_1.z.boolean(),
    isCompleted: zod_1.z.boolean(),
    isSuccess: zod_1.z.boolean(),
    isFailed: zod_1.z.boolean(),
    isCancelled: zod_1.z.boolean(),
    isTest: zod_1.z.boolean(),
    createdAt: zod_1.z.coerce.date(),
    updatedAt: zod_1.z.coerce.date(),
    startedAt: zod_1.z.coerce.date().optional(),
    finishedAt: zod_1.z.coerce.date().optional(),
    delayedUntil: zod_1.z.coerce.date().optional(),
    ttl: zod_1.z.string().optional(),
    expiredAt: zod_1.z.coerce.date().optional(),
    tags: zod_1.z.string().array(),
    costInCents: zod_1.z.number(),
    baseCostInCents: zod_1.z.number(),
    durationMs: zod_1.z.number(),
};
const RetrieveRunCommandFields = {
    ...CommonRunFields,
    depth: zod_1.z.number(),
    triggerFunction: zod_1.z.enum(["triggerAndWait", "trigger", "batchTriggerAndWait", "batchTrigger"]),
    batchId: zod_1.z.string().optional(),
};
exports.RelatedRunDetails = zod_1.z.object(RetrieveRunCommandFields);
exports.RetrieveRunResponse = zod_1.z.object({
    ...RetrieveRunCommandFields,
    payload: zod_1.z.any().optional(),
    payloadPresignedUrl: zod_1.z.string().optional(),
    output: zod_1.z.any().optional(),
    outputPresignedUrl: zod_1.z.string().optional(),
    schedule: exports.RunScheduleDetails.optional(),
    relatedRuns: zod_1.z.object({
        root: exports.RelatedRunDetails.optional(),
        parent: exports.RelatedRunDetails.optional(),
        children: zod_1.z.array(exports.RelatedRunDetails).optional(),
    }),
    attempts: zod_1.z.array(zod_1.z
        .object({
        id: zod_1.z.string(),
        status: exports.AttemptStatus,
        createdAt: zod_1.z.coerce.date(),
        updatedAt: zod_1.z.coerce.date(),
        startedAt: zod_1.z.coerce.date().optional(),
        completedAt: zod_1.z.coerce.date().optional(),
        error: common_js_1.SerializedError.optional(),
    })
        .optional()),
});
exports.ListRunResponseItem = zod_1.z.object({
    ...CommonRunFields,
    env: exports.RunEnvironmentDetails,
});
exports.ListRunResponse = zod_1.z.object({
    data: zod_1.z.array(exports.ListRunResponseItem),
    pagination: zod_1.z.object({
        next: zod_1.z.string().optional(),
        previous: zod_1.z.string().optional(),
    }),
});
exports.CreateEnvironmentVariableRequestBody = zod_1.z.object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
});
exports.UpdateEnvironmentVariableRequestBody = zod_1.z.object({
    value: zod_1.z.string(),
});
exports.ImportEnvironmentVariablesRequestBody = zod_1.z.object({
    variables: zod_1.z.record(zod_1.z.string()),
    override: zod_1.z.boolean().optional(),
});
exports.EnvironmentVariableResponseBody = zod_1.z.object({
    success: zod_1.z.boolean(),
});
exports.EnvironmentVariableValue = zod_1.z.object({
    value: zod_1.z.string(),
});
exports.EnvironmentVariable = zod_1.z.object({
    name: zod_1.z.string(),
    value: zod_1.z.string(),
});
exports.EnvironmentVariables = zod_1.z.array(exports.EnvironmentVariable);
//# sourceMappingURL=api.js.map