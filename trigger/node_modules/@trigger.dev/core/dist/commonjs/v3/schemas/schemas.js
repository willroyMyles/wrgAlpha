"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunExecutionLazyAttemptPayload = exports.WaitReason = exports.Config = exports.PreStopCauses = exports.PostStartCauses = exports.TaskManifest = exports.TaskFileMetadata = exports.TaskFile = exports.TaskMetadata = exports.ScheduleMetadata = exports.QueueOptions = exports.RetryOptions = exports.RateLimitOptions = exports.SlidingWindowRateLimit = exports.FixedWindowRateLimit = exports.ProdTaskRunExecutionPayload = exports.ProdTaskRunExecution = exports.TaskRunExecutionPayload = exports.EnvironmentType = void 0;
const zod_1 = require("zod");
const common_js_1 = require("./common.js");
/*
    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.
*/
exports.EnvironmentType = zod_1.z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]);
exports.TaskRunExecutionPayload = zod_1.z.object({
    execution: common_js_1.TaskRunExecution,
    traceContext: zod_1.z.record(zod_1.z.unknown()),
    environment: zod_1.z.record(zod_1.z.string()).optional(),
});
// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.
// Strategies for not breaking backwards compatibility:
// 1. Add new fields as optional
// 2. If a field is required, add a default value
exports.ProdTaskRunExecution = common_js_1.TaskRunExecution.extend({
    worker: zod_1.z.object({
        id: zod_1.z.string(),
        contentHash: zod_1.z.string(),
        version: zod_1.z.string(),
    }),
    machine: common_js_1.MachinePreset.default({ name: "small-1x", cpu: 1, memory: 1, centsPerMs: 0 }),
});
exports.ProdTaskRunExecutionPayload = zod_1.z.object({
    execution: exports.ProdTaskRunExecution,
    traceContext: zod_1.z.record(zod_1.z.unknown()),
    environment: zod_1.z.record(zod_1.z.string()).optional(),
});
exports.FixedWindowRateLimit = zod_1.z.object({
    type: zod_1.z.literal("fixed-window"),
    limit: zod_1.z.number(),
    window: zod_1.z.union([
        zod_1.z.object({
            seconds: zod_1.z.number(),
        }),
        zod_1.z.object({
            minutes: zod_1.z.number(),
        }),
        zod_1.z.object({
            hours: zod_1.z.number(),
        }),
    ]),
});
exports.SlidingWindowRateLimit = zod_1.z.object({
    type: zod_1.z.literal("sliding-window"),
    limit: zod_1.z.number(),
    window: zod_1.z.union([
        zod_1.z.object({
            seconds: zod_1.z.number(),
        }),
        zod_1.z.object({
            minutes: zod_1.z.number(),
        }),
        zod_1.z.object({
            hours: zod_1.z.number(),
        }),
    ]),
});
exports.RateLimitOptions = zod_1.z.discriminatedUnion("type", [
    exports.FixedWindowRateLimit,
    exports.SlidingWindowRateLimit,
]);
exports.RetryOptions = zod_1.z.object({
    /** The number of attempts before giving up */
    maxAttempts: zod_1.z.number().int().optional(),
    /** The exponential factor to use when calculating the next retry time.
     *
     * Each subsequent retry will be calculated as `previousTimeout * factor`
     */
    factor: zod_1.z.number().optional(),
    /** The minimum time to wait before retrying */
    minTimeoutInMs: zod_1.z.number().int().optional(),
    /** The maximum time to wait before retrying */
    maxTimeoutInMs: zod_1.z.number().int().optional(),
    /** Randomize the timeout between retries.
     *
     * This can be useful to prevent the thundering herd problem where all retries happen at the same time.
     */
    randomize: zod_1.z.boolean().optional(),
});
exports.QueueOptions = zod_1.z.object({
    /** You can define a shared queue and then pass the name in to your task.
     *
     * @example
     *
     * ```ts
     * const myQueue = queue({
        name: "my-queue",
        concurrencyLimit: 1,
      });
  
      export const task1 = task({
        id: "task-1",
        queue: {
          name: "my-queue",
        },
        run: async (payload: { message: string }) => {
          // ...
        },
      });
  
      export const task2 = task({
        id: "task-2",
        queue: {
          name: "my-queue",
        },
        run: async (payload: { message: string }) => {
          // ...
        },
      });
     * ```
     */
    name: zod_1.z.string().optional(),
    /** An optional property that specifies the maximum number of concurrent run executions.
     *
     * If this property is omitted, the task can potentially use up the full concurrency of an environment. */
    concurrencyLimit: zod_1.z.number().int().min(0).max(1000).optional(),
    /** @deprecated This feature is coming soon */
    rateLimit: exports.RateLimitOptions.optional(),
});
exports.ScheduleMetadata = zod_1.z.object({
    cron: zod_1.z.string(),
    timezone: zod_1.z.string(),
});
const taskMetadata = {
    id: zod_1.z.string(),
    queue: exports.QueueOptions.optional(),
    retry: exports.RetryOptions.optional(),
    machine: common_js_1.MachineConfig.optional(),
    triggerSource: zod_1.z.string().optional(),
    schedule: exports.ScheduleMetadata.optional(),
};
exports.TaskMetadata = zod_1.z.object(taskMetadata);
exports.TaskFile = zod_1.z.object({
    entry: zod_1.z.string(),
    out: zod_1.z.string(),
});
const taskFileMetadata = {
    filePath: zod_1.z.string(),
    exportName: zod_1.z.string(),
    entryPoint: zod_1.z.string(),
};
exports.TaskFileMetadata = zod_1.z.object(taskFileMetadata);
exports.TaskManifest = zod_1.z.object({
    ...taskMetadata,
    ...taskFileMetadata,
});
exports.PostStartCauses = zod_1.z.enum(["index", "create", "restore"]);
exports.PreStopCauses = zod_1.z.enum(["terminate"]);
const RegexSchema = zod_1.z.custom((val) => {
    try {
        // Check to see if val is a regex
        return typeof val.test === "function";
    }
    catch {
        return false;
    }
});
exports.Config = zod_1.z.object({
    project: zod_1.z.string(),
    triggerDirectories: zod_1.z.string().array().optional(),
    triggerUrl: zod_1.z.string().optional(),
    projectDir: zod_1.z.string().optional(),
    tsconfigPath: zod_1.z.string().optional(),
    retries: zod_1.z
        .object({
        enabledInDev: zod_1.z.boolean().default(true),
        default: exports.RetryOptions.optional(),
    })
        .optional(),
    additionalPackages: zod_1.z.string().array().optional(),
    additionalFiles: zod_1.z.string().array().optional(),
    dependenciesToBundle: zod_1.z.array(zod_1.z.union([zod_1.z.string(), RegexSchema])).optional(),
    logLevel: zod_1.z.string().optional(),
    enableConsoleLogging: zod_1.z.boolean().optional(),
    postInstall: zod_1.z.string().optional(),
    extraCACerts: zod_1.z.string().optional(),
});
exports.WaitReason = zod_1.z.enum(["WAIT_FOR_DURATION", "WAIT_FOR_TASK", "WAIT_FOR_BATCH"]);
exports.TaskRunExecutionLazyAttemptPayload = zod_1.z.object({
    runId: zod_1.z.string(),
    attemptCount: zod_1.z.number().optional(),
    messageId: zod_1.z.string(),
    isTest: zod_1.z.boolean(),
    traceContext: zod_1.z.record(zod_1.z.unknown()),
    environment: zod_1.z.record(zod_1.z.string()).optional(),
});
//# sourceMappingURL=schemas.js.map