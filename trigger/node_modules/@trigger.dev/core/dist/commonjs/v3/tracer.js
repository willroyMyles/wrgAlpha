"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TriggerTracer = void 0;
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const semanticInternalAttributes_js_1 = require("./semanticInternalAttributes.js");
const clock_api_js_1 = require("./clock-api.js");
const usage_api_js_1 = require("./usage-api.js");
const task_context_api_js_1 = require("./task-context-api.js");
class TriggerTracer {
    _config;
    constructor(_config) {
        this._config = _config;
    }
    _tracer;
    get tracer() {
        if (!this._tracer) {
            if ("tracer" in this._config)
                return this._config.tracer;
            this._tracer = api_1.trace.getTracer(this._config.name, this._config.version);
        }
        return this._tracer;
    }
    _logger;
    get logger() {
        if (!this._logger) {
            if ("logger" in this._config)
                return this._config.logger;
            this._logger = api_logs_1.logs.getLogger(this._config.name, this._config.version);
        }
        return this._logger;
    }
    extractContext(traceContext) {
        return api_1.propagation.extract(api_1.context.active(), traceContext ?? {});
    }
    startActiveSpan(name, fn, options, ctx) {
        const parentContext = ctx ?? api_1.context.active();
        const attributes = options?.attributes ?? {};
        return this.tracer.startActiveSpan(name, {
            ...options,
            attributes,
            startTime: clock_api_js_1.clock.preciseNow(),
        }, parentContext, async (span) => {
            if (task_context_api_js_1.taskContext.ctx) {
                this.tracer
                    .startSpan(name, {
                    ...options,
                    attributes: {
                        ...attributes,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL]: true,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
                    },
                }, parentContext)
                    .end();
            }
            const usageMeasurement = usage_api_js_1.usage.start();
            try {
                return await fn(span);
            }
            catch (e) {
                if (typeof e === "string" || e instanceof Error) {
                    span.recordException(e);
                }
                span.setStatus({ code: api_1.SpanStatusCode.ERROR });
                throw e;
            }
            finally {
                if (task_context_api_js_1.taskContext.ctx) {
                    const usageSample = usage_api_js_1.usage.stop(usageMeasurement);
                    const machine = task_context_api_js_1.taskContext.ctx.machine;
                    span.setAttributes({
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs
                            ? usageSample.cpuTime * machine.centsPerMs
                            : 0,
                    });
                }
                span.end(clock_api_js_1.clock.preciseNow());
            }
        });
    }
    startSpan(name, options, ctx) {
        const parentContext = ctx ?? api_1.context.active();
        const attributes = options?.attributes ?? {};
        const span = this.tracer.startSpan(name, options, ctx);
        this.tracer
            .startSpan(name, {
            ...options,
            attributes: {
                ...attributes,
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_PARTIAL]: true,
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
            },
        }, parentContext)
            .end();
        return span;
    }
}
exports.TriggerTracer = TriggerTracer;
//# sourceMappingURL=tracer.js.map