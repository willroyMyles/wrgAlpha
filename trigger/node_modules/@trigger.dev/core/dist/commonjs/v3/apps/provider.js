"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderShell = void 0;
const node_http_1 = require("node:http");
const http_js_1 = require("./http.js");
const logger_js_1 = require("./logger.js");
const isExecaChildProcess_js_1 = require("./isExecaChildProcess.js");
const promises_1 = require("node:timers/promises");
const process_js_1 = require("./process.js");
const messages_js_1 = require("../schemas/messages.js");
const zodMessageHandler_js_1 = require("../zodMessageHandler.js");
const zodSocket_js_1 = require("../zodSocket.js");
const HTTP_SERVER_PORT = Number(process.env.HTTP_SERVER_PORT || (0, http_js_1.getRandomPortNumber)());
const MACHINE_NAME = process.env.MACHINE_NAME || "local";
const PLATFORM_HOST = process.env.PLATFORM_HOST || "127.0.0.1";
const PLATFORM_WS_PORT = process.env.PLATFORM_WS_PORT || 3030;
const PLATFORM_SECRET = process.env.PLATFORM_SECRET || "provider-secret";
const SECURE_CONNECTION = ["1", "true"].includes(process.env.SECURE_CONNECTION ?? "false");
const logger = new logger_js_1.SimpleLogger(`[${MACHINE_NAME}]`);
class ProviderShell {
    options;
    tasks;
    #httpPort;
    #httpServer;
    platformSocket;
    constructor(options) {
        this.options = options;
        this.tasks = options.tasks;
        this.#httpPort = options.port ?? HTTP_SERVER_PORT;
        this.#httpServer = this.#createHttpServer();
        this.platformSocket = this.#createPlatformSocket();
        this.#createSharedQueueSocket();
    }
    #createSharedQueueSocket() {
        const sharedQueueConnection = new zodSocket_js_1.ZodSocketConnection({
            namespace: "shared-queue",
            host: PLATFORM_HOST,
            port: Number(PLATFORM_WS_PORT),
            secure: SECURE_CONNECTION,
            clientMessages: messages_js_1.ClientToSharedQueueMessages,
            serverMessages: messages_js_1.SharedQueueToClientMessages,
            authToken: PLATFORM_SECRET,
            handlers: {
                SERVER_READY: async (message) => {
                    // TODO: create new schema without worker requirement
                    await sender.send("READY_FOR_TASKS", {
                        backgroundWorkerId: "placeholder",
                    });
                },
                BACKGROUND_WORKER_MESSAGE: async (message) => {
                    if (message.data.type === "SCHEDULE_ATTEMPT") {
                        try {
                            await this.tasks.create({
                                image: message.data.image,
                                machine: message.data.machine,
                                version: message.data.version,
                                nextAttemptNumber: message.data.nextAttemptNumber,
                                // identifiers
                                envId: message.data.envId,
                                envType: message.data.envType,
                                orgId: message.data.orgId,
                                projectId: message.data.projectId,
                                runId: message.data.runId,
                            });
                        }
                        catch (error) {
                            logger.error("create failed", error);
                        }
                    }
                },
            },
        });
        const sender = new zodMessageHandler_js_1.ZodMessageSender({
            schema: messages_js_1.clientWebsocketMessages,
            sender: async (message) => {
                return new Promise((resolve, reject) => {
                    try {
                        const { type, ...payload } = message;
                        sharedQueueConnection.socket.emit(type, payload);
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            },
        });
        return sharedQueueConnection;
    }
    #createPlatformSocket() {
        const platformConnection = new zodSocket_js_1.ZodSocketConnection({
            namespace: "provider",
            host: PLATFORM_HOST,
            port: Number(PLATFORM_WS_PORT),
            secure: SECURE_CONNECTION,
            clientMessages: messages_js_1.ProviderToPlatformMessages,
            serverMessages: messages_js_1.PlatformToProviderMessages,
            authToken: PLATFORM_SECRET,
            extraHeaders: {
                "x-trigger-provider-type": this.options.type,
            },
            handlers: {
                INDEX: async (message) => {
                    try {
                        await this.tasks.index({
                            shortCode: message.shortCode,
                            imageRef: message.imageTag,
                            apiKey: message.apiKey,
                            apiUrl: message.apiUrl,
                            // identifiers
                            envId: message.envId,
                            envType: message.envType,
                            orgId: message.orgId,
                            projectId: message.projectId,
                            deploymentId: message.deploymentId,
                        });
                    }
                    catch (error) {
                        if ((0, isExecaChildProcess_js_1.isExecaChildProcess)(error)) {
                            logger.error("Index failed", {
                                socketMessage: message,
                                exitCode: error.exitCode,
                                escapedCommand: error.escapedCommand,
                                stdout: error.stdout,
                                stderr: error.stderr,
                            });
                            if (error.exitCode === process_js_1.EXIT_CODE_ALREADY_HANDLED) {
                                logger.error("Index failure already reported by the worker", {
                                    socketMessage: message,
                                });
                                // Add a brief delay to avoid messaging race conditions
                                await (0, promises_1.setTimeout)(2000);
                            }
                            function normalizeStderr(stderr) {
                                return stderr
                                    .split("\n")
                                    .map((line) => line.trim())
                                    .filter((line) => line.length > 0)
                                    .join("\n");
                            }
                            return {
                                success: false,
                                error: {
                                    name: "Index error",
                                    message: `Crashed with exit code ${error.exitCode}`,
                                    stderr: normalizeStderr(error.stderr),
                                },
                            };
                        }
                        else {
                            logger.error("Index failed", error);
                        }
                        if (error instanceof Error) {
                            return {
                                success: false,
                                error: {
                                    name: "Provider error",
                                    message: error.message,
                                    stack: error.stack,
                                },
                            };
                        }
                        else {
                            return {
                                success: false,
                                error: {
                                    name: "Provider error",
                                    message: "Unknown error",
                                },
                            };
                        }
                    }
                    return {
                        success: true,
                    };
                },
                RESTORE: async (message) => {
                    if (message.type.toLowerCase() !== this.options.type.toLowerCase()) {
                        logger.error(`restore failed: ${this.options.type} provider can't restore ${message.type} checkpoints`);
                        return;
                    }
                    try {
                        await this.tasks.restore({
                            checkpointRef: message.location,
                            machine: message.machine,
                            imageRef: message.imageRef,
                            attemptNumber: message.attemptNumber,
                            // identifiers
                            envId: message.envId,
                            envType: message.envType,
                            orgId: message.orgId,
                            projectId: message.projectId,
                            runId: message.runId,
                            checkpointId: message.checkpointId,
                        });
                    }
                    catch (error) {
                        logger.error("restore failed", error);
                    }
                },
                PRE_PULL_DEPLOYMENT: async (message) => {
                    if (!this.tasks.prePullDeployment) {
                        logger.debug("prePullDeployment not implemented", message);
                        return;
                    }
                    try {
                        await this.tasks.prePullDeployment({
                            shortCode: message.shortCode,
                            imageRef: message.imageRef,
                            // identifiers
                            envId: message.envId,
                            envType: message.envType,
                            orgId: message.orgId,
                            projectId: message.projectId,
                            deploymentId: message.deploymentId,
                        });
                    }
                    catch (error) {
                        logger.error("prePullDeployment failed", error);
                    }
                },
            },
        });
        return platformConnection;
    }
    #createHttpServer() {
        const httpServer = (0, node_http_1.createServer)(async (req, res) => {
            logger.log(`[${req.method}]`, req.url);
            const reply = new http_js_1.HttpReply(res);
            try {
                const url = new URL(req.url ?? "", `http://${req.headers.host}`);
                switch (url.pathname) {
                    case "/health": {
                        return reply.text("ok");
                    }
                    case "/whoami": {
                        return reply.text(`${MACHINE_NAME}`);
                    }
                    case "/close": {
                        this.platformSocket.close();
                        return reply.text("platform socket closed");
                    }
                    case "/delete": {
                        const body = await (0, http_js_1.getTextBody)(req);
                        if (this.tasks.delete) {
                            await this.tasks.delete({ runId: body });
                            return reply.text(`sent delete request: ${body}`);
                        }
                        else {
                            return reply.text("delete not implemented", 501);
                        }
                    }
                    default: {
                        return reply.empty(404);
                    }
                }
            }
            catch (error) {
                logger.error("HTTP server error", { error });
                reply.empty(500);
                return;
            }
        });
        httpServer.on("clientError", (err, socket) => {
            socket.end("HTTP/1.1 400 Bad Request\r\n\r\n");
        });
        httpServer.on("listening", () => {
            logger.log("server listening on port", this.#httpPort);
        });
        return httpServer;
    }
    async listen() {
        this.#httpServer.listen(this.#httpPort, this.options.host ?? "0.0.0.0");
        await this.tasks.init();
    }
}
exports.ProviderShell = ProviderShell;
//# sourceMappingURL=provider.js.map