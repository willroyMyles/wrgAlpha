"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodNamespace = void 0;
const zodMessageHandler_js_1 = require("./zodMessageHandler.js");
const zodSocket_js_1 = require("./zodSocket.js");
const structuredLogger_js_1 = require("./utils/structuredLogger.js");
class ZodNamespace {
    #logger;
    #handler;
    sender;
    io;
    namespace;
    constructor(opts) {
        this.#logger = opts.logger ?? new structuredLogger_js_1.SimpleStructuredLogger(opts.name);
        this.#handler = new zodSocket_js_1.ZodSocketMessageHandler({
            schema: opts.clientMessages,
            handlers: opts.handlers,
        });
        this.io = opts.io;
        this.namespace = this.io.of(opts.name);
        // FIXME: There's a bug here, this sender should not accept Socket schemas with callbacks
        this.sender = new zodMessageHandler_js_1.ZodMessageSender({
            schema: opts.serverMessages,
            sender: async (message) => {
                return new Promise((resolve, reject) => {
                    try {
                        // @ts-expect-error
                        this.namespace.emit(message.type, message.payload);
                        resolve();
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            },
        });
        if (opts.preAuth) {
            this.namespace.use(async (socket, next) => {
                const logger = this.#logger.child({ socketId: socket.id, socketStage: "preAuth" });
                if (typeof opts.preAuth === "function") {
                    await opts.preAuth(socket, next, logger);
                }
            });
        }
        if (opts.authToken) {
            this.namespace.use((socket, next) => {
                const logger = this.#logger.child({ socketId: socket.id, socketStage: "auth" });
                const { auth } = socket.handshake;
                if (!("token" in auth)) {
                    logger.error("no token");
                    return socket.disconnect(true);
                }
                if (auth.token !== opts.authToken) {
                    logger.error("invalid token");
                    return socket.disconnect(true);
                }
                logger.info("success");
                next();
                return;
            });
        }
        if (opts.postAuth) {
            this.namespace.use(async (socket, next) => {
                const logger = this.#logger.child({ socketId: socket.id, socketStage: "auth" });
                if (typeof opts.postAuth === "function") {
                    await opts.postAuth(socket, next, logger);
                }
            });
        }
        this.namespace.on("connection", async (socket) => {
            const logger = this.#logger.child({ socketId: socket.id, socketStage: "connection" });
            logger.info("connected");
            this.#handler.registerHandlers(socket, logger);
            socket.on("disconnect", async (reason, description) => {
                logger.info("disconnect", { reason, description });
                if (opts.onDisconnect) {
                    await opts.onDisconnect(socket, reason, description, logger);
                }
            });
            socket.on("error", async (error) => {
                logger.error("error", { error });
                if (opts.onError) {
                    await opts.onError(socket, error, logger);
                }
            });
            if (opts.onConnection) {
                await opts.onConnection(socket, this.#handler, this.sender, logger);
            }
        });
    }
    fetchSockets() {
        return this.namespace.fetchSockets();
    }
}
exports.ZodNamespace = ZodNamespace;
//# sourceMappingURL=zodNamespace.js.map