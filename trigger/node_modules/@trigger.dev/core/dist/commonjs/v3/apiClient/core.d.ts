import { z } from "zod";
import { RetryOptions } from "../schemas/index.js";
import { Attributes, Span } from "@opentelemetry/api";
import { TriggerTracer } from "../tracer.js";
import { CursorPage, CursorPageParams, CursorPageResponse, OffsetLimitPage, OffsetLimitPageParams, OffsetLimitPageResponse } from "./pagination.js";
export declare const defaultRetryOptions: {
    maxAttempts: number;
    factor: number;
    minTimeoutInMs: number;
    maxTimeoutInMs: number;
    randomize: false;
};
export type ZodFetchOptions = {
    retry?: RetryOptions;
    tracer?: TriggerTracer;
    name?: string;
    attributes?: Attributes;
    icon?: string;
    onResponseBody?: (body: unknown, span: Span) => void;
};
export type ApiRequestOptions = Pick<ZodFetchOptions, "retry">;
export declare const isRequestOptions: (obj: unknown) => obj is ApiRequestOptions;
interface FetchCursorPageParams extends CursorPageParams {
    query?: URLSearchParams;
}
interface FetchOffsetLimitPageParams extends OffsetLimitPageParams {
    query?: URLSearchParams;
}
export declare function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(schema: TResponseBodySchema, url: string, requestInit?: RequestInit, options?: ZodFetchOptions): ApiPromise<z.output<TResponseBodySchema>>;
export declare function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(schema: TItemSchema, url: string, params: FetchCursorPageParams, requestInit?: RequestInit, options?: ZodFetchOptions): CursorPagePromise<TItemSchema>;
export declare function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(schema: TItemSchema, url: string, params: FetchOffsetLimitPageParams, requestInit?: RequestInit, options?: ZodFetchOptions): OffsetLimitPagePromise<TItemSchema>;
type ZodFetchResult<T> = {
    data: T;
    response: Response;
};
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
export declare class ApiPromise<T> extends Promise<T> {
    private responsePromise;
    constructor(responsePromise: Promise<ZodFetchResult<T>>);
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     */
    asResponse(): Promise<Response>;
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     */
    withResponse(): Promise<{
        data: T;
        response: Response;
    }>;
    private parse;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
export declare class CursorPagePromise<TItemSchema extends z.ZodTypeAny> extends ApiPromise<CursorPage<z.output<TItemSchema>>> implements AsyncIterable<z.output<TItemSchema>> {
    #private;
    private schema;
    private url;
    private params;
    private requestInit?;
    private options?;
    constructor(result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>, schema: TItemSchema, url: string, params: FetchCursorPageParams, requestInit?: RequestInit | undefined, options?: ZodFetchOptions | undefined);
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<z.output<TItemSchema>>, void, unknown>;
}
export declare class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny> extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>> implements AsyncIterable<z.output<TItemSchema>> {
    #private;
    private schema;
    private url;
    private params;
    private requestInit?;
    private options?;
    constructor(result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>, schema: TItemSchema, url: string, params: FetchOffsetLimitPageParams, requestInit?: RequestInit | undefined, options?: ZodFetchOptions | undefined);
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<z.output<TItemSchema>>, void, unknown>;
}
export declare function isEmptyObj(obj: Object | null | undefined): boolean;
export declare function hasOwn(obj: Object, key: string): boolean;
export {};
