"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiClient = exports.isRequestOptions = void 0;
exports.mergeRequestOptions = mergeRequestOptions;
const api_1 = require("@opentelemetry/api");
const zod_1 = require("zod");
const index_js_1 = require("../schemas/index.js");
const task_context_api_js_1 = require("../task-context-api.js");
const core_js_1 = require("./core.js");
Object.defineProperty(exports, "isRequestOptions", { enumerable: true, get: function () { return core_js_1.isRequestOptions; } });
const errors_js_1 = require("./errors.js");
const version_js_1 = require("../../version.js");
const DEFAULT_ZOD_FETCH_OPTIONS = {
    retry: {
        maxAttempts: 3,
        minTimeoutInMs: 1000,
        maxTimeoutInMs: 30_000,
        factor: 2,
        randomize: false,
    },
};
/**
 * Trigger.dev v3 API client
 */
class ApiClient {
    accessToken;
    baseUrl;
    defaultRequestOptions;
    constructor(baseUrl, accessToken, requestOptions = {}) {
        this.accessToken = accessToken;
        this.baseUrl = baseUrl.replace(/\/$/, "");
        this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);
    }
    async getRunResult(runId, requestOptions) {
        try {
            return await (0, core_js_1.zodfetch)(index_js_1.TaskRunExecutionResult, `${this.baseUrl}/api/v1/runs/${runId}/result`, {
                method: "GET",
                headers: this.#getHeaders(false),
            }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
        }
        catch (error) {
            if (error instanceof errors_js_1.ApiError) {
                if (error.status === 404) {
                    return undefined;
                }
            }
            throw error;
        }
    }
    async getBatchResults(batchId, requestOptions) {
        return await (0, core_js_1.zodfetch)(index_js_1.BatchTaskRunExecutionResult, `${this.baseUrl}/api/v1/batches/${batchId}/results`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    triggerTask(taskId, body, options, requestOptions) {
        const encodedTaskId = encodeURIComponent(taskId);
        return (0, core_js_1.zodfetch)(index_js_1.TriggerTaskResponse, `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`, {
            method: "POST",
            headers: this.#getHeaders(options?.spanParentAsLink ?? false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    batchTriggerTask(taskId, body, options, requestOptions) {
        const encodedTaskId = encodeURIComponent(taskId);
        return (0, core_js_1.zodfetch)(index_js_1.BatchTriggerTaskResponse, `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/batch`, {
            method: "POST",
            headers: this.#getHeaders(options?.spanParentAsLink ?? false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createUploadPayloadUrl(filename, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    getPayloadUrl(filename, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CreateUploadPayloadUrlResponseBody, `${this.baseUrl}/api/v1/packets/${filename}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.RetrieveRunResponse, `${this.baseUrl}/api/v3/runs/${runId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listRuns(query, requestOptions) {
        const searchParams = createSearchQueryForListRuns(query);
        return (0, core_js_1.zodfetchCursorPage)(index_js_1.ListRunResponseItem, `${this.baseUrl}/api/v1/runs`, {
            query: searchParams,
            limit: query?.limit,
            after: query?.after,
            before: query?.before,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listProjectRuns(projectRef, query, requestOptions) {
        const searchParams = createSearchQueryForListRuns(query);
        if (query?.env) {
            searchParams.append("filter[env]", Array.isArray(query.env) ? query.env.join(",") : query.env);
        }
        return (0, core_js_1.zodfetchCursorPage)(index_js_1.ListRunResponseItem, `${this.baseUrl}/api/v1/projects/${projectRef}/runs`, {
            query: searchParams,
            limit: query?.limit,
            after: query?.after,
            before: query?.before,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    replayRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ReplayRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/replay`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    cancelRun(runId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.CanceledRunResponse, `${this.baseUrl}/api/v2/runs/${runId}/cancel`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    rescheduleRun(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.RetrieveRunResponse, `${this.baseUrl}/api/v1/runs/${runId}/reschedule`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    addTags(runId, body, requestOptions) {
        return (0, core_js_1.zodfetch)(zod_1.z.object({ message: zod_1.z.string() }), `${this.baseUrl}/api/v1/runs/${runId}/tags`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createSchedule(options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listSchedules(options, requestOptions) {
        const searchParams = new URLSearchParams();
        if (options?.page) {
            searchParams.append("page", options.page.toString());
        }
        if (options?.perPage) {
            searchParams.append("perPage", options.perPage.toString());
        }
        return (0, core_js_1.zodfetchOffsetLimitPage)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules`, {
            page: options?.page,
            limit: options?.perPage,
        }, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    updateSchedule(scheduleId, options, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
            body: JSON.stringify(options),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deactivateSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    activateSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.ScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`, {
            method: "POST",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deleteSchedule(scheduleId, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.DeletedScheduleObject, `${this.baseUrl}/api/v1/schedules/${scheduleId}`, {
            method: "DELETE",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    listEnvVars(projectRef, slug, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariables, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    importEnvVars(projectRef, slug, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    retrieveEnvVar(projectRef, slug, key, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableValue, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "GET",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    createEnvVar(projectRef, slug, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`, {
            method: "POST",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    updateEnvVar(projectRef, slug, key, body, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "PUT",
            headers: this.#getHeaders(false),
            body: JSON.stringify(body),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    deleteEnvVar(projectRef, slug, key, requestOptions) {
        return (0, core_js_1.zodfetch)(index_js_1.EnvironmentVariableResponseBody, `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`, {
            method: "DELETE",
            headers: this.#getHeaders(false),
        }, mergeRequestOptions(this.defaultRequestOptions, requestOptions));
    }
    #getHeaders(spanParentAsLink) {
        const headers = {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.accessToken}`,
            "trigger-version": version_js_1.VERSION,
        };
        // Only inject the context if we are inside a task
        if (task_context_api_js_1.taskContext.isInsideTask) {
            headers["x-trigger-worker"] = "true";
            api_1.propagation.inject(api_1.context.active(), headers);
            if (spanParentAsLink) {
                headers["x-trigger-span-parent-as-link"] = "1";
            }
        }
        return headers;
    }
}
exports.ApiClient = ApiClient;
function createSearchQueryForListRuns(query) {
    const searchParams = new URLSearchParams();
    if (query) {
        if (query.status) {
            searchParams.append("filter[status]", Array.isArray(query.status) ? query.status.join(",") : query.status);
        }
        if (query.taskIdentifier) {
            searchParams.append("filter[taskIdentifier]", Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(",") : query.taskIdentifier);
        }
        if (query.version) {
            searchParams.append("filter[version]", Array.isArray(query.version) ? query.version.join(",") : query.version);
        }
        if (query.bulkAction) {
            searchParams.append("filter[bulkAction]", query.bulkAction);
        }
        if (query.tag) {
            searchParams.append("filter[tag]", Array.isArray(query.tag) ? query.tag.join(",") : query.tag);
        }
        if (query.schedule) {
            searchParams.append("filter[schedule]", query.schedule);
        }
        if (typeof query.isTest === "boolean") {
            searchParams.append("filter[isTest]", String(query.isTest));
        }
        if (query.from) {
            searchParams.append("filter[createdAt][from]", query.from instanceof Date ? query.from.getTime().toString() : query.from.toString());
        }
        if (query.to) {
            searchParams.append("filter[createdAt][to]", query.to instanceof Date ? query.to.getTime().toString() : query.to.toString());
        }
        if (query.period) {
            searchParams.append("filter[createdAt][period]", query.period);
        }
    }
    return searchParams;
}
function mergeRequestOptions(defaultOptions, options) {
    if (!options) {
        return defaultOptions;
    }
    return {
        ...defaultOptions,
        ...options,
        retry: {
            ...defaultOptions.retry,
            ...options.retry,
        },
    };
}
//# sourceMappingURL=index.js.map