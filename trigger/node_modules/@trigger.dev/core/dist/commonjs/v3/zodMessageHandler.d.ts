import { z } from "zod";
import { StructuredLogger } from "./utils/structuredLogger.js";
export declare class ZodSchemaParsedError extends Error {
    error: z.ZodError;
    payload: unknown;
    constructor(error: z.ZodError, payload: unknown);
}
export type ZodMessageValueSchema<TDiscriminatedUnion extends z.ZodDiscriminatedUnion<any, any>> = z.ZodFirstPartySchemaTypes | TDiscriminatedUnion;
export interface ZodMessageCatalogSchema {
    [key: string]: ZodMessageValueSchema<any>;
}
export type ZodMessageHandlers<TCatalogSchema extends ZodMessageCatalogSchema> = Partial<{
    [K in keyof TCatalogSchema]: (payload: z.infer<TCatalogSchema[K]>) => Promise<any>;
}>;
export type ZodMessageHandlerOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {
    schema: TMessageCatalog;
    messages?: ZodMessageHandlers<TMessageCatalog>;
    logger?: StructuredLogger;
};
export type MessageFromSchema<K extends keyof TMessageCatalog, TMessageCatalog extends ZodMessageCatalogSchema> = {
    type: K;
    payload: z.input<TMessageCatalog[K]>;
};
export type MessagePayloadFromSchema<K extends keyof TMessageCatalog, TMessageCatalog extends ZodMessageCatalogSchema> = z.output<TMessageCatalog[K]>;
export type MessageFromCatalog<TMessageCatalog extends ZodMessageCatalogSchema> = {
    [K in keyof TMessageCatalog]: MessageFromSchema<K, TMessageCatalog>;
}[keyof TMessageCatalog];
export declare const ZodMessageSchema: z.ZodObject<{
    version: z.ZodDefault<z.ZodLiteral<"v1">>;
    type: z.ZodString;
    payload: z.ZodUnknown;
}, "strip", z.ZodTypeAny, {
    type: string;
    version: "v1";
    payload?: unknown;
}, {
    type: string;
    version?: "v1" | undefined;
    payload?: unknown;
}>;
export interface EventEmitterLike {
    on(eventName: string | symbol, listener: (...args: any[]) => void): this;
}
export declare class ZodMessageHandler<TMessageCatalog extends ZodMessageCatalogSchema> {
    #private;
    constructor(options: ZodMessageHandlerOptions<TMessageCatalog>);
    handleMessage(message: unknown): Promise<{
        success: true;
        data: unknown;
    } | {
        success: false;
        error: string;
    }>;
    parseMessage(message: unknown): {
        success: true;
        data: MessageFromCatalog<TMessageCatalog>;
    } | {
        success: false;
        error: string;
    };
    registerHandlers(emitter: EventEmitterLike, logger?: StructuredLogger): void;
}
export declare function parseMessageFromCatalog<TMessageCatalog extends ZodMessageCatalogSchema>(message: unknown, schema: TMessageCatalog): MessageFromCatalog<TMessageCatalog>;
type ZodMessageSenderCallback<TMessageCatalog extends ZodMessageCatalogSchema> = (message: {
    type: keyof TMessageCatalog;
    payload: z.infer<TMessageCatalog[keyof TMessageCatalog]>;
    version: "v1";
}) => Promise<void>;
export type ZodMessageSenderOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {
    schema: TMessageCatalog;
    sender: ZodMessageSenderCallback<TMessageCatalog>;
};
export declare class ZodMessageSender<TMessageCatalog extends ZodMessageCatalogSchema> {
    #private;
    constructor(options: ZodMessageSenderOptions<TMessageCatalog>);
    send<K extends keyof TMessageCatalog>(type: K, payload: z.input<TMessageCatalog[K]>): Promise<void>;
    forwardMessage(message: unknown): Promise<void>;
}
export declare function sendMessageInCatalog<TMessageCatalog extends ZodMessageCatalogSchema>(catalog: TMessageCatalog, type: keyof TMessageCatalog, payload: z.input<TMessageCatalog[keyof TMessageCatalog]>, sender: ZodMessageSenderCallback<TMessageCatalog>): Promise<void>;
export type MessageCatalogToSocketIoEvents<TCatalog extends ZodMessageCatalogSchema> = {
    [K in keyof TCatalog]: (message: z.infer<TCatalog[K]>) => void;
};
export {};
