"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProdUsageManager = void 0;
const promises_1 = require("node:timers/promises");
const usageClient_js_1 = require("./usageClient.js");
class ProdUsageManager {
    delegageUsageManager;
    options;
    _measurement;
    _abortController;
    _lastSample;
    _usageClient;
    constructor(delegageUsageManager, options) {
        this.delegageUsageManager = delegageUsageManager;
        this.options = options;
        if (this.options.url && this.options.jwt) {
            this._usageClient = new usageClient_js_1.UsageClient(this.options.url, this.options.jwt);
        }
    }
    get isReportingEnabled() {
        return typeof this._usageClient !== "undefined";
    }
    disable() {
        this.delegageUsageManager.disable();
        this._abortController?.abort();
    }
    sample() {
        return this._measurement?.sample();
    }
    start() {
        if (!this.isReportingEnabled || !this.options.heartbeatIntervalMs) {
            return this.delegageUsageManager.start();
        }
        if (!this._measurement) {
            this._measurement = this.delegageUsageManager.start();
            this.#startReportingHeartbeat().catch(console.error);
            return this._measurement;
        }
        return this.delegageUsageManager.start();
    }
    stop(measurement) {
        return this.delegageUsageManager.stop(measurement);
    }
    async pauseAsync(cb) {
        return this.delegageUsageManager.pauseAsync(cb);
    }
    async #startReportingHeartbeat() {
        if (!this._measurement || !this.isReportingEnabled || !this.options.heartbeatIntervalMs) {
            return;
        }
        this._abortController = new AbortController();
        for await (const _ of (0, promises_1.setInterval)(this.options.heartbeatIntervalMs)) {
            if (this._abortController.signal.aborted) {
                break;
            }
            await this.#reportUsage();
        }
    }
    async flush() {
        return await this.#reportUsage();
    }
    async #reportUsage() {
        if (!this._measurement) {
            return;
        }
        if (!this.isReportingEnabled) {
            return;
        }
        const client = this._usageClient;
        if (!client) {
            return;
        }
        const sample = this._measurement.sample();
        const cpuTimeSinceLastSample = this._lastSample
            ? sample.cpuTime - this._lastSample.cpuTime
            : sample.cpuTime;
        this._lastSample = sample;
        if (cpuTimeSinceLastSample <= 0) {
            return;
        }
        await client.sendUsageEvent({ durationMs: cpuTimeSinceLastSample });
    }
}
exports.ProdUsageManager = ProdUsageManager;
//# sourceMappingURL=prodUsageManager.js.map