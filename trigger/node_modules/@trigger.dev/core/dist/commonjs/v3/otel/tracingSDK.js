"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TracingSDK = void 0;
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const resources_1 = require("@opentelemetry/resources");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const version_js_1 = require("../../version.js");
const limits_js_1 = require("../limits.js");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const otelProcessors_js_1 = require("../taskContext/otelProcessors.js");
const getEnv_js_1 = require("../utils/getEnv.js");
class AsyncResourceDetector {
    _promise;
    _resolver;
    _resolved = false;
    constructor() {
        this._promise = new Promise((resolver) => {
            this._resolver = resolver;
        });
    }
    detect(_config) {
        return new resources_1.Resource({}, this._promise);
    }
    resolveWithAttributes(attributes) {
        if (!this._resolver) {
            throw new Error("Resolver not available");
        }
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        this._resolver(attributes);
    }
}
class TracingSDK {
    config;
    asyncResourceDetector = new AsyncResourceDetector();
    _logProvider;
    _spanExporter;
    _traceProvider;
    getLogger;
    getTracer;
    constructor(config) {
        this.config = config;
        setLogLevel(config.diagLogLevel ?? "none");
        const envResourceAttributesSerialized = (0, getEnv_js_1.getEnvVar)("OTEL_RESOURCE_ATTRIBUTES");
        const envResourceAttributes = envResourceAttributesSerialized
            ? JSON.parse(envResourceAttributesSerialized)
            : {};
        const commonResources = (0, resources_1.detectResourcesSync)({
            detectors: [this.asyncResourceDetector, resources_1.processDetectorSync],
        })
            .merge(new resources_1.Resource({
            [semantic_conventions_1.SemanticResourceAttributes.CLOUD_PROVIDER]: "trigger.dev",
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.TRIGGER]: true,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.CLI_VERSION]: version_js_1.VERSION,
        }))
            .merge(config.resource ?? new resources_1.Resource({}))
            .merge(new resources_1.Resource(envResourceAttributes));
        const traceProvider = new sdk_trace_node_1.NodeTracerProvider({
            forceFlushTimeoutMillis: config.forceFlushTimeoutMillis,
            resource: commonResources,
            spanLimits: {
                attributeCountLimit: limits_js_1.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: limits_js_1.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
                eventCountLimit: limits_js_1.OTEL_SPAN_EVENT_COUNT_LIMIT,
                attributePerEventCountLimit: limits_js_1.OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
                linkCountLimit: limits_js_1.OTEL_LINK_COUNT_LIMIT,
                attributePerLinkCountLimit: limits_js_1.OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
            },
        });
        const spanExporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({
            url: `${config.url}/v1/traces`,
            timeoutMillis: config.forceFlushTimeoutMillis,
        });
        traceProvider.addSpanProcessor(new otelProcessors_js_1.TaskContextSpanProcessor((0, getEnv_js_1.getEnvVar)("OTEL_BATCH_PROCESSING_ENABLED") === "1"
            ? new sdk_trace_node_1.BatchSpanProcessor(spanExporter, {
                maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_SPAN_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_SPAN_SCHEDULED_DELAY_MILLIS") ?? "200"),
                exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_SPAN_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_SPAN_MAX_QUEUE_SIZE") ?? "512"),
            })
            : new sdk_trace_node_1.SimpleSpanProcessor(spanExporter)));
        traceProvider.register();
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: config.instrumentations ?? [],
            tracerProvider: traceProvider,
        });
        const logExporter = new exporter_logs_otlp_http_1.OTLPLogExporter({
            url: `${config.url}/v1/logs`,
        });
        // To start a logger, you first need to initialize the Logger provider.
        const loggerProvider = new sdk_logs_1.LoggerProvider({
            resource: commonResources,
            logRecordLimits: {
                attributeCountLimit: limits_js_1.OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: limits_js_1.OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            },
        });
        loggerProvider.addLogRecordProcessor(new otelProcessors_js_1.TaskContextLogProcessor((0, getEnv_js_1.getEnvVar)("OTEL_BATCH_PROCESSING_ENABLED") === "1"
            ? new sdk_logs_1.BatchLogRecordProcessor(logExporter, {
                maxExportBatchSize: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_LOG_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                scheduledDelayMillis: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_LOG_SCHEDULED_DELAY_MILLIS") ?? "200"),
                exportTimeoutMillis: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_LOG_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                maxQueueSize: parseInt((0, getEnv_js_1.getEnvVar)("OTEL_LOG_MAX_QUEUE_SIZE") ?? "512"),
            })
            : new sdk_logs_1.SimpleLogRecordProcessor(logExporter)));
        this._logProvider = loggerProvider;
        this._spanExporter = spanExporter;
        this._traceProvider = traceProvider;
        api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
        this.getLogger = loggerProvider.getLogger.bind(loggerProvider);
        this.getTracer = traceProvider.getTracer.bind(traceProvider);
    }
    async flush() {
        await Promise.all([this._traceProvider.forceFlush(), this._logProvider.forceFlush()]);
    }
    async shutdown() {
        await Promise.all([this._traceProvider.shutdown(), this._logProvider.shutdown()]);
    }
}
exports.TracingSDK = TracingSDK;
function setLogLevel(level) {
    let diagLogLevel;
    switch (level) {
        case "none":
            diagLogLevel = api_1.DiagLogLevel.NONE;
            break;
        case "error":
            diagLogLevel = api_1.DiagLogLevel.ERROR;
            break;
        case "warn":
            diagLogLevel = api_1.DiagLogLevel.WARN;
            break;
        case "info":
            diagLogLevel = api_1.DiagLogLevel.INFO;
            break;
        case "debug":
            diagLogLevel = api_1.DiagLogLevel.DEBUG;
            break;
        case "verbose":
            diagLogLevel = api_1.DiagLogLevel.VERBOSE;
            break;
        case "all":
            diagLogLevel = api_1.DiagLogLevel.ALL;
            break;
        default:
            diagLogLevel = api_1.DiagLogLevel.NONE;
    }
    api_1.diag.setLogger(new api_1.DiagConsoleLogger(), diagLogLevel);
}
//# sourceMappingURL=tracingSDK.js.map