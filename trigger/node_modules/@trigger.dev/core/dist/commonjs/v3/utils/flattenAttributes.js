"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NULL_SENTINEL = void 0;
exports.flattenAttributes = flattenAttributes;
exports.unflattenAttributes = unflattenAttributes;
exports.primitiveValueOrflattenedAttributes = primitiveValueOrflattenedAttributes;
exports.NULL_SENTINEL = "$@null((";
function flattenAttributes(obj, prefix) {
    const result = {};
    // Check if obj is null or undefined
    if (obj === undefined) {
        return result;
    }
    if (obj === null) {
        result[prefix || ""] = exports.NULL_SENTINEL;
        return result;
    }
    if (typeof obj === "string") {
        result[prefix || ""] = obj;
        return result;
    }
    if (typeof obj === "number") {
        result[prefix || ""] = obj;
        return result;
    }
    if (typeof obj === "boolean") {
        result[prefix || ""] = obj;
        return result;
    }
    if (obj instanceof Date) {
        result[prefix || ""] = obj.toISOString();
        return result;
    }
    for (const [key, value] of Object.entries(obj)) {
        const newPrefix = `${prefix ? `${prefix}.` : ""}${Array.isArray(obj) ? `[${key}]` : key}`;
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                if (typeof value[i] === "object" && value[i] !== null) {
                    // update null check here as well
                    Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));
                }
                else {
                    if (value[i] === null) {
                        result[`${newPrefix}.[${i}]`] = exports.NULL_SENTINEL;
                    }
                    else {
                        result[`${newPrefix}.[${i}]`] = value[i];
                    }
                }
            }
        }
        else if (isRecord(value)) {
            // update null check here
            Object.assign(result, flattenAttributes(value, newPrefix));
        }
        else {
            if (typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
                result[newPrefix] = value;
            }
            else if (value === null) {
                result[newPrefix] = exports.NULL_SENTINEL;
            }
        }
    }
    return result;
}
function isRecord(value) {
    return value !== null && typeof value === "object" && !Array.isArray(value);
}
function unflattenAttributes(obj) {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return obj;
    }
    if (typeof obj === "object" &&
        obj !== null &&
        Object.keys(obj).length === 1 &&
        Object.keys(obj)[0] === "") {
        return rehydrateNull(obj[""]);
    }
    if (Object.keys(obj).length === 0) {
        return;
    }
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        const parts = key.split(".").reduce((acc, part) => {
            if (part.includes("[")) {
                // Handling nested array indices
                const subparts = part.split(/\[|\]/).filter((p) => p !== "");
                acc.push(...subparts);
            }
            else {
                acc.push(part);
            }
            return acc;
        }, []);
        let current = result;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!part) {
                continue;
            }
            const nextPart = parts[i + 1];
            const isArray = nextPart && /^\d+$/.test(nextPart);
            if (isArray && !Array.isArray(current[part])) {
                current[part] = [];
            }
            else if (!isArray && current[part] === undefined) {
                current[part] = {};
            }
            current = current[part];
        }
        const lastPart = parts[parts.length - 1];
        if (lastPart) {
            current[lastPart] = rehydrateNull(value);
        }
    }
    // Convert the result to an array if all top-level keys are numeric indices
    if (Object.keys(result).every((k) => /^\d+$/.test(k))) {
        const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));
        const arrayResult = Array(maxIndex + 1);
        for (const key in result) {
            arrayResult[parseInt(key)] = result[key];
        }
        return arrayResult;
    }
    return result;
}
function primitiveValueOrflattenedAttributes(obj, prefix) {
    if (typeof obj === "string" ||
        typeof obj === "number" ||
        typeof obj === "boolean" ||
        obj === null ||
        obj === undefined) {
        return obj;
    }
    const attributes = flattenAttributes(obj, prefix);
    if (prefix !== undefined &&
        typeof attributes[prefix] !== "undefined" &&
        attributes[prefix] !== null) {
        return attributes[prefix];
    }
    return attributes;
}
function rehydrateNull(value) {
    if (value === exports.NULL_SENTINEL) {
        return null;
    }
    return value;
}
//# sourceMappingURL=flattenAttributes.js.map