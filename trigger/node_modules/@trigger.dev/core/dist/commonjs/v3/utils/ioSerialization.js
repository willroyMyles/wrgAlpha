"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePacket = parsePacket;
exports.stringifyIO = stringifyIO;
exports.conditionallyExportPacket = conditionallyExportPacket;
exports.packetRequiresOffloading = packetRequiresOffloading;
exports.conditionallyImportPacket = conditionallyImportPacket;
exports.resolvePresignedPacketUrl = resolvePresignedPacketUrl;
exports.createPacketAttributes = createPacketAttributes;
exports.createPacketAttributesAsJson = createPacketAttributesAsJson;
exports.prettyPrintPacket = prettyPrintPacket;
exports.replaceSuperJsonPayload = replaceSuperJsonPayload;
const limits_js_1 = require("../limits.js");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const flattenAttributes_js_1 = require("./flattenAttributes.js");
const apiClientManager_api_js_1 = require("../apiClientManager-api.js");
async function parsePacket(value) {
    if (!value.data) {
        return undefined;
    }
    switch (value.dataType) {
        case "application/json":
            return JSON.parse(value.data);
        case "application/super+json":
            const { parse } = await loadSuperJSON();
            return parse(value.data);
        case "text/plain":
            return value.data;
        case "application/store":
            throw new Error(`Cannot parse an application/store packet (${value.data}). Needs to be imported first.`);
        default:
            return value.data;
    }
}
async function stringifyIO(value) {
    if (value === undefined) {
        return { dataType: "application/json" };
    }
    if (typeof value === "string") {
        return { data: value, dataType: "text/plain" };
    }
    try {
        const { stringify } = await loadSuperJSON();
        const data = stringify(value);
        return { data, dataType: "application/super+json" };
    }
    catch {
        return { data: value, dataType: "application/json" };
    }
}
async function conditionallyExportPacket(packet, pathPrefix, tracer) {
    if (apiClientManager_api_js_1.apiClientManager.client) {
        const { needsOffloading, size } = packetRequiresOffloading(packet);
        if (needsOffloading) {
            if (!tracer) {
                return await exportPacket(packet, pathPrefix);
            }
            else {
                const result = await tracer.startActiveSpan("store.uploadOutput", async (span) => {
                    return await exportPacket(packet, pathPrefix);
                }, {
                    attributes: {
                        byteLength: size,
                        [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-upload",
                    },
                });
                return result ?? packet;
            }
        }
    }
    return packet;
}
function packetRequiresOffloading(packet, lengthLimit) {
    if (!packet.data) {
        return {
            needsOffloading: false,
            size: 0,
        };
    }
    const byteSize = Buffer.byteLength(packet.data, "utf8");
    return {
        needsOffloading: byteSize >= (lengthLimit ?? limits_js_1.OFFLOAD_IO_PACKET_LENGTH_LIMIT),
        size: byteSize,
    };
}
async function exportPacket(packet, pathPrefix) {
    // Offload the output
    const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;
    const presignedResponse = await apiClientManager_api_js_1.apiClientManager.client.createUploadPayloadUrl(filename);
    const uploadResponse = await fetch(presignedResponse.presignedUrl, {
        method: "PUT",
        headers: {
            "Content-Type": packet.dataType,
        },
        body: packet.data,
    });
    if (!uploadResponse.ok) {
        throw new Error(`Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`);
    }
    return {
        data: filename,
        dataType: "application/store",
    };
}
async function conditionallyImportPacket(packet, tracer) {
    if (packet.dataType !== "application/store") {
        return packet;
    }
    if (!tracer) {
        return await importPacket(packet);
    }
    else {
        const result = await tracer.startActiveSpan("store.downloadPayload", async (span) => {
            return await importPacket(packet, span);
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
            },
        });
        return result ?? packet;
    }
}
async function resolvePresignedPacketUrl(url, tracer) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return;
        }
        const data = await response.text();
        const dataType = response.headers.get("content-type") ?? "application/json";
        const packet = {
            data,
            dataType,
        };
        return await parsePacket(packet);
    }
    catch (error) {
        return;
    }
}
async function importPacket(packet, span) {
    if (!packet.data) {
        return packet;
    }
    if (!apiClientManager_api_js_1.apiClientManager.client) {
        return packet;
    }
    const presignedResponse = await apiClientManager_api_js_1.apiClientManager.client.getPayloadUrl(packet.data);
    const response = await fetch(presignedResponse.presignedUrl);
    if (!response.ok) {
        throw new Error(`Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`);
    }
    const data = await response.text();
    span?.setAttribute("size", Buffer.byteLength(data, "utf8"));
    return {
        data,
        dataType: response.headers.get("content-type") ?? "application/json",
    };
}
async function createPacketAttributes(packet, dataKey, dataTypeKey) {
    if (!packet.data) {
        return;
    }
    switch (packet.dataType) {
        case "application/json":
            return {
                ...(0, flattenAttributes_js_1.flattenAttributes)(packet, dataKey),
                [dataTypeKey]: packet.dataType,
            };
        case "application/super+json":
            const { parse } = await loadSuperJSON();
            if (typeof packet.data === "undefined" || packet.data === null) {
                return;
            }
            try {
                const parsed = parse(packet.data);
                const jsonified = JSON.parse(JSON.stringify(parsed, safeReplacer));
                const result = {
                    ...(0, flattenAttributes_js_1.flattenAttributes)(jsonified, dataKey),
                    [dataTypeKey]: "application/json",
                };
                return result;
            }
            catch (e) {
                return;
            }
        case "application/store":
            return {
                [dataKey]: packet.data,
                [dataTypeKey]: packet.dataType,
            };
        case "text/plain":
            return {
                [dataKey]: packet.data,
                [dataTypeKey]: packet.dataType,
            };
        default:
            return;
    }
}
async function createPacketAttributesAsJson(data, dataType) {
    if (typeof data === "string" ||
        typeof data === "number" ||
        typeof data === "boolean" ||
        data === null ||
        data === undefined) {
        return data;
    }
    switch (dataType) {
        case "application/json":
            return (0, limits_js_1.imposeAttributeLimits)((0, flattenAttributes_js_1.flattenAttributes)(data, undefined));
        case "application/super+json":
            const { deserialize } = await loadSuperJSON();
            const deserialized = deserialize(data);
            const jsonify = safeJsonParse(JSON.stringify(deserialized, safeReplacer));
            return (0, limits_js_1.imposeAttributeLimits)((0, flattenAttributes_js_1.flattenAttributes)(jsonify, undefined));
        case "application/store":
            return data;
        default:
            return {};
    }
}
async function prettyPrintPacket(rawData, dataType) {
    if (rawData === undefined) {
        return "";
    }
    if (dataType === "application/super+json") {
        if (typeof rawData === "string") {
            rawData = safeJsonParse(rawData);
        }
        const { deserialize } = await loadSuperJSON();
        return await prettyPrintPacket(deserialize(rawData), "application/json");
    }
    if (dataType === "application/json") {
        if (typeof rawData === "string") {
            rawData = safeJsonParse(rawData);
        }
        return JSON.stringify(rawData, safeReplacer, 2);
    }
    if (typeof rawData === "string") {
        return rawData;
    }
    return JSON.stringify(rawData, safeReplacer, 2);
}
function safeReplacer(key, value) {
    // If it is a BigInt
    if (typeof value === "bigint") {
        return value.toString(); // Convert to string
    }
    // if it is a Regex
    if (value instanceof RegExp) {
        return value.toString(); // Convert to string
    }
    // if it is a Set
    if (value instanceof Set) {
        return Array.from(value); // Convert to array
    }
    // if it is a Map, convert it to an object
    if (value instanceof Map) {
        const obj = {};
        value.forEach((v, k) => {
            obj[k] = v;
        });
        return obj;
    }
    return value; // Otherwise return the value as is
}
function getPacketExtension(outputType) {
    switch (outputType) {
        case "application/json":
            return "json";
        case "application/super+json":
            return "json";
        case "text/plain":
            return "txt";
        default:
            return "txt";
    }
}
async function loadSuperJSON() {
    const superjson = await import("superjson");
    superjson.registerCustom({
        isApplicable: (v) => v instanceof Buffer,
        serialize: (v) => [...v],
        deserialize: (v) => Buffer.from(v),
    }, "buffer");
    return superjson;
}
function safeJsonParse(value) {
    try {
        return JSON.parse(value);
    }
    catch {
        return;
    }
}
async function replaceSuperJsonPayload(original, newPayload) {
    const superjson = await loadSuperJSON();
    const originalObject = superjson.parse(original);
    const { meta } = superjson.serialize(originalObject);
    const newSuperJson = {
        json: JSON.parse(newPayload),
        meta,
    };
    return superjson.deserialize(newSuperJson);
}
//# sourceMappingURL=ioSerialization.js.map