import { z } from "zod";
import { Prettify } from "../types.js";
import { RuntimeEnvironmentType } from "./api.js";
import { ErrorWithStack } from "./errors.js";
import { JobRunStatusRecord } from "./statuses.js";
export declare const RunStatusSchema: z.ZodUnion<[z.ZodLiteral<"PENDING">, z.ZodLiteral<"QUEUED">, z.ZodLiteral<"WAITING_ON_CONNECTIONS">, z.ZodLiteral<"PREPROCESSING">, z.ZodLiteral<"STARTED">, z.ZodLiteral<"SUCCESS">, z.ZodLiteral<"FAILURE">, z.ZodLiteral<"TIMED_OUT">, z.ZodLiteral<"ABORTED">, z.ZodLiteral<"CANCELED">, z.ZodLiteral<"UNRESOLVED_AUTH">, z.ZodLiteral<"INVALID_PAYLOAD">, z.ZodLiteral<"EXECUTING">, z.ZodLiteral<"WAITING_TO_CONTINUE">, z.ZodLiteral<"WAITING_TO_EXECUTE">]>;
export declare const RunTaskSchema: z.ZodObject<{
    /** The Task id */
    id: z.ZodString;
    /** The key that you defined when creating the Task, the first param in any task. */
    displayKey: z.ZodNullable<z.ZodString>;
    /** The Task status */
    status: z.ZodEnum<["PENDING", "WAITING", "RUNNING", "COMPLETED", "ERRORED", "CANCELED"]>;
    /** The name of the Task */
    name: z.ZodString;
    /** The icon of the Task, a string.
     * For integrations, this will be a lowercase name of the company.
     * Can be used with the [@trigger.dev/companyicons](https://www.npmjs.com/package/@trigger.dev/companyicons) package to display an svg. */
    icon: z.ZodNullable<z.ZodString>;
    /** When the task started */
    startedAt: z.ZodNullable<z.ZodDate>;
    /** When the task completed */
    completedAt: z.ZodNullable<z.ZodDate>;
}, "strip", z.ZodTypeAny, {
    status: "PENDING" | "WAITING" | "RUNNING" | "COMPLETED" | "ERRORED" | "CANCELED";
    name: string;
    id: string;
    icon: string | null;
    startedAt: Date | null;
    completedAt: Date | null;
    displayKey: string | null;
}, {
    status: "PENDING" | "WAITING" | "RUNNING" | "COMPLETED" | "ERRORED" | "CANCELED";
    name: string;
    id: string;
    icon: string | null;
    startedAt: Date | null;
    completedAt: Date | null;
    displayKey: string | null;
}>;
export type RunTaskWithSubtasks = z.infer<typeof RunTaskSchema> & {
    /** The subtasks of the task */
    subtasks?: RunTaskWithSubtasks[];
};
declare const GetRunOptionsSchema: z.ZodObject<{
    /** Return subtasks, which appear in a `subtasks` array on a task. @default false */
    subtasks: z.ZodOptional<z.ZodBoolean>;
    /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */
    cursor: z.ZodOptional<z.ZodString>;
    /** How many tasks you want to return in one go, max 50. @default 20 */
    take: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    subtasks?: boolean | undefined;
    cursor?: string | undefined;
    take?: number | undefined;
}, {
    subtasks?: boolean | undefined;
    cursor?: string | undefined;
    take?: number | undefined;
}>;
export type GetRunOptions = z.infer<typeof GetRunOptionsSchema>;
declare const GetRunOptionsWithTaskDetailsSchema: z.ZodObject<{
    subtasks: z.ZodOptional<z.ZodBoolean>;
    cursor: z.ZodOptional<z.ZodString>;
    take: z.ZodOptional<z.ZodNumber>;
    taskdetails: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    subtasks?: boolean | undefined;
    cursor?: string | undefined;
    take?: number | undefined;
    taskdetails?: boolean | undefined;
}, {
    subtasks?: boolean | undefined;
    cursor?: string | undefined;
    take?: number | undefined;
    taskdetails?: boolean | undefined;
}>;
export type GetRunOptionsWithTaskDetails = z.infer<typeof GetRunOptionsWithTaskDetailsSchema>;
export declare const GetRunSchema: z.ZodObject<{
    status: z.ZodUnion<[z.ZodLiteral<"PENDING">, z.ZodLiteral<"QUEUED">, z.ZodLiteral<"WAITING_ON_CONNECTIONS">, z.ZodLiteral<"PREPROCESSING">, z.ZodLiteral<"STARTED">, z.ZodLiteral<"SUCCESS">, z.ZodLiteral<"FAILURE">, z.ZodLiteral<"TIMED_OUT">, z.ZodLiteral<"ABORTED">, z.ZodLiteral<"CANCELED">, z.ZodLiteral<"UNRESOLVED_AUTH">, z.ZodLiteral<"INVALID_PAYLOAD">, z.ZodLiteral<"EXECUTING">, z.ZodLiteral<"WAITING_TO_CONTINUE">, z.ZodLiteral<"WAITING_TO_EXECUTE">]>;
    id: z.ZodString;
    startedAt: z.ZodNullable<z.ZodDate>;
    completedAt: z.ZodNullable<z.ZodDate>;
    updatedAt: z.ZodNullable<z.ZodDate>;
    output: z.ZodOptional<z.ZodAny>;
    tasks: z.ZodArray<z.ZodType<RunTaskWithSubtasks, z.ZodTypeDef, RunTaskWithSubtasks>, "many">;
    statuses: z.ZodDefault<z.ZodArray<z.ZodObject<{
        data: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodType<import("./json.js").SerializableJson, z.ZodTypeDef, import("./json.js").SerializableJson>>>;
        label: z.ZodString;
        state: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"loading">, z.ZodLiteral<"success">, z.ZodLiteral<"failure">]>>;
        key: z.ZodString;
        history: z.ZodArray<z.ZodObject<{
            label: z.ZodOptional<z.ZodString>;
            state: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"loading">, z.ZodLiteral<"success">, z.ZodLiteral<"failure">]>>;
            data: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodType<import("./json.js").SerializableJson, z.ZodTypeDef, import("./json.js").SerializableJson>>>;
        }, "strip", z.ZodTypeAny, {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }, {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        label: string;
        key: string;
        history: {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }[];
        data?: Record<string, import("./json.js").SerializableJson> | undefined;
        state?: "loading" | "success" | "failure" | undefined;
    }, {
        label: string;
        key: string;
        history: {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }[];
        data?: Record<string, import("./json.js").SerializableJson> | undefined;
        state?: "loading" | "success" | "failure" | undefined;
    }>, "many">>;
    nextCursor: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
    id: string;
    startedAt: Date | null;
    completedAt: Date | null;
    updatedAt: Date | null;
    tasks: RunTaskWithSubtasks[];
    statuses: {
        label: string;
        key: string;
        history: {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }[];
        data?: Record<string, import("./json.js").SerializableJson> | undefined;
        state?: "loading" | "success" | "failure" | undefined;
    }[];
    output?: any;
    nextCursor?: string | undefined;
}, {
    status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
    id: string;
    startedAt: Date | null;
    completedAt: Date | null;
    updatedAt: Date | null;
    tasks: RunTaskWithSubtasks[];
    output?: any;
    statuses?: {
        label: string;
        key: string;
        history: {
            label?: string | undefined;
            state?: "loading" | "success" | "failure" | undefined;
            data?: Record<string, import("./json.js").SerializableJson> | undefined;
        }[];
        data?: Record<string, import("./json.js").SerializableJson> | undefined;
        state?: "loading" | "success" | "failure" | undefined;
    }[] | undefined;
    nextCursor?: string | undefined;
}>;
export type GetRun = Prettify<z.infer<typeof GetRunSchema>>;
declare const GetRunsOptionsSchema: z.ZodObject<{
    /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */
    cursor: z.ZodOptional<z.ZodString>;
    /** How many runs you want to return in one go, max 50. @default 20 */
    take: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    cursor?: string | undefined;
    take?: number | undefined;
}, {
    cursor?: string | undefined;
    take?: number | undefined;
}>;
export type GetRunsOptions = z.infer<typeof GetRunsOptionsSchema>;
export declare const GetRunsSchema: z.ZodObject<{
    /** The runs from the query */
    runs: z.ZodArray<z.ZodObject<{
        /** The Run id */
        id: z.ZodString;
        /** The Run status */
        status: z.ZodUnion<[z.ZodLiteral<"PENDING">, z.ZodLiteral<"QUEUED">, z.ZodLiteral<"WAITING_ON_CONNECTIONS">, z.ZodLiteral<"PREPROCESSING">, z.ZodLiteral<"STARTED">, z.ZodLiteral<"SUCCESS">, z.ZodLiteral<"FAILURE">, z.ZodLiteral<"TIMED_OUT">, z.ZodLiteral<"ABORTED">, z.ZodLiteral<"CANCELED">, z.ZodLiteral<"UNRESOLVED_AUTH">, z.ZodLiteral<"INVALID_PAYLOAD">, z.ZodLiteral<"EXECUTING">, z.ZodLiteral<"WAITING_TO_CONTINUE">, z.ZodLiteral<"WAITING_TO_EXECUTE">]>;
        /** When the run started */
        startedAt: z.ZodNullable<z.ZodDate>;
        /** When the run was last updated */
        updatedAt: z.ZodNullable<z.ZodDate>;
        /** When the run was completed */
        completedAt: z.ZodNullable<z.ZodDate>;
    }, "strip", z.ZodTypeAny, {
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
    }, {
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
    }>, "many">;
    /** If there are more runs, you can use this to get them */
    nextCursor: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    runs: {
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
    }[];
    nextCursor?: string | undefined;
}, {
    runs: {
        status: "PENDING" | "CANCELED" | "QUEUED" | "WAITING_ON_CONNECTIONS" | "PREPROCESSING" | "STARTED" | "SUCCESS" | "FAILURE" | "TIMED_OUT" | "ABORTED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD" | "EXECUTING" | "WAITING_TO_CONTINUE" | "WAITING_TO_EXECUTE";
        id: string;
        startedAt: Date | null;
        completedAt: Date | null;
        updatedAt: Date | null;
    }[];
    nextCursor?: string | undefined;
}>;
export type RunNotificationJobMetadata = {
    id: string;
    version: string;
};
export type RunNotificationEnvMetadata = {
    slug: string;
    id: string;
    type: RuntimeEnvironmentType;
};
export type RunNotificationOrgMetadata = {
    slug: string;
    id: string;
    title: string;
};
export type RunNotificationProjectMetadata = {
    slug: string;
    id: string;
    name: string;
};
export type RunNotificationAccountMetadata = {
    id: string;
    metadata?: any;
};
export type RunNotificationInvocationMetadata<T = any> = {
    id: string;
    context: any;
    timestamp: Date;
    payload: T;
};
export type RunNotificationRunMetadata = {
    /** The Run id */
    id: string;
    /** The Run status */
    statuses: JobRunStatusRecord[];
    /** When the run started */
    startedAt: Date;
    /** When the run was last updated */
    updatedAt: Date;
    /** When the run was completed */
    completedAt: Date;
    /** If the run was a test or not */
    isTest: boolean;
    executionDurationInMs: number;
    executionCount: number;
};
type RunNotificationCommon<TPayload = any> = {
    /** The Run id */
    id: string;
    /** The Run status */
    statuses: JobRunStatusRecord[];
    /** When the run started */
    startedAt: Date;
    /** When the run was last updated */
    updatedAt: Date;
    /** When the run was completed */
    completedAt: Date;
    /** If the run was a test or not */
    isTest: boolean;
    executionDurationInMs: number;
    executionCount: number;
    /** Job metadata */
    job: RunNotificationJobMetadata;
    /** Environment metadata */
    environment: RunNotificationEnvMetadata;
    /** Organization metadata */
    organization: RunNotificationOrgMetadata;
    /** Project metadata */
    project: RunNotificationProjectMetadata;
    /** Account metadata */
    account?: RunNotificationAccountMetadata;
    /** Invocation metadata */
    invocation: RunNotificationInvocationMetadata<TPayload>;
};
export type SuccessfulRunNotification<TOutput, TPayload = any> = RunNotificationCommon<TPayload> & {
    ok: true;
    /** The Run status */
    status: "SUCCESS";
    /** The output of the run */
    output: TOutput;
};
export type FailedRunNotification<TPayload = any> = RunNotificationCommon<TPayload> & {
    ok: false;
    /** The Run status */
    status: "FAILURE" | "TIMED_OUT" | "ABORTED" | "CANCELED" | "UNRESOLVED_AUTH" | "INVALID_PAYLOAD";
    /** The error of the run */
    error: any;
    /** The task that failed */
    task?: {
        id: string;
        cacheKey: string | null;
        status: string;
        name: string;
        icon: string | null;
        startedAt: string;
        error: ErrorWithStack;
        params: any | null;
    };
};
export type RunNotification<TOutput, TPayload = any> = SuccessfulRunNotification<TOutput, TPayload> | FailedRunNotification<TPayload>;
export {};
