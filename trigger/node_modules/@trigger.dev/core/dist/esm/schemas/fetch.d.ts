import { z } from "zod";
import { Prettify } from "../types.js";
export declare const FetchRetryHeadersStrategySchema: z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    resetFormat: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant";
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>;
export type FetchRetryHeadersStrategy = z.infer<typeof FetchRetryHeadersStrategySchema>;
/** The `backoff` strategy retries the request with an exponential backoff. */
export declare const FetchRetryBackoffStrategySchema: z.ZodObject<{
    limit: z.ZodOptional<z.ZodNumber>;
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}>;
/** The `backoff` strategy retries the request with an exponential backoff. */
export type FetchRetryBackoffStrategy = z.infer<typeof FetchRetryBackoffStrategySchema>;
export declare const FetchRetryStrategySchema: z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    resetFormat: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant";
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>, z.ZodObject<{
    limit: z.ZodOptional<z.ZodNumber>;
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}>]>;
export type FetchRetryStrategy = z.infer<typeof FetchRetryStrategySchema>;
/** The options for a fetch request */
export declare const FetchRequestInitSchema: z.ZodObject<{
    /** The HTTP method to use for the request. */
    method: z.ZodOptional<z.ZodString>;
    /** Any headers to send with the request. Note that you can use [redactString](https://trigger.dev/docs/sdk/redactString) to prevent sensitive information from being stored (e.g. in the logs), like API keys and tokens. */
    headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodObject<{
        __redactedString: z.ZodLiteral<true>;
        strings: z.ZodArray<z.ZodString, "many">;
        interpolations: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        __redactedString: true;
        strings: string[];
        interpolations: string[];
    }, {
        __redactedString: true;
        strings: string[];
        interpolations: string[];
    }>]>>>;
    /** The body of the request. */
    body: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodType<ArrayBuffer, z.ZodTypeDef, ArrayBuffer>]>>;
}, "strip", z.ZodTypeAny, {
    method?: string | undefined;
    headers?: Record<string, string | {
        __redactedString: true;
        strings: string[];
        interpolations: string[];
    }> | undefined;
    body?: string | ArrayBuffer | undefined;
}, {
    method?: string | undefined;
    headers?: Record<string, string | {
        __redactedString: true;
        strings: string[];
        interpolations: string[];
    }> | undefined;
    body?: string | ArrayBuffer | undefined;
}>;
/** The options for a fetch request */
export type FetchRequestInit = z.infer<typeof FetchRequestInitSchema>;
export declare const FetchRetryOptionsSchema: z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    resetFormat: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant";
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>, z.ZodObject<{
    limit: z.ZodOptional<z.ZodNumber>;
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}, {
    strategy: "backoff";
    limit?: number | undefined;
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
}>]>>;
/** An object where the key is a status code pattern and the value is a retrying strategy. Supported patterns are:
  - Specific status codes: 429
  - Ranges: 500-599
  - Wildcards: 2xx, 3xx, 4xx, 5xx
  */
export type FetchRetryOptions = z.infer<typeof FetchRetryOptionsSchema>;
export declare const FetchTimeoutOptionsSchema: z.ZodObject<{
    durationInMs: z.ZodNumber;
    retry: z.ZodOptional<z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }, {
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    durationInMs: number;
    retry?: {
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}, {
    durationInMs: number;
    retry?: {
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}>;
export type FetchTimeoutOptions = z.infer<typeof FetchTimeoutOptionsSchema>;
export declare const FetchOperationSchema: z.ZodObject<{
    url: z.ZodString;
    requestInit: z.ZodOptional<z.ZodObject<{
        /** The HTTP method to use for the request. */
        method: z.ZodOptional<z.ZodString>;
        /** Any headers to send with the request. Note that you can use [redactString](https://trigger.dev/docs/sdk/redactString) to prevent sensitive information from being stored (e.g. in the logs), like API keys and tokens. */
        headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodObject<{
            __redactedString: z.ZodLiteral<true>;
            strings: z.ZodArray<z.ZodString, "many">;
            interpolations: z.ZodArray<z.ZodString, "many">;
        }, "strip", z.ZodTypeAny, {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }, {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }>]>>>;
        /** The body of the request. */
        body: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodType<ArrayBuffer, z.ZodTypeDef, ArrayBuffer>]>>;
    }, "strip", z.ZodTypeAny, {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    }, {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    }>>;
    retry: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
        /** The `headers` strategy retries the request using info from the response headers. */
        strategy: z.ZodLiteral<"headers">;
        /** The header to use to determine the maximum number of times to retry the request. */
        limitHeader: z.ZodString;
        /** The header to use to determine the number of remaining retries. */
        remainingHeader: z.ZodString;
        /** The header to use to determine the time when the number of remaining retries will be reset. */
        resetHeader: z.ZodString;
        /** The event filter to use to determine if the request should be retried. */
        bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
        /** The format of the `resetHeader` value. */
        resetFormat: z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>;
    }, "strip", z.ZodTypeAny, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        resetFormat: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant";
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    }, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    }>, z.ZodObject<{
        limit: z.ZodOptional<z.ZodNumber>;
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
        strategy: z.ZodLiteral<"backoff">;
        bodyFilter: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
    }, "strip", z.ZodTypeAny, {
        strategy: "backoff";
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    }, {
        strategy: "backoff";
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    }>]>>>;
    timeout: z.ZodOptional<z.ZodObject<{
        durationInMs: z.ZodNumber;
        retry: z.ZodOptional<z.ZodObject<{
            limit: z.ZodOptional<z.ZodNumber>;
            factor: z.ZodOptional<z.ZodNumber>;
            minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
            maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
            randomize: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        }, {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    }, {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    url: string;
    requestInit?: {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    } | undefined;
    retry?: Record<string, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        resetFormat: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant";
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    } | {
        strategy: "backoff";
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    }> | undefined;
    timeout?: {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    } | undefined;
}, {
    url: string;
    requestInit?: {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    } | undefined;
    retry?: Record<string, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    } | {
        strategy: "backoff";
        limit?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        bodyFilter?: import("./eventFilter.js").EventFilter | undefined;
    }> | undefined;
    timeout?: {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    } | undefined;
}>;
export type FetchOperation = z.infer<typeof FetchOperationSchema>;
export declare const FetchPollOperationSchema: z.ZodObject<{
    url: z.ZodString;
    interval: z.ZodDefault<z.ZodNumber>;
    timeout: z.ZodDefault<z.ZodNumber>;
    responseFilter: z.ZodObject<{
        headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
            $endsWith: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            $endsWith: string;
        }, {
            $endsWith: string;
        }>, z.ZodObject<{
            $startsWith: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            $startsWith: string;
        }, {
            $startsWith: string;
        }>, z.ZodObject<{
            $ignoreCaseEquals: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            $ignoreCaseEquals: string;
        }, {
            $ignoreCaseEquals: string;
        }>]>, "many">]>>>;
        body: z.ZodOptional<z.ZodType<import("./eventFilter.js").EventFilter, z.ZodTypeDef, import("./eventFilter.js").EventFilter>>;
        status: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
    }, "strip", z.ZodTypeAny, {
        headers?: Record<string, string[] | ({
            $endsWith: string;
        } | {
            $startsWith: string;
        } | {
            $ignoreCaseEquals: string;
        })[]> | undefined;
        body?: import("./eventFilter.js").EventFilter | undefined;
        status?: number[] | undefined;
    }, {
        headers?: Record<string, string[] | ({
            $endsWith: string;
        } | {
            $startsWith: string;
        } | {
            $ignoreCaseEquals: string;
        })[]> | undefined;
        body?: import("./eventFilter.js").EventFilter | undefined;
        status?: number[] | undefined;
    }>;
    requestInit: z.ZodOptional<z.ZodObject<{
        /** The HTTP method to use for the request. */
        method: z.ZodOptional<z.ZodString>;
        /** Any headers to send with the request. Note that you can use [redactString](https://trigger.dev/docs/sdk/redactString) to prevent sensitive information from being stored (e.g. in the logs), like API keys and tokens. */
        headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodObject<{
            __redactedString: z.ZodLiteral<true>;
            strings: z.ZodArray<z.ZodString, "many">;
            interpolations: z.ZodArray<z.ZodString, "many">;
        }, "strip", z.ZodTypeAny, {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }, {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }>]>>>;
        /** The body of the request. */
        body: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodType<ArrayBuffer, z.ZodTypeDef, ArrayBuffer>]>>;
    }, "strip", z.ZodTypeAny, {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    }, {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    }>>;
    requestTimeout: z.ZodOptional<z.ZodObject<{
        durationInMs: z.ZodNumber;
        retry: z.ZodOptional<z.ZodObject<{
            limit: z.ZodOptional<z.ZodNumber>;
            factor: z.ZodOptional<z.ZodNumber>;
            minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
            maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
            randomize: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        }, {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    }, {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    url: string;
    interval: number;
    timeout: number;
    responseFilter: {
        headers?: Record<string, string[] | ({
            $endsWith: string;
        } | {
            $startsWith: string;
        } | {
            $ignoreCaseEquals: string;
        })[]> | undefined;
        body?: import("./eventFilter.js").EventFilter | undefined;
        status?: number[] | undefined;
    };
    requestInit?: {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    } | undefined;
    requestTimeout?: {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    } | undefined;
}, {
    url: string;
    responseFilter: {
        headers?: Record<string, string[] | ({
            $endsWith: string;
        } | {
            $startsWith: string;
        } | {
            $ignoreCaseEquals: string;
        })[]> | undefined;
        body?: import("./eventFilter.js").EventFilter | undefined;
        status?: number[] | undefined;
    };
    interval?: number | undefined;
    timeout?: number | undefined;
    requestInit?: {
        method?: string | undefined;
        headers?: Record<string, string | {
            __redactedString: true;
            strings: string[];
            interpolations: string[];
        }> | undefined;
        body?: string | ArrayBuffer | undefined;
    } | undefined;
    requestTimeout?: {
        durationInMs: number;
        retry?: {
            limit?: number | undefined;
            factor?: number | undefined;
            minTimeoutInMs?: number | undefined;
            maxTimeoutInMs?: number | undefined;
            randomize?: boolean | undefined;
        } | undefined;
    } | undefined;
}>;
export type FetchPollOperation = Prettify<z.infer<typeof FetchPollOperationSchema>>;
