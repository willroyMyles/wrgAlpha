import { eventFilterMatches } from "./eventFilterMatches.js";
export async function requestFilterMatches(request, filter) {
    const clonedRequest = request.clone();
    if (!requestMethodMatches(clonedRequest.method, filter.method)) {
        return false;
    }
    const headersObj = Object.fromEntries(clonedRequest.headers.entries());
    if (filter.headers && !eventFilterMatches(headersObj, filter.headers)) {
        return false;
    }
    const searchParams = new URL(clonedRequest.url).searchParams;
    const searchParamsObject = {};
    for (const [key, value] of searchParams.entries()) {
        searchParamsObject[key] = value;
    }
    if (filter.query && !eventFilterMatches(searchParamsObject, filter.query)) {
        return false;
    }
    try {
        const json = await clonedRequest.json();
        if (filter.body && !eventFilterMatches(json, filter.body)) {
            return false;
        }
    }
    catch (e) {
        if (filter.body) {
            return false;
        }
    }
    return true;
}
export async function responseFilterMatches(response, filter) {
    if (filter.headers && !eventFilterMatches(response.headers, filter.headers)) {
        return { match: false };
    }
    try {
        const json = await response.json();
        if (filter.body && !eventFilterMatches(json, filter.body)) {
            return { match: false, body: json };
        }
        else {
            return { match: true, body: json };
        }
    }
    catch (e) {
        if (filter.body) {
            return { match: false, body: undefined };
        }
    }
    return { match: true, body: undefined };
}
function requestMethodMatches(method, filter) {
    if (!filter) {
        return true;
    }
    return filter.includes(method);
}
//# sourceMappingURL=requestFilterMatches.js.map