import { z } from "zod";
import { AddTagsRequestBody, BatchTaskRunExecutionResult, BatchTriggerTaskRequestBody, CreateEnvironmentVariableRequestBody, CreateScheduleOptions, ListRunResponseItem, ListScheduleOptions, RescheduleRunRequestBody, TaskRunExecutionResult, TriggerTaskRequestBody, UpdateEnvironmentVariableRequestBody, UpdateScheduleOptions } from "../schemas/index.js";
import { ApiRequestOptions, CursorPagePromise, ZodFetchOptions, isRequestOptions } from "./core.js";
import { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, ListProjectRunsQueryParams, ListRunsQueryParams, UpdateEnvironmentVariableParams } from "./types.js";
export type { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, UpdateEnvironmentVariableParams, };
export type TriggerOptions = {
    spanParentAsLink?: boolean;
};
export { isRequestOptions };
export type { ApiRequestOptions };
/**
 * Trigger.dev v3 API client
 */
export declare class ApiClient {
    #private;
    private readonly accessToken;
    private readonly baseUrl;
    private readonly defaultRequestOptions;
    constructor(baseUrl: string, accessToken: string, requestOptions?: ApiRequestOptions);
    getRunResult(runId: string, requestOptions?: ZodFetchOptions): Promise<TaskRunExecutionResult | undefined>;
    getBatchResults(batchId: string, requestOptions?: ZodFetchOptions): Promise<BatchTaskRunExecutionResult | undefined>;
    triggerTask(taskId: string, body: TriggerTaskRequestBody, options?: TriggerOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    batchTriggerTask(taskId: string, body: BatchTriggerTaskRequestBody, options?: TriggerOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        runs: string[];
        batchId: string;
    }>;
    createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        presignedUrl: string;
    }>;
    getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        presignedUrl: string;
    }>;
    retrieveRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
        id: string;
        attempts: ({
            status: "PENDING" | "COMPLETED" | "CANCELED" | "EXECUTING" | "FAILED" | "PAUSED";
            id: string;
            updatedAt: Date;
            createdAt: Date;
            startedAt?: Date | undefined;
            completedAt?: Date | undefined;
            error?: {
                message: string;
                name?: string | undefined;
                stackTrace?: string | undefined;
            } | undefined;
        } | undefined)[];
        updatedAt: Date;
        isTest: boolean;
        createdAt: Date;
        tags: string[];
        durationMs: number;
        costInCents: number;
        baseCostInCents: number;
        depth: number;
        triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
        taskIdentifier: string;
        isQueued: boolean;
        isExecuting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        relatedRuns: {
            root?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        payload?: any;
        payloadPresignedUrl?: string | undefined;
        output?: any;
        outputPresignedUrl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        batchId?: string | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        startedAt?: Date | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        ttl?: string | undefined;
        expiredAt?: Date | undefined;
    }>;
    listRuns(query?: ListRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    listProjectRuns(projectRef: string, query?: ListProjectRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    replayRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    cancelRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
        id: string;
        attempts: ({
            status: "PENDING" | "COMPLETED" | "CANCELED" | "EXECUTING" | "FAILED" | "PAUSED";
            id: string;
            updatedAt: Date;
            createdAt: Date;
            startedAt?: Date | undefined;
            completedAt?: Date | undefined;
            error?: {
                message: string;
                name?: string | undefined;
                stackTrace?: string | undefined;
            } | undefined;
        } | undefined)[];
        updatedAt: Date;
        isTest: boolean;
        createdAt: Date;
        tags: string[];
        durationMs: number;
        costInCents: number;
        baseCostInCents: number;
        depth: number;
        triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
        taskIdentifier: string;
        isQueued: boolean;
        isExecuting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        relatedRuns: {
            root?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "EXECUTING" | "FAILED" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                depth: number;
                triggerFunction: "trigger" | "triggerAndWait" | "batchTriggerAndWait" | "batchTrigger";
                taskIdentifier: string;
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                batchId?: string | undefined;
                idempotencyKey?: string | undefined;
                version?: string | undefined;
                startedAt?: Date | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                ttl?: string | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        payload?: any;
        payloadPresignedUrl?: string | undefined;
        output?: any;
        outputPresignedUrl?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        batchId?: string | undefined;
        idempotencyKey?: string | undefined;
        version?: string | undefined;
        startedAt?: Date | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        ttl?: string | undefined;
        expiredAt?: Date | undefined;
    }>;
    addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        message: string;
    }>;
    createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodUnion<[z.ZodLiteral<"DECLARATIVE">, z.ZodLiteral<"IMPERATIVE">]>;
        task: z.ZodString;
        active: z.ZodBoolean;
        deduplicationKey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        externalId: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        generator: z.ZodObject<{
            type: z.ZodLiteral<"CRON">;
            expression: z.ZodString;
            description: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "CRON";
            description: string;
            expression: string;
        }, {
            type: "CRON";
            description: string;
            expression: string;
        }>;
        timezone: z.ZodString;
        nextRun: z.ZodOptional<z.ZodNullable<z.ZodDate>>;
        environments: z.ZodArray<z.ZodObject<{
            id: z.ZodString;
            type: z.ZodString;
            userName: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>>;
    retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    updateSchedule(scheduleId: string, options: UpdateScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        deduplicationKey?: string | null | undefined;
        externalId?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        value: string;
        name: string;
    }[]>;
    importEnvVars(projectRef: string, slug: string, body: ImportEnvironmentVariablesParams, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        value: string;
    }>;
    createEnvVar(projectRef: string, slug: string, body: CreateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    updateEnvVar(projectRef: string, slug: string, key: string, body: UpdateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
}
export declare function mergeRequestOptions(defaultOptions: ZodFetchOptions, options?: ApiRequestOptions): ZodFetchOptions;
