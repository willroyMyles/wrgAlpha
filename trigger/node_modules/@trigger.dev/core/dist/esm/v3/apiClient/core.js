import { z } from "zod";
import { fromZodError, ValidationError } from "zod-validation-error";
import { calculateNextRetryDelay } from "../utils/retries.js";
import { ApiConnectionError, ApiError, ApiSchemaValidationError } from "./errors.js";
import { SemanticInternalAttributes } from "../semanticInternalAttributes.js";
import { accessoryAttributes } from "../utils/styleAttributes.js";
import { CursorPage, OffsetLimitPage, } from "./pagination.js";
export const defaultRetryOptions = {
    maxAttempts: 3,
    factor: 2,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 60000,
    randomize: false,
};
// This is required so that we can determine if a given object matches the ApiRequestOptions
// type at runtime. While this requires duplication, it is enforced by the TypeScript
// compiler such that any missing / extraneous keys will cause an error.
const requestOptionsKeys = {
    retry: true,
};
export const isRequestOptions = (obj) => {
    return (typeof obj === "object" &&
        obj !== null &&
        !isEmptyObj(obj) &&
        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));
};
export function zodfetch(schema, url, requestInit, options) {
    return new ApiPromise(_doZodFetch(schema, url, requestInit, options));
}
export function zodfetchCursorPage(schema, url, params, requestInit, options) {
    const query = new URLSearchParams(params.query);
    if (params.limit) {
        query.set("page[size]", String(params.limit));
    }
    if (params.after) {
        query.set("page[after]", params.after);
    }
    if (params.before) {
        query.set("page[before]", params.before);
    }
    const cursorPageSchema = z.object({
        data: z.array(schema),
        pagination: z.object({
            next: z.string().optional(),
            previous: z.string().optional(),
        }),
    });
    const $url = new URL(url);
    $url.search = query.toString();
    const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);
    return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);
}
export function zodfetchOffsetLimitPage(schema, url, params, requestInit, options) {
    const query = new URLSearchParams(params.query);
    if (params.limit) {
        query.set("perPage", String(params.limit));
    }
    if (params.page) {
        query.set("page", String(params.page));
    }
    const offsetLimitPageSchema = z.object({
        data: z.array(schema),
        pagination: z.object({
            currentPage: z.coerce.number(),
            totalPages: z.coerce.number(),
            count: z.coerce.number(),
        }),
    });
    const $url = new URL(url);
    $url.search = query.toString();
    const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);
    return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);
}
async function traceZodFetch(params, callback) {
    if (!params.options?.tracer) {
        return callback();
    }
    const url = new URL(params.url);
    const method = params.requestInit?.method ?? "GET";
    const name = params.options.name ?? `${method} ${url.pathname}`;
    return await params.options.tracer.startActiveSpan(name, async (span) => {
        return await callback(span);
    }, {
        attributes: {
            [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? "api",
            ...params.options.attributes,
        },
    });
}
async function _doZodFetch(schema, url, requestInit, options) {
    const $requestInit = await requestInit;
    return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {
        const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);
        if (options?.onResponseBody && span) {
            options.onResponseBody(result.data, span);
        }
        return result;
    });
}
async function _doZodFetchWithRetries(schema, url, requestInit, options, attempt = 1) {
    try {
        const response = await fetch(url, requestInitWithCache(requestInit));
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
            const retryResult = shouldRetry(response, attempt, options?.retry);
            if (retryResult.retry) {
                await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);
                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
            }
            else {
                const errText = await response.text().catch((e) => castToError(e).message);
                const errJSON = safeJsonParse(errText);
                const errMessage = errJSON ? undefined : errText;
                throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);
            }
        }
        const jsonBody = await response.json();
        const parsedResult = schema.safeParse(jsonBody);
        if (parsedResult.success) {
            return { data: parsedResult.data, response };
        }
        const validationError = fromZodError(parsedResult.error);
        throw new ApiSchemaValidationError({
            status: response.status,
            cause: validationError,
            message: validationError.message,
            rawBody: jsonBody,
            headers: responseHeaders,
        });
    }
    catch (error) {
        if (error instanceof ApiError) {
            throw error;
        }
        if (error instanceof ValidationError) {
        }
        if (options?.retry) {
            const retry = { ...defaultRetryOptions, ...options.retry };
            const delay = calculateNextRetryDelay(retry, attempt);
            if (delay) {
                await waitForRetry(url, attempt + 1, delay, options, requestInit);
                return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);
            }
        }
        throw new ApiConnectionError({ cause: castToError(error) });
    }
}
function castToError(err) {
    if (err instanceof Error)
        return err;
    return new Error(err);
}
function shouldRetry(response, attempt, retryOptions) {
    function shouldRetryForOptions() {
        const retry = { ...defaultRetryOptions, ...retryOptions };
        const delay = calculateNextRetryDelay(retry, attempt);
        if (delay) {
            return { retry: true, delay };
        }
        else {
            return { retry: false };
        }
    }
    // Note this is not a standard header.
    const shouldRetryHeader = response.headers.get("x-should-retry");
    // If the server explicitly says whether or not to retry, obey.
    if (shouldRetryHeader === "true")
        return shouldRetryForOptions();
    if (shouldRetryHeader === "false")
        return { retry: false };
    // Retry on request timeouts.
    if (response.status === 408)
        return shouldRetryForOptions();
    // Retry on lock timeouts.
    if (response.status === 409)
        return shouldRetryForOptions();
    // Retry on rate limits.
    if (response.status === 429) {
        if (attempt >= (typeof retryOptions?.maxAttempts === "number" ? retryOptions?.maxAttempts : 3)) {
            return { retry: false };
        }
        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.
        const resetAtUnixEpochMs = response.headers.get("x-ratelimit-reset");
        if (resetAtUnixEpochMs) {
            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
            const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);
            if (delay > 0) {
                return { retry: true, delay };
            }
        }
        return shouldRetryForOptions();
    }
    // Retry internal errors.
    if (response.status >= 500)
        return shouldRetryForOptions();
    return { retry: false };
}
function safeJsonParse(text) {
    try {
        return JSON.parse(text);
    }
    catch (e) {
        return undefined;
    }
}
function createResponseHeaders(headers) {
    return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()), {
        get(target, name) {
            const key = name.toString();
            return target[key.toLowerCase()] || target[key];
        },
    });
}
function requestInitWithCache(requestInit) {
    try {
        const withCache = {
            ...requestInit,
            cache: "no-cache",
        };
        const _ = new Request("http://localhost", withCache);
        return withCache;
    }
    catch (error) {
        return requestInit ?? {};
    }
}
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
export class ApiPromise extends Promise {
    responsePromise;
    constructor(responsePromise) {
        super((resolve) => {
            // this is maybe a bit weird but this has to be a no-op to not implicitly
            // parse the response body; instead .then, .catch, .finally are overridden
            // to parse the response
            resolve(null);
        });
        this.responsePromise = responsePromise;
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     */
    asResponse() {
        return this.responsePromise.then((p) => p.response);
    }
    /**
     * Gets the parsed response data and the raw `Response` instance.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     */
    async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response };
    }
    parse() {
        return this.responsePromise.then((result) => result.data);
    }
    then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.parse().catch(onrejected);
    }
    finally(onfinally) {
        return this.parse().finally(onfinally);
    }
}
export class CursorPagePromise extends ApiPromise {
    schema;
    url;
    params;
    requestInit;
    options;
    constructor(result, schema, url, params, requestInit, options) {
        super(result.then((result) => ({
            data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),
            response: result.response,
        })));
        this.schema = schema;
        this.url = url;
        this.params = params;
        this.requestInit = requestInit;
        this.options = options;
    }
    #fetchPage(params) {
        return zodfetchCursorPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
            yield item;
        }
    }
}
export class OffsetLimitPagePromise extends ApiPromise {
    schema;
    url;
    params;
    requestInit;
    options;
    constructor(result, schema, url, params, requestInit, options) {
        super(result.then((result) => ({
            data: new OffsetLimitPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),
            response: result.response,
        })));
        this.schema = schema;
        this.url = url;
        this.params = params;
        this.requestInit = requestInit;
        this.options = options;
    }
    #fetchPage(params) {
        return zodfetchOffsetLimitPage(this.schema, this.url, { ...this.params, ...params }, this.requestInit, this.options);
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */
    async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
            yield item;
        }
    }
}
async function waitForRetry(url, attempt, delay, options, requestInit, response) {
    if (options?.tracer) {
        const method = requestInit?.method ?? "GET";
        return options.tracer.startActiveSpan(response ? `wait after ${response.status}` : `wait after error`, async (span) => {
            await new Promise((resolve) => setTimeout(resolve, delay));
        }, {
            attributes: {
                [SemanticInternalAttributes.STYLE_ICON]: "wait",
                ...accessoryAttributes({
                    items: [
                        {
                            text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,
                            variant: "normal",
                        },
                    ],
                    style: "codepath",
                }),
            },
        });
    }
    await new Promise((resolve) => setTimeout(resolve, delay));
}
// https://stackoverflow.com/a/34491287
export function isEmptyObj(obj) {
    if (!obj)
        return true;
    for (const _k in obj)
        return false;
    return true;
}
// https://eslint.org/docs/latest/rules/no-prototype-builtins
export function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
//# sourceMappingURL=core.js.map