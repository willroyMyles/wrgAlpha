export class ApiError extends Error {
    status;
    headers;
    error;
    code;
    param;
    type;
    constructor(status, error, message, headers) {
        super(`${ApiError.makeMessage(status, error, message)}`);
        this.name = "TriggerApiError";
        this.status = status;
        this.headers = headers;
        const data = error;
        this.error = data;
        this.code = data?.["code"];
        this.param = data?.["param"];
        this.type = data?.["type"];
    }
    static makeMessage(status, error, message) {
        const msg = error?.message
            ? typeof error.message === "string"
                ? error.message
                : JSON.stringify(error.message)
            : error
                ? JSON.stringify(error)
                : message;
        if (status && msg) {
            return `${status} ${msg}`;
        }
        if (status) {
            return `${status} status code (no body)`;
        }
        if (msg) {
            return msg;
        }
        return "(no status code or body)";
    }
    static generate(status, errorResponse, message, headers) {
        if (!status) {
            return new ApiConnectionError({ cause: castToError(errorResponse) });
        }
        const error = errorResponse?.["error"];
        if (status === 400) {
            return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
            return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
            return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
            return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
            return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
            return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
            return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
            return new InternalServerError(status, error, message, headers);
        }
        return new ApiError(status, error, message, headers);
    }
}
export class ApiConnectionError extends ApiError {
    status = undefined;
    constructor({ message, cause }) {
        super(undefined, undefined, message || "Connection error.", undefined);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause)
            this.cause = cause;
    }
}
export class BadRequestError extends ApiError {
    status = 400;
}
export class AuthenticationError extends ApiError {
    status = 401;
}
export class PermissionDeniedError extends ApiError {
    status = 403;
}
export class NotFoundError extends ApiError {
    status = 404;
}
export class ConflictError extends ApiError {
    status = 409;
}
export class UnprocessableEntityError extends ApiError {
    status = 422;
}
export class RateLimitError extends ApiError {
    status = 429;
    get millisecondsUntilReset() {
        // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.
        const resetAtUnixEpochMs = (this.headers ?? {})["x-ratelimit-reset"];
        if (typeof resetAtUnixEpochMs === "string") {
            const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);
            if (isNaN(resetAtUnixEpoch)) {
                return;
            }
            // Add between 0 and 2000ms to the reset time to add jitter
            return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);
        }
        return;
    }
}
export class InternalServerError extends ApiError {
}
export class ApiSchemaValidationError extends ApiError {
    status = 200;
    rawBody;
    constructor({ message, cause, status, rawBody, headers, }) {
        super(status, undefined, message || "Validation error.", headers);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause)
            this.cause = cause;
        this.rawBody = rawBody;
    }
}
function castToError(err) {
    if (err instanceof Error)
        return err;
    return new Error(err);
}
//# sourceMappingURL=errors.js.map