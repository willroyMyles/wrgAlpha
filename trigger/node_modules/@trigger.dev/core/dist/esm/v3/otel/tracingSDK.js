import { DiagConsoleLogger, DiagLogLevel, diag } from "@opentelemetry/api";
import { logs } from "@opentelemetry/api-logs";
import { OTLPLogExporter } from "@opentelemetry/exporter-logs-otlp-http";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { registerInstrumentations } from "@opentelemetry/instrumentation";
import { Resource, detectResourcesSync, processDetectorSync, } from "@opentelemetry/resources";
import { BatchLogRecordProcessor, LoggerProvider, SimpleLogRecordProcessor, } from "@opentelemetry/sdk-logs";
import { BatchSpanProcessor, NodeTracerProvider, SimpleSpanProcessor, } from "@opentelemetry/sdk-trace-node";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { VERSION } from "../../version.js";
import { OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT, OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT, OTEL_LINK_COUNT_LIMIT, OTEL_LOG_ATTRIBUTE_COUNT_LIMIT, OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT, OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT, OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT, OTEL_SPAN_EVENT_COUNT_LIMIT, } from "../limits.js";
import { SemanticInternalAttributes } from "../semanticInternalAttributes.js";
import { TaskContextLogProcessor, TaskContextSpanProcessor, } from "../taskContext/otelProcessors.js";
import { getEnvVar } from "../utils/getEnv.js";
class AsyncResourceDetector {
    _promise;
    _resolver;
    _resolved = false;
    constructor() {
        this._promise = new Promise((resolver) => {
            this._resolver = resolver;
        });
    }
    detect(_config) {
        return new Resource({}, this._promise);
    }
    resolveWithAttributes(attributes) {
        if (!this._resolver) {
            throw new Error("Resolver not available");
        }
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        this._resolver(attributes);
    }
}
export class TracingSDK {
    config;
    asyncResourceDetector = new AsyncResourceDetector();
    _logProvider;
    _spanExporter;
    _traceProvider;
    getLogger;
    getTracer;
    constructor(config) {
        this.config = config;
        setLogLevel(config.diagLogLevel ?? "none");
        const envResourceAttributesSerialized = getEnvVar("OTEL_RESOURCE_ATTRIBUTES");
        const envResourceAttributes = envResourceAttributesSerialized
            ? JSON.parse(envResourceAttributesSerialized)
            : {};
        const commonResources = detectResourcesSync({
            detectors: [this.asyncResourceDetector, processDetectorSync],
        })
            .merge(new Resource({
            [SemanticResourceAttributes.CLOUD_PROVIDER]: "trigger.dev",
            [SemanticInternalAttributes.TRIGGER]: true,
            [SemanticInternalAttributes.CLI_VERSION]: VERSION,
        }))
            .merge(config.resource ?? new Resource({}))
            .merge(new Resource(envResourceAttributes));
        const traceProvider = new NodeTracerProvider({
            forceFlushTimeoutMillis: config.forceFlushTimeoutMillis,
            resource: commonResources,
            spanLimits: {
                attributeCountLimit: OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
                eventCountLimit: OTEL_SPAN_EVENT_COUNT_LIMIT,
                attributePerEventCountLimit: OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
                linkCountLimit: OTEL_LINK_COUNT_LIMIT,
                attributePerLinkCountLimit: OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
            },
        });
        const spanExporter = new OTLPTraceExporter({
            url: `${config.url}/v1/traces`,
            timeoutMillis: config.forceFlushTimeoutMillis,
        });
        traceProvider.addSpanProcessor(new TaskContextSpanProcessor(getEnvVar("OTEL_BATCH_PROCESSING_ENABLED") === "1"
            ? new BatchSpanProcessor(spanExporter, {
                maxExportBatchSize: parseInt(getEnvVar("OTEL_SPAN_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                scheduledDelayMillis: parseInt(getEnvVar("OTEL_SPAN_SCHEDULED_DELAY_MILLIS") ?? "200"),
                exportTimeoutMillis: parseInt(getEnvVar("OTEL_SPAN_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                maxQueueSize: parseInt(getEnvVar("OTEL_SPAN_MAX_QUEUE_SIZE") ?? "512"),
            })
            : new SimpleSpanProcessor(spanExporter)));
        traceProvider.register();
        registerInstrumentations({
            instrumentations: config.instrumentations ?? [],
            tracerProvider: traceProvider,
        });
        const logExporter = new OTLPLogExporter({
            url: `${config.url}/v1/logs`,
        });
        // To start a logger, you first need to initialize the Logger provider.
        const loggerProvider = new LoggerProvider({
            resource: commonResources,
            logRecordLimits: {
                attributeCountLimit: OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,
                attributeValueLengthLimit: OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            },
        });
        loggerProvider.addLogRecordProcessor(new TaskContextLogProcessor(getEnvVar("OTEL_BATCH_PROCESSING_ENABLED") === "1"
            ? new BatchLogRecordProcessor(logExporter, {
                maxExportBatchSize: parseInt(getEnvVar("OTEL_LOG_MAX_EXPORT_BATCH_SIZE") ?? "64"),
                scheduledDelayMillis: parseInt(getEnvVar("OTEL_LOG_SCHEDULED_DELAY_MILLIS") ?? "200"),
                exportTimeoutMillis: parseInt(getEnvVar("OTEL_LOG_EXPORT_TIMEOUT_MILLIS") ?? "30000"),
                maxQueueSize: parseInt(getEnvVar("OTEL_LOG_MAX_QUEUE_SIZE") ?? "512"),
            })
            : new SimpleLogRecordProcessor(logExporter)));
        this._logProvider = loggerProvider;
        this._spanExporter = spanExporter;
        this._traceProvider = traceProvider;
        logs.setGlobalLoggerProvider(loggerProvider);
        this.getLogger = loggerProvider.getLogger.bind(loggerProvider);
        this.getTracer = traceProvider.getTracer.bind(traceProvider);
    }
    async flush() {
        await Promise.all([this._traceProvider.forceFlush(), this._logProvider.forceFlush()]);
    }
    async shutdown() {
        await Promise.all([this._traceProvider.shutdown(), this._logProvider.shutdown()]);
    }
}
function setLogLevel(level) {
    let diagLogLevel;
    switch (level) {
        case "none":
            diagLogLevel = DiagLogLevel.NONE;
            break;
        case "error":
            diagLogLevel = DiagLogLevel.ERROR;
            break;
        case "warn":
            diagLogLevel = DiagLogLevel.WARN;
            break;
        case "info":
            diagLogLevel = DiagLogLevel.INFO;
            break;
        case "debug":
            diagLogLevel = DiagLogLevel.DEBUG;
            break;
        case "verbose":
            diagLogLevel = DiagLogLevel.VERBOSE;
            break;
        case "all":
            diagLogLevel = DiagLogLevel.ALL;
            break;
        default:
            diagLogLevel = DiagLogLevel.NONE;
    }
    diag.setLogger(new DiagConsoleLogger(), diagLogLevel);
}
//# sourceMappingURL=tracingSDK.js.map