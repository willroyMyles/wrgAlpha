import { z } from "zod";
import { ConfigManifest } from "./config.js";
import { TaskFile, TaskManifest } from "./schemas.js";
export const BuildExternal = z.object({
    name: z.string(),
    version: z.string(),
});
export const BuildTarget = z.enum(["dev", "deploy"]);
export const BuildRuntime = z.enum(["node", "bun"]);
export const BuildManifest = z.object({
    target: BuildTarget,
    packageVersion: z.string(),
    cliPackageVersion: z.string(),
    contentHash: z.string(),
    runtime: BuildRuntime,
    environment: z.string(),
    config: ConfigManifest,
    files: z.array(TaskFile),
    sources: z.record(z.object({
        contents: z.string(),
        contentHash: z.string(),
    })),
    outputPath: z.string(),
    runWorkerEntryPoint: z.string(), // Dev & Deploy has a runWorkerEntryPoint
    runControllerEntryPoint: z.string().optional(), // Only deploy has a runControllerEntryPoint
    indexWorkerEntryPoint: z.string(), // Dev & Deploy has a indexWorkerEntryPoint
    indexControllerEntryPoint: z.string().optional(), // Only deploy has a indexControllerEntryPoint
    loaderEntryPoint: z.string().optional(),
    configPath: z.string(),
    externals: BuildExternal.array().optional(),
    build: z.object({
        env: z.record(z.string()).optional(),
        commands: z.array(z.string()).optional(),
    }),
    customConditions: z.array(z.string()).optional(),
    deploy: z.object({
        env: z.record(z.string()).optional(),
        sync: z
            .object({
            env: z.record(z.string()).optional(),
        })
            .optional(),
    }),
    image: z
        .object({
        pkgs: z.array(z.string()).optional(),
        instructions: z.array(z.string()).optional(),
    })
        .optional(),
    otelImportHook: z
        .object({
        include: z.array(z.string()).optional(),
        exclude: z.array(z.string()).optional(),
    })
        .optional(),
});
export const IndexMessage = z.object({
    type: z.literal("index"),
    data: z.object({
        build: BuildManifest,
    }),
});
export const WorkerManifest = z.object({
    configPath: z.string(),
    tasks: TaskManifest.array(),
    workerEntryPoint: z.string(),
    controllerEntryPoint: z.string().optional(),
    loaderEntryPoint: z.string().optional(),
    runtime: BuildRuntime,
    customConditions: z.array(z.string()).optional(),
    otelImportHook: z
        .object({
        include: z.array(z.string()).optional(),
        exclude: z.array(z.string()).optional(),
    })
        .optional(),
});
export const WorkerManifestMessage = z.object({
    type: z.literal("worker-manifest"),
    data: z.object({
        manifest: WorkerManifest,
    }),
});
export const ImportError = z.object({
    message: z.string(),
    file: z.string(),
    stack: z.string().optional(),
    name: z.string().optional(),
});
export const ImportTaskFileErrors = z.array(ImportError);
//# sourceMappingURL=build.js.map