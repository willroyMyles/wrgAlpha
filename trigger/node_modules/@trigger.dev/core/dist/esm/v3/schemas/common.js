import { z } from "zod";
// Defaults to 0.5
export const MachineCpu = z.union([
    z.literal(0.25),
    z.literal(0.5),
    z.literal(1),
    z.literal(2),
    z.literal(4),
]);
// Defaults to 1
export const MachineMemory = z.union([
    z.literal(0.25),
    z.literal(0.5),
    z.literal(1),
    z.literal(2),
    z.literal(4),
    z.literal(8),
]);
// Default is small-1x
export const MachinePresetName = z.enum([
    "micro",
    "small-1x",
    "small-2x",
    "medium-1x",
    "medium-2x",
    "large-1x",
    "large-2x",
]);
export const MachineConfig = z.object({
    cpu: MachineCpu.optional(),
    memory: MachineMemory.optional(),
    preset: MachinePresetName.optional(),
});
export const MachinePreset = z.object({
    name: MachinePresetName,
    cpu: z.number(),
    memory: z.number(),
    centsPerMs: z.number(),
});
export const TaskRunBuiltInError = z.object({
    type: z.literal("BUILT_IN_ERROR"),
    name: z.string(),
    message: z.string(),
    stackTrace: z.string(),
});
export const TaskRunCustomErrorObject = z.object({
    type: z.literal("CUSTOM_ERROR"),
    raw: z.string(),
});
export const TaskRunStringError = z.object({
    type: z.literal("STRING_ERROR"),
    raw: z.string(),
});
export const TaskRunErrorCodes = {
    COULD_NOT_FIND_EXECUTOR: "COULD_NOT_FIND_EXECUTOR",
    COULD_NOT_FIND_TASK: "COULD_NOT_FIND_TASK",
    COULD_NOT_IMPORT_TASK: "COULD_NOT_IMPORT_TASK",
    CONFIGURED_INCORRECTLY: "CONFIGURED_INCORRECTLY",
    TASK_ALREADY_RUNNING: "TASK_ALREADY_RUNNING",
    TASK_EXECUTION_FAILED: "TASK_EXECUTION_FAILED",
    TASK_EXECUTION_ABORTED: "TASK_EXECUTION_ABORTED",
    TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE: "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE",
    TASK_PROCESS_SIGKILL_TIMEOUT: "TASK_PROCESS_SIGKILL_TIMEOUT",
    TASK_RUN_CANCELLED: "TASK_RUN_CANCELLED",
    TASK_OUTPUT_ERROR: "TASK_OUTPUT_ERROR",
    HANDLE_ERROR_ERROR: "HANDLE_ERROR_ERROR",
    GRACEFUL_EXIT_TIMEOUT: "GRACEFUL_EXIT_TIMEOUT",
    TASK_RUN_CRASHED: "TASK_RUN_CRASHED",
};
export const TaskRunInternalError = z.object({
    type: z.literal("INTERNAL_ERROR"),
    code: z.enum([
        "COULD_NOT_FIND_EXECUTOR",
        "COULD_NOT_FIND_TASK",
        "COULD_NOT_IMPORT_TASK",
        "CONFIGURED_INCORRECTLY",
        "TASK_ALREADY_RUNNING",
        "TASK_EXECUTION_FAILED",
        "TASK_EXECUTION_ABORTED",
        "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE",
        "TASK_PROCESS_SIGKILL_TIMEOUT",
        "TASK_RUN_CANCELLED",
        "TASK_OUTPUT_ERROR",
        "HANDLE_ERROR_ERROR",
        "GRACEFUL_EXIT_TIMEOUT",
        "TASK_RUN_HEARTBEAT_TIMEOUT",
        "TASK_RUN_CRASHED",
    ]),
    message: z.string().optional(),
    stackTrace: z.string().optional(),
});
export const TaskRunError = z.discriminatedUnion("type", [
    TaskRunBuiltInError,
    TaskRunCustomErrorObject,
    TaskRunStringError,
    TaskRunInternalError,
]);
export const TaskRun = z.object({
    id: z.string(),
    payload: z.string(),
    payloadType: z.string(),
    context: z.any(),
    tags: z.array(z.string()),
    isTest: z.boolean().default(false),
    createdAt: z.coerce.date(),
    startedAt: z.coerce.date().default(() => new Date()),
    idempotencyKey: z.string().optional(),
    maxAttempts: z.number().optional(),
    durationMs: z.number().default(0),
    costInCents: z.number().default(0),
    baseCostInCents: z.number().default(0),
    version: z.string().optional(),
});
export const TaskRunExecutionTask = z.object({
    id: z.string(),
    filePath: z.string(),
    exportName: z.string(),
});
export const TaskRunExecutionAttempt = z.object({
    id: z.string(),
    number: z.number(),
    startedAt: z.coerce.date(),
    backgroundWorkerId: z.string(),
    backgroundWorkerTaskId: z.string(),
    status: z.string(),
});
export const TaskRunExecutionEnvironment = z.object({
    id: z.string(),
    slug: z.string(),
    type: z.enum(["PRODUCTION", "STAGING", "DEVELOPMENT", "PREVIEW"]),
});
export const TaskRunExecutionOrganization = z.object({
    id: z.string(),
    slug: z.string(),
    name: z.string(),
});
export const TaskRunExecutionProject = z.object({
    id: z.string(),
    ref: z.string(),
    slug: z.string(),
    name: z.string(),
});
export const TaskRunExecutionQueue = z.object({
    id: z.string(),
    name: z.string(),
});
export const TaskRunExecutionBatch = z.object({
    id: z.string(),
});
export const TaskRunExecution = z.object({
    task: TaskRunExecutionTask,
    attempt: TaskRunExecutionAttempt,
    run: TaskRun,
    queue: TaskRunExecutionQueue,
    environment: TaskRunExecutionEnvironment,
    organization: TaskRunExecutionOrganization,
    project: TaskRunExecutionProject,
    batch: TaskRunExecutionBatch.optional(),
    machine: MachinePreset.optional(),
});
export const TaskRunContext = z.object({
    task: TaskRunExecutionTask,
    attempt: TaskRunExecutionAttempt.omit({
        backgroundWorkerId: true,
        backgroundWorkerTaskId: true,
    }),
    run: TaskRun.omit({ payload: true, payloadType: true }),
    queue: TaskRunExecutionQueue,
    environment: TaskRunExecutionEnvironment,
    organization: TaskRunExecutionOrganization,
    project: TaskRunExecutionProject,
    batch: TaskRunExecutionBatch.optional(),
    machine: MachinePreset.optional(),
});
export const TaskRunExecutionRetry = z.object({
    timestamp: z.number(),
    delay: z.number(),
    error: z.unknown().optional(),
});
export const TaskRunExecutionUsage = z.object({
    durationMs: z.number(),
});
export const TaskRunFailedExecutionResult = z.object({
    ok: z.literal(false),
    id: z.string(),
    error: TaskRunError,
    retry: TaskRunExecutionRetry.optional(),
    skippedRetrying: z.boolean().optional(),
    usage: TaskRunExecutionUsage.optional(),
});
export const TaskRunSuccessfulExecutionResult = z.object({
    ok: z.literal(true),
    id: z.string(),
    output: z.string().optional(),
    outputType: z.string(),
    usage: TaskRunExecutionUsage.optional(),
});
export const TaskRunExecutionResult = z.discriminatedUnion("ok", [
    TaskRunSuccessfulExecutionResult,
    TaskRunFailedExecutionResult,
]);
export const BatchTaskRunExecutionResult = z.object({
    id: z.string(),
    items: TaskRunExecutionResult.array(),
});
export const SerializedError = z.object({
    message: z.string(),
    name: z.string().optional(),
    stackTrace: z.string().optional(),
});
//# sourceMappingURL=common.js.map