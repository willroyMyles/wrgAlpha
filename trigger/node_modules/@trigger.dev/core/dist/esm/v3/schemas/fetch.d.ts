import { z } from "zod";
import { EventFilter } from "./eventFilter.js";
import { Prettify } from "../types/index.js";
export declare const FetchRetryHeadersStrategy: z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodOptional<z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>;
export type FetchRetryHeadersStrategy = z.infer<typeof FetchRetryHeadersStrategy>;
export declare const FetchRetryBackoffStrategy: z.ZodObject<{
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}>;
/** The `backoff` strategy retries the request with an exponential backoff. */
export type FetchRetryBackoffStrategy = z.infer<typeof FetchRetryBackoffStrategy>;
export declare const FetchRetryStrategy: z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodOptional<z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>, z.ZodObject<{
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}>]>;
export type FetchRetryStrategy = z.infer<typeof FetchRetryStrategy>;
export declare const FetchRetryByStatusOptions: z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
    /** The `headers` strategy retries the request using info from the response headers. */
    strategy: z.ZodLiteral<"headers">;
    /** The header to use to determine the maximum number of times to retry the request. */
    limitHeader: z.ZodString;
    /** The header to use to determine the number of remaining retries. */
    remainingHeader: z.ZodString;
    /** The header to use to determine the time when the number of remaining retries will be reset. */
    resetHeader: z.ZodString;
    /** The event filter to use to determine if the request should be retried. */
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
    /** The format of the `resetHeader` value. */
    resetFormat: z.ZodOptional<z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>>;
}, "strip", z.ZodTypeAny, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}, {
    strategy: "headers";
    limitHeader: string;
    remainingHeader: string;
    resetHeader: string;
    bodyFilter?: EventFilter | undefined;
    resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
}>, z.ZodObject<{
    factor: z.ZodOptional<z.ZodNumber>;
    minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
    randomize: z.ZodOptional<z.ZodBoolean>;
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    strategy: z.ZodLiteral<"backoff">;
    bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
}, "strip", z.ZodTypeAny, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}, {
    strategy: "backoff";
    factor?: number | undefined;
    minTimeoutInMs?: number | undefined;
    maxTimeoutInMs?: number | undefined;
    randomize?: boolean | undefined;
    maxAttempts?: number | undefined;
    bodyFilter?: EventFilter | undefined;
}>]>>;
/** An object where the key is a status code pattern and the value is a retrying strategy. Supported patterns are:
  - Specific status codes: 429
  - Ranges: 500-599
  - Wildcards: 2xx, 3xx, 4xx, 5xx
  */
export type FetchRetryByStatusOptions = Prettify<z.infer<typeof FetchRetryByStatusOptions>>;
export declare const FetchTimeoutOptions: z.ZodObject<{
    /** The maximum time to wait for the request to complete. */
    durationInMs: z.ZodOptional<z.ZodNumber>;
    retry: z.ZodOptional<z.ZodObject<{
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    durationInMs?: number | undefined;
    retry?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}, {
    durationInMs?: number | undefined;
    retry?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}>;
export type FetchTimeoutOptions = z.infer<typeof FetchTimeoutOptions>;
export declare const FetchRetryOptions: z.ZodObject<{
    /** The retrying strategy for specific status codes. */
    byStatus: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<"strategy", [z.ZodObject<{
        /** The `headers` strategy retries the request using info from the response headers. */
        strategy: z.ZodLiteral<"headers">;
        /** The header to use to determine the maximum number of times to retry the request. */
        limitHeader: z.ZodString;
        /** The header to use to determine the number of remaining retries. */
        remainingHeader: z.ZodString;
        /** The header to use to determine the time when the number of remaining retries will be reset. */
        resetHeader: z.ZodString;
        /** The event filter to use to determine if the request should be retried. */
        bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
        /** The format of the `resetHeader` value. */
        resetFormat: z.ZodOptional<z.ZodDefault<z.ZodEnum<["unix_timestamp", "unix_timestamp_in_ms", "iso_8601", "iso_8601_duration_openai_variant"]>>>;
    }, "strip", z.ZodTypeAny, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    }, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    }>, z.ZodObject<{
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        strategy: z.ZodLiteral<"backoff">;
        bodyFilter: z.ZodOptional<z.ZodType<EventFilter, z.ZodTypeDef, EventFilter>>;
    }, "strip", z.ZodTypeAny, {
        strategy: "backoff";
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        maxAttempts?: number | undefined;
        bodyFilter?: EventFilter | undefined;
    }, {
        strategy: "backoff";
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        maxAttempts?: number | undefined;
        bodyFilter?: EventFilter | undefined;
    }>]>>>;
    /** The timeout options for the request. */
    timeout: z.ZodOptional<z.ZodObject<{
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }>>;
    /**
     * The retrying strategy for connection errors.
     */
    connectionError: z.ZodOptional<z.ZodObject<{
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        factor: z.ZodOptional<z.ZodNumber>;
        minTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        maxTimeoutInMs: z.ZodOptional<z.ZodNumber>;
        randomize: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }, {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    byStatus?: Record<string, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    } | {
        strategy: "backoff";
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        maxAttempts?: number | undefined;
        bodyFilter?: EventFilter | undefined;
    }> | undefined;
    timeout?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
    connectionError?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}, {
    byStatus?: Record<string, {
        strategy: "headers";
        limitHeader: string;
        remainingHeader: string;
        resetHeader: string;
        bodyFilter?: EventFilter | undefined;
        resetFormat?: "unix_timestamp" | "unix_timestamp_in_ms" | "iso_8601" | "iso_8601_duration_openai_variant" | undefined;
    } | {
        strategy: "backoff";
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
        maxAttempts?: number | undefined;
        bodyFilter?: EventFilter | undefined;
    }> | undefined;
    timeout?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
    connectionError?: {
        maxAttempts?: number | undefined;
        factor?: number | undefined;
        minTimeoutInMs?: number | undefined;
        maxTimeoutInMs?: number | undefined;
        randomize?: boolean | undefined;
    } | undefined;
}>;
export type FetchRetryOptions = Prettify<z.infer<typeof FetchRetryOptions>>;
