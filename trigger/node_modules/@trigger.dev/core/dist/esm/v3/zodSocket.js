import { io } from "socket.io-client";
import { z } from "zod";
import { LogLevel, SimpleStructuredLogger } from "./utils/structuredLogger.js";
import { fromZodError } from "zod-validation-error";
const messageSchema = z.object({
    version: z.string(),
    type: z.string(),
    payload: z.unknown(),
});
export class ZodSocketMessageHandler {
    #schema;
    #handlers;
    #logger;
    constructor(options) {
        this.#schema = options.schema;
        this.#handlers = options.handlers;
        this.#logger =
            options.logger ?? new SimpleStructuredLogger("socket-message-handler", LogLevel.info);
    }
    async handleMessage(message) {
        const parseResult = this.parseMessage(message);
        if (!parseResult.success) {
            this.#logger.error("Failed to parse message, skipping handler", {
                rawMessage: message,
                error: parseResult.reason,
            });
            return;
        }
        if (!this.#handlers) {
            throw new Error("No handlers provided");
        }
        const { type, payload } = parseResult.data;
        const handler = this.#handlers[type];
        if (!handler) {
            console.error(`No handler for message type: ${String(type)}`);
            return;
        }
        const ack = await handler(payload);
        return ack;
    }
    parseMessage(message) {
        const parsedMessage = messageSchema.safeParse(message);
        if (!parsedMessage.success) {
            return {
                success: false,
                reason: `Failed to parse message: ${fromZodError(parsedMessage.error).toString()}`,
            };
        }
        const schema = this.#schema[parsedMessage.data.type]?.["message"];
        if (!schema) {
            return {
                success: false,
                reason: `Unknown message type: ${parsedMessage.data.type}`,
            };
        }
        const messageWithVersion = {
            version: parsedMessage.data.version,
            ...(typeof parsedMessage.data.payload === "object" ? parsedMessage.data.payload : {}),
        };
        const parsedPayload = schema.safeParse(messageWithVersion);
        if (!parsedPayload.success) {
            console.error("Failed to parse message payload", {
                message,
                payload: messageWithVersion,
            });
            return {
                success: false,
                reason: fromZodError(parsedPayload.error).toString(),
            };
        }
        return {
            success: true,
            data: {
                type: parsedMessage.data.type,
                payload: parsedPayload.data,
            },
        };
    }
    registerHandlers(emitter, logger) {
        const log = logger ?? console;
        if (!this.#handlers) {
            log.info("No handlers provided");
            return;
        }
        for (const eventName of Object.keys(this.#handlers)) {
            emitter.on(eventName, async (message, callback) => {
                log.info(`handling ${eventName}`, {
                    payload: message,
                    hasCallback: !!callback,
                });
                let ack;
                try {
                    // FIXME: this only works if the message doesn't have genuine payload prop
                    if ("payload" in message) {
                        ack = await this.handleMessage({ type: eventName, ...message });
                    }
                    else {
                        // Handle messages not sent by ZodMessageSender
                        const { version, ...payload } = message;
                        ack = await this.handleMessage({ type: eventName, version, payload });
                    }
                }
                catch (error) {
                    log.error("Error while handling message", {
                        error: error instanceof Error
                            ? {
                                message: error.message,
                                stack: error.stack,
                            }
                            : error,
                    });
                    return;
                }
                if (callback && typeof callback === "function") {
                    callback(ack);
                }
            });
        }
    }
}
export class ZodSocketMessageSender {
    #schema;
    #socket;
    #logger;
    constructor(options) {
        this.#schema = options.schema;
        this.#socket = options.socket;
        this.#logger = options.logger ?? new SimpleStructuredLogger("zod-socket-sender", LogLevel.info);
    }
    send(type, payload) {
        const schema = this.#schema[type]?.["message"];
        if (!schema) {
            throw new Error(`Unknown message type: ${type}`);
        }
        const parsedPayload = schema.safeParse(payload);
        if (!parsedPayload.success) {
            this.#logger.error("Failed to parse message payload, will not send", {
                error: parsedPayload.error,
            });
            return;
        }
        // @ts-expect-error
        this.#socket.emit(type, { payload, version: "v1" });
        return;
    }
    async sendWithAck(type, payload) {
        const schema = this.#schema[type]?.["message"];
        if (!schema) {
            throw new Error(`Unknown message type: ${type}`);
        }
        const parsedPayload = schema.safeParse(payload);
        if (!parsedPayload.success) {
            throw new Error(`Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`);
        }
        // @ts-expect-error
        const callbackResult = await this.#socket.emitWithAck(type, { payload, version: "v1" });
        return callbackResult;
    }
}
export class ZodSocketConnection {
    #sender;
    socket;
    #handler;
    #logger;
    constructor(opts) {
        const uri = `${opts.secure ? "wss" : "ws"}://${opts.host}:${opts.port ?? (opts.secure ? "443" : "80")}/${opts.namespace}`;
        const logger = new SimpleStructuredLogger(opts.namespace, LogLevel.info);
        logger.log("new zod socket", { uri });
        this.socket = io(uri, {
            transports: ["websocket"],
            auth: {
                token: opts.authToken,
            },
            extraHeaders: opts.extraHeaders,
            reconnectionDelay: 500,
            reconnectionDelayMax: 1000,
            ...opts.ioOptions,
        });
        this.#logger = logger.child({
            socketId: this.socket.id,
        });
        this.#handler = new ZodSocketMessageHandler({
            schema: opts.serverMessages,
            handlers: opts.handlers,
        });
        this.#handler.registerHandlers(this.socket, this.#logger);
        this.#sender = new ZodSocketMessageSender({
            schema: opts.clientMessages,
            socket: this.socket,
            logger: this.#logger,
        });
        this.socket.on("connect_error", async (error) => {
            this.#logger.error(`connect_error: ${error}`);
            if (opts.onError) {
                await opts.onError(this.socket, error, this.#logger);
            }
        });
        this.socket.on("connect", async () => {
            this.#logger.info("connect");
            if (opts.onConnection) {
                await opts.onConnection(this.socket, this.#handler, this.#sender, this.#logger);
            }
        });
        this.socket.on("disconnect", async (reason, description) => {
            this.#logger.info("disconnect", { reason, description });
            if (opts.onDisconnect) {
                await opts.onDisconnect(this.socket, reason, description, this.#logger);
            }
        });
    }
    close() {
        this.socket.close();
    }
    connect() {
        this.socket.connect();
    }
    get send() {
        return this.#sender.send.bind(this.#sender);
    }
    get sendWithAck() {
        return this.#sender.sendWithAck.bind(this.#sender);
    }
}
//# sourceMappingURL=zodSocket.js.map