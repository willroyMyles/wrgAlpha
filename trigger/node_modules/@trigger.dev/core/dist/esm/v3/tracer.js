import { SpanStatusCode, context, propagation, trace, } from "@opentelemetry/api";
import { logs } from "@opentelemetry/api-logs";
import { SemanticInternalAttributes } from "./semanticInternalAttributes.js";
import { clock } from "./clock-api.js";
import { usage } from "./usage-api.js";
import { taskContext } from "./task-context-api.js";
export class TriggerTracer {
    _config;
    constructor(_config) {
        this._config = _config;
    }
    _tracer;
    get tracer() {
        if (!this._tracer) {
            if ("tracer" in this._config)
                return this._config.tracer;
            this._tracer = trace.getTracer(this._config.name, this._config.version);
        }
        return this._tracer;
    }
    _logger;
    get logger() {
        if (!this._logger) {
            if ("logger" in this._config)
                return this._config.logger;
            this._logger = logs.getLogger(this._config.name, this._config.version);
        }
        return this._logger;
    }
    extractContext(traceContext) {
        return propagation.extract(context.active(), traceContext ?? {});
    }
    startActiveSpan(name, fn, options, ctx) {
        const parentContext = ctx ?? context.active();
        const attributes = options?.attributes ?? {};
        return this.tracer.startActiveSpan(name, {
            ...options,
            attributes,
            startTime: clock.preciseNow(),
        }, parentContext, async (span) => {
            if (taskContext.ctx) {
                this.tracer
                    .startSpan(name, {
                    ...options,
                    attributes: {
                        ...attributes,
                        [SemanticInternalAttributes.SPAN_PARTIAL]: true,
                        [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
                    },
                }, parentContext)
                    .end();
            }
            const usageMeasurement = usage.start();
            try {
                return await fn(span);
            }
            catch (e) {
                if (typeof e === "string" || e instanceof Error) {
                    span.recordException(e);
                }
                span.setStatus({ code: SpanStatusCode.ERROR });
                throw e;
            }
            finally {
                if (taskContext.ctx) {
                    const usageSample = usage.stop(usageMeasurement);
                    const machine = taskContext.ctx.machine;
                    span.setAttributes({
                        [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,
                        [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs
                            ? usageSample.cpuTime * machine.centsPerMs
                            : 0,
                    });
                }
                span.end(clock.preciseNow());
            }
        });
    }
    startSpan(name, options, ctx) {
        const parentContext = ctx ?? context.active();
        const attributes = options?.attributes ?? {};
        const span = this.tracer.startSpan(name, options, ctx);
        this.tracer
            .startSpan(name, {
            ...options,
            attributes: {
                ...attributes,
                [SemanticInternalAttributes.SPAN_PARTIAL]: true,
                [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,
            },
        }, parentContext)
            .end();
        return span;
    }
}
//# sourceMappingURL=tracer.js.map