import { SpanKind } from "@opentelemetry/api";
import { VERSION } from "../../version.js";
import { parseError, sanitizeError } from "../errors.js";
import { recordSpanException } from "../otel/index.js";
import { TaskRunContext, TaskRunErrorCodes, } from "../schemas/index.js";
import { SemanticInternalAttributes } from "../semanticInternalAttributes.js";
import { taskContext } from "../task-context-api.js";
import { conditionallyExportPacket, conditionallyImportPacket, createPacketAttributes, parsePacket, stringifyIO, } from "../utils/ioSerialization.js";
import { calculateNextRetryDelay } from "../utils/retries.js";
export class TaskExecutor {
    task;
    _tracingSDK;
    _tracer;
    _consoleInterceptor;
    _importedConfig;
    _handleErrorFn;
    constructor(task, options) {
        this.task = task;
        this._tracingSDK = options.tracingSDK;
        this._tracer = options.tracer;
        this._consoleInterceptor = options.consoleInterceptor;
        this._importedConfig = options.config;
        this._handleErrorFn = options.handleErrorFn;
    }
    async execute(execution, worker, traceContext, usage) {
        const ctx = TaskRunContext.parse(execution);
        const attemptMessage = `Attempt ${execution.attempt.number}`;
        const originalPacket = {
            data: execution.run.payload,
            dataType: execution.run.payloadType,
        };
        taskContext.setGlobalTaskContext({
            ctx,
            worker,
        });
        this._tracingSDK.asyncResourceDetector.resolveWithAttributes({
            ...taskContext.attributes,
            [SemanticInternalAttributes.SDK_VERSION]: VERSION,
            [SemanticInternalAttributes.SDK_LANGUAGE]: "typescript",
        });
        const result = await this._tracer.startActiveSpan(attemptMessage, async (span) => {
            return await this._consoleInterceptor.intercept(console, async () => {
                let parsedPayload;
                let initOutput;
                try {
                    const payloadPacket = await conditionallyImportPacket(originalPacket, this._tracer);
                    parsedPayload = await parsePacket(payloadPacket);
                    if (execution.attempt.number === 1) {
                        await this.#callOnStartFunctions(parsedPayload, ctx);
                    }
                    initOutput = await this.#callInitFunctions(parsedPayload, ctx);
                    const output = await this.#callRun(parsedPayload, ctx, initOutput);
                    await this.#callOnSuccessFunctions(parsedPayload, output, ctx, initOutput);
                    try {
                        const stringifiedOutput = await stringifyIO(output);
                        const finalOutput = await conditionallyExportPacket(stringifiedOutput, `${execution.attempt.id}/output`, this._tracer);
                        const attributes = await createPacketAttributes(finalOutput, SemanticInternalAttributes.OUTPUT, SemanticInternalAttributes.OUTPUT_TYPE);
                        if (attributes) {
                            span.setAttributes(attributes);
                        }
                        return {
                            ok: true,
                            id: execution.run.id,
                            output: finalOutput.data,
                            outputType: finalOutput.dataType,
                        };
                    }
                    catch (stringifyError) {
                        recordSpanException(span, stringifyError);
                        return {
                            ok: false,
                            id: execution.run.id,
                            error: {
                                type: "INTERNAL_ERROR",
                                code: TaskRunErrorCodes.TASK_OUTPUT_ERROR,
                                message: stringifyError instanceof Error
                                    ? stringifyError.message
                                    : typeof stringifyError === "string"
                                        ? stringifyError
                                        : undefined,
                            },
                        };
                    }
                }
                catch (runError) {
                    try {
                        const handleErrorResult = await this.#handleError(execution, runError, parsedPayload, ctx);
                        recordSpanException(span, handleErrorResult.error ?? runError);
                        if (handleErrorResult.status !== "retry") {
                            await this.#callOnFailureFunctions(parsedPayload, handleErrorResult.error ?? runError, ctx, initOutput);
                        }
                        return {
                            id: execution.run.id,
                            ok: false,
                            error: sanitizeError(handleErrorResult.error
                                ? parseError(handleErrorResult.error)
                                : parseError(runError)),
                            retry: handleErrorResult.status === "retry" ? handleErrorResult.retry : undefined,
                            skippedRetrying: handleErrorResult.status === "skipped",
                        };
                    }
                    catch (handleErrorError) {
                        recordSpanException(span, handleErrorError);
                        return {
                            ok: false,
                            id: execution.run.id,
                            error: {
                                type: "INTERNAL_ERROR",
                                code: TaskRunErrorCodes.HANDLE_ERROR_ERROR,
                                message: handleErrorError instanceof Error
                                    ? handleErrorError.message
                                    : typeof handleErrorError === "string"
                                        ? handleErrorError
                                        : undefined,
                            },
                        };
                    }
                }
                finally {
                    await this.#callTaskCleanup(parsedPayload, ctx, initOutput);
                }
            });
        }, {
            kind: SpanKind.CONSUMER,
            attributes: {
                [SemanticInternalAttributes.STYLE_ICON]: "attempt",
            },
        }, this._tracer.extractContext(traceContext));
        return { result };
    }
    async #callRun(payload, ctx, init) {
        const runFn = this.task.fns.run;
        const middlewareFn = this.task.fns.middleware;
        if (!runFn) {
            throw new Error("Task does not have a run function");
        }
        if (!middlewareFn) {
            return runFn(payload, { ctx, init });
        }
        return middlewareFn(payload, { ctx, next: async () => runFn(payload, { ctx, init }) });
    }
    async #callInitFunctions(payload, ctx) {
        await this.#callConfigInit(payload, ctx);
        const initFn = this.task.fns.init;
        if (!initFn) {
            return {};
        }
        return this._tracer.startActiveSpan("init", async (span) => {
            return await initFn(payload, { ctx });
        }, {
            attributes: {
                [SemanticInternalAttributes.STYLE_ICON]: "function",
            },
        });
    }
    async #callConfigInit(payload, ctx) {
        const initFn = this._importedConfig?.init;
        if (!initFn) {
            return {};
        }
        return this._tracer.startActiveSpan("config.init", async (span) => {
            return await initFn(payload, { ctx });
        }, {
            attributes: {
                [SemanticInternalAttributes.STYLE_ICON]: "function",
            },
        });
    }
    async #callOnSuccessFunctions(payload, output, ctx, initOutput) {
        await this.#callOnSuccessFunction(this.task.fns.onSuccess, "task.onSuccess", payload, output, ctx, initOutput);
        await this.#callOnSuccessFunction(this._importedConfig?.onSuccess, "config.onSuccess", payload, output, ctx, initOutput);
    }
    async #callOnSuccessFunction(onSuccessFn, name, payload, output, ctx, initOutput) {
        if (!onSuccessFn) {
            return;
        }
        try {
            await this._tracer.startActiveSpan(name, async (span) => {
                return await onSuccessFn(payload, output, { ctx, init: initOutput });
            }, {
                attributes: {
                    [SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch {
            // Ignore errors from onSuccess functions
        }
    }
    async #callOnFailureFunctions(payload, error, ctx, initOutput) {
        await this.#callOnFailureFunction(this.task.fns.onFailure, "task.onFailure", payload, error, ctx, initOutput);
        await this.#callOnFailureFunction(this._importedConfig?.onFailure, "config.onFailure", payload, error, ctx, initOutput);
    }
    async #callOnFailureFunction(onFailureFn, name, payload, error, ctx, initOutput) {
        if (!onFailureFn) {
            return;
        }
        try {
            return await this._tracer.startActiveSpan(name, async (span) => {
                return await onFailureFn(payload, error, { ctx, init: initOutput });
            }, {
                attributes: {
                    [SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch (e) {
            // Ignore errors from onFailure functions
        }
    }
    async #callOnStartFunctions(payload, ctx) {
        await this.#callOnStartFunction(this._importedConfig?.onStart, "config.onStart", payload, ctx, {});
        await this.#callOnStartFunction(this.task.fns.onStart, "task.onStart", payload, ctx, {});
    }
    async #callOnStartFunction(onStartFn, name, payload, ctx, initOutput) {
        if (!onStartFn) {
            return;
        }
        try {
            await this._tracer.startActiveSpan(name, async (span) => {
                return await onStartFn(payload, { ctx });
            }, {
                attributes: {
                    [SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch {
            // Ignore errors from onStart functions
        }
    }
    async #callTaskCleanup(payload, ctx, init) {
        const cleanupFn = this.task.fns.cleanup;
        if (!cleanupFn) {
            return;
        }
        return this._tracer.startActiveSpan("cleanup", async (span) => {
            return await cleanupFn(payload, { ctx, init });
        });
    }
    async #handleError(execution, error, payload, ctx) {
        const retriesConfig = this._importedConfig?.retries;
        const retry = this.task.retry ?? retriesConfig?.default;
        if (!retry) {
            return { status: "noop" };
        }
        if (error instanceof Error && error.name === "AbortTaskRunError") {
            return { status: "skipped" };
        }
        if (execution.run.maxAttempts) {
            retry.maxAttempts = Math.max(execution.run.maxAttempts, 1);
        }
        let delay = calculateNextRetryDelay(retry, execution.attempt.number);
        if (delay &&
            error instanceof Error &&
            error.name === "TriggerApiError" &&
            error.status === 429) {
            const rateLimitError = error;
            delay = rateLimitError.millisecondsUntilReset;
        }
        if (execution.environment.type === "DEVELOPMENT" &&
            typeof retriesConfig?.enabledInDev === "boolean" &&
            !retriesConfig.enabledInDev) {
            return { status: "skipped" };
        }
        return this._tracer.startActiveSpan("handleError()", async (span) => {
            const handleErrorResult = this.task.fns.handleError
                ? await this.task.fns.handleError(payload, error, {
                    ctx,
                    retry,
                    retryDelayInMs: delay,
                    retryAt: delay ? new Date(Date.now() + delay) : undefined,
                })
                : this._importedConfig
                    ? await this._handleErrorFn?.(payload, error, {
                        ctx,
                        retry,
                        retryDelayInMs: delay,
                        retryAt: delay ? new Date(Date.now() + delay) : undefined,
                    })
                    : undefined;
            // If handleErrorResult
            if (!handleErrorResult) {
                return typeof delay === "undefined"
                    ? { status: "noop" }
                    : { status: "retry", retry: { timestamp: Date.now() + delay, delay } };
            }
            if (handleErrorResult.skipRetrying) {
                return { status: "skipped", error: handleErrorResult.error };
            }
            if (typeof handleErrorResult.retryAt !== "undefined") {
                return {
                    status: "retry",
                    retry: {
                        timestamp: handleErrorResult.retryAt.getTime(),
                        delay: handleErrorResult.retryAt.getTime() - Date.now(),
                    },
                    error: handleErrorResult.error,
                };
            }
            if (typeof handleErrorResult.retryDelayInMs === "number") {
                return {
                    status: "retry",
                    retry: {
                        timestamp: Date.now() + handleErrorResult.retryDelayInMs,
                        delay: handleErrorResult.retryDelayInMs,
                    },
                    error: handleErrorResult.error,
                };
            }
            if (handleErrorResult.retry && typeof handleErrorResult.retry === "object") {
                const delay = calculateNextRetryDelay(handleErrorResult.retry, execution.attempt.number);
                return typeof delay === "undefined"
                    ? { status: "noop", error: handleErrorResult.error }
                    : {
                        status: "retry",
                        retry: { timestamp: Date.now() + delay, delay },
                        error: handleErrorResult.error,
                    };
            }
            return { status: "noop", error: handleErrorResult.error };
        }, {
            attributes: {
                [SemanticInternalAttributes.STYLE_ICON]: "exclamation-circle",
            },
        });
    }
}
//# sourceMappingURL=taskExecutor.js.map