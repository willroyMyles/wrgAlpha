import { z } from "zod";
export class ZodSchemaParsedError extends Error {
    error;
    payload;
    constructor(error, payload) {
        super(error.message);
        this.error = error;
        this.payload = payload;
    }
}
export const ZodMessageSchema = z.object({
    version: z.literal("v1").default("v1"),
    type: z.string(),
    payload: z.unknown(),
});
export class ZodMessageHandler {
    #schema;
    #handlers;
    #logger;
    constructor(options) {
        this.#schema = options.schema;
        this.#handlers = options.messages;
        this.#logger = options.logger ?? console;
    }
    async handleMessage(message) {
        const parsedMessage = this.parseMessage(message);
        if (!parsedMessage.success) {
            this.#logger.error(parsedMessage.error, { message });
            return {
                success: false,
                error: parsedMessage.error,
            };
        }
        if (!this.#handlers) {
            this.#logger.error("No handlers provided", { message });
            return {
                success: false,
                error: "No handlers provided",
            };
        }
        const handler = this.#handlers[parsedMessage.data.type];
        if (!handler) {
            const error = `No handler for message type: ${String(parsedMessage.data.type)}`;
            this.#logger.error(error, { message });
            return {
                success: false,
                error,
            };
        }
        const ack = await handler(parsedMessage.data.payload);
        return {
            success: true,
            data: ack,
        };
    }
    parseMessage(message) {
        const parsedMessage = ZodMessageSchema.safeParse(message);
        if (!parsedMessage.success) {
            return {
                success: false,
                error: `Failed to parse message: ${JSON.stringify(parsedMessage.error)}`,
            };
        }
        const schema = this.#schema[parsedMessage.data.type];
        if (!schema) {
            return {
                success: false,
                error: `Unknown message type: ${parsedMessage.data.type}`,
            };
        }
        const parsedPayload = schema.safeParse(parsedMessage.data.payload);
        if (!parsedPayload.success) {
            return {
                success: false,
                error: `Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`,
            };
        }
        return {
            success: true,
            data: {
                type: parsedMessage.data.type,
                payload: parsedPayload.data,
            },
        };
    }
    registerHandlers(emitter, logger) {
        const log = logger ?? console;
        if (!this.#handlers) {
            log.info("No handlers provided");
            return;
        }
        for (const eventName of Object.keys(this.#schema)) {
            emitter.on(eventName, async (message, callback) => {
                log.info(`handling ${eventName}`, {
                    payload: message,
                    hasCallback: !!callback,
                });
                let ack;
                // FIXME: this only works if the message doesn't have genuine payload prop
                if ("payload" in message) {
                    ack = await this.handleMessage({ type: eventName, ...message });
                }
                else {
                    // Handle messages not sent by ZodMessageSender
                    const { version, ...payload } = message;
                    ack = await this.handleMessage({ type: eventName, version, payload });
                }
                if (callback && typeof callback === "function") {
                    if (!ack.success) {
                        // We don't know the callback type, so we can't do anything else - not all callbacks may accept a success prop
                        log.error("Failed to handle message, skipping callback", { message, error: ack.error });
                        return;
                    }
                    callback(ack.data);
                }
            });
        }
    }
}
export function parseMessageFromCatalog(message, schema) {
    const parsedMessage = ZodMessageSchema.safeParse(message);
    if (!parsedMessage.success) {
        throw new Error(`Failed to parse message: ${JSON.stringify(parsedMessage.error)}`);
    }
    const messageSchema = schema[parsedMessage.data.type];
    if (!messageSchema) {
        throw new Error(`Unknown message type: ${parsedMessage.data.type}`);
    }
    const parsedPayload = messageSchema.safeParse(parsedMessage.data.payload);
    if (!parsedPayload.success) {
        throw new Error(`Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`);
    }
    return {
        type: parsedMessage.data.type,
        payload: parsedPayload.data,
    };
}
export class ZodMessageSender {
    #schema;
    #sender;
    constructor(options) {
        this.#schema = options.schema;
        this.#sender = options.sender;
    }
    async send(type, payload) {
        const schema = this.#schema[type];
        if (!schema) {
            throw new Error(`Unknown message type: ${type}`);
        }
        const parsedPayload = schema.safeParse(payload);
        if (!parsedPayload.success) {
            throw new ZodSchemaParsedError(parsedPayload.error, payload);
        }
        try {
            await this.#sender({ type, payload, version: "v1" });
        }
        catch (error) {
            console.error("[ZodMessageSender] Failed to send message", error);
        }
    }
    async forwardMessage(message) {
        const parsedMessage = ZodMessageSchema.safeParse(message);
        if (!parsedMessage.success) {
            throw new Error(`Failed to parse message: ${JSON.stringify(parsedMessage.error)}`);
        }
        const schema = this.#schema[parsedMessage.data.type];
        if (!schema) {
            throw new Error(`Unknown message type: ${parsedMessage.data.type}`);
        }
        const parsedPayload = schema.safeParse(parsedMessage.data.payload);
        if (!parsedPayload.success) {
            throw new Error(`Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`);
        }
        try {
            await this.#sender({
                type: parsedMessage.data.type,
                payload: parsedPayload.data,
                version: "v1",
            });
        }
        catch (error) {
            console.error("[ZodMessageSender] Failed to forward message", error);
        }
    }
}
export async function sendMessageInCatalog(catalog, type, payload, sender) {
    const schema = catalog[type];
    if (!schema) {
        throw new Error(`Unknown message type: ${type}`);
    }
    const parsedPayload = schema.safeParse(payload);
    if (!parsedPayload.success) {
        throw new ZodSchemaParsedError(parsedPayload.error, payload);
    }
    await sender({ type, payload, version: "v1" });
}
//# sourceMappingURL=zodMessageHandler.js.map