import type { ManagerOptions, Socket, SocketOptions } from "socket.io-client";
import { z } from "zod";
import { EventEmitterLike, ZodMessageValueSchema } from "./zodMessageHandler.js";
import { StructuredLogger } from "./utils/structuredLogger.js";
export interface ZodSocketMessageCatalogSchema {
    [key: string]: {
        message: ZodMessageValueSchema<any>;
    } | {
        message: ZodMessageValueSchema<any>;
        callback?: ZodMessageValueSchema<any>;
    };
}
export type ZodMessageCatalogToSocketIoEvents<TCatalog extends ZodSocketMessageCatalogSchema> = {
    [K in keyof TCatalog]: SocketMessageHasCallback<TCatalog, K> extends true ? (message: z.infer<GetSocketMessageSchema<TCatalog, K>>, callback: (ack: z.infer<GetSocketCallbackSchema<TCatalog, K>>) => void) => void : (message: z.infer<GetSocketMessageSchema<TCatalog, K>>) => void;
};
export type GetSocketMessageSchema<TRPCCatalog extends ZodSocketMessageCatalogSchema, TMessageType extends keyof TRPCCatalog> = TRPCCatalog[TMessageType]["message"];
export type InferSocketMessageSchema<TRPCCatalog extends ZodSocketMessageCatalogSchema, TMessageType extends keyof TRPCCatalog> = z.infer<GetSocketMessageSchema<TRPCCatalog, TMessageType>>;
export type GetSocketCallbackSchema<TRPCCatalog extends ZodSocketMessageCatalogSchema, TMessageType extends keyof TRPCCatalog> = TRPCCatalog[TMessageType] extends {
    callback: any;
} ? TRPCCatalog[TMessageType]["callback"] : never;
export type InferSocketCallbackSchema<TRPCCatalog extends ZodSocketMessageCatalogSchema, TMessageType extends keyof TRPCCatalog> = z.infer<GetSocketCallbackSchema<TRPCCatalog, TMessageType>>;
export type SocketMessageHasCallback<TRPCCatalog extends ZodSocketMessageCatalogSchema, TMessageType extends keyof TRPCCatalog> = GetSocketCallbackSchema<TRPCCatalog, TMessageType> extends never ? false : true;
export type ZodSocketMessageHandlers<TCatalogSchema extends ZodSocketMessageCatalogSchema> = Partial<{
    [K in keyof TCatalogSchema]: (payload: z.infer<GetSocketMessageSchema<TCatalogSchema, K>>) => Promise<SocketMessageHasCallback<TCatalogSchema, K> extends true ? z.input<GetSocketCallbackSchema<TCatalogSchema, K>> : void>;
}>;
export type ZodSocketMessageHandlerOptions<TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    schema: TMessageCatalog;
    handlers?: ZodSocketMessageHandlers<TMessageCatalog>;
    logger?: StructuredLogger;
};
type MessageFromSocketSchema<K extends keyof TMessageCatalog, TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    type: K;
    payload: z.input<GetSocketMessageSchema<TMessageCatalog, K>>;
};
export type MessagesFromSocketCatalog<TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    [K in keyof TMessageCatalog]: MessageFromSocketSchema<K, TMessageCatalog>;
}[keyof TMessageCatalog];
export declare class ZodSocketMessageHandler<TRPCCatalog extends ZodSocketMessageCatalogSchema> {
    #private;
    constructor(options: ZodSocketMessageHandlerOptions<TRPCCatalog>);
    handleMessage(message: unknown): Promise<(SocketMessageHasCallback<TRPCCatalog, keyof TRPCCatalog> extends true ? z.input<GetSocketCallbackSchema<TRPCCatalog, keyof TRPCCatalog>> : void) | undefined>;
    private parseMessage;
    registerHandlers(emitter: EventEmitterLike, logger?: StructuredLogger): void;
}
export type ZodSocketMessageSenderOptions<TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    schema: TMessageCatalog;
    socket: ZodSocket<any, TMessageCatalog>;
    logger?: StructuredLogger;
};
export type GetSocketMessagesWithCallback<TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    [K in keyof TMessageCatalog]: SocketMessageHasCallback<TMessageCatalog, K> extends true ? K : never;
}[keyof TMessageCatalog];
export type GetSocketMessagesWithoutCallback<TMessageCatalog extends ZodSocketMessageCatalogSchema> = {
    [K in keyof TMessageCatalog]: SocketMessageHasCallback<TMessageCatalog, K> extends true ? never : K;
}[keyof TMessageCatalog];
export declare class ZodSocketMessageSender<TMessageCatalog extends ZodSocketMessageCatalogSchema> {
    #private;
    constructor(options: ZodSocketMessageSenderOptions<TMessageCatalog>);
    send<K extends GetSocketMessagesWithoutCallback<TMessageCatalog>>(type: K, payload: z.input<GetSocketMessageSchema<TMessageCatalog, K>>): void;
    sendWithAck<K extends GetSocketMessagesWithCallback<TMessageCatalog>>(type: K, payload: z.input<GetSocketMessageSchema<TMessageCatalog, K>>): Promise<z.infer<GetSocketCallbackSchema<TMessageCatalog, K>>>;
}
export type ZodSocket<TListenEvents extends ZodSocketMessageCatalogSchema, TEmitEvents extends ZodSocketMessageCatalogSchema> = Omit<Socket<ZodMessageCatalogToSocketIoEvents<TListenEvents>, ZodMessageCatalogToSocketIoEvents<TEmitEvents>>, "timeout"> & {
    timeout: (timeout: number) => Socket<ZodMessageCatalogToSocketIoEvents<TListenEvents>, ZodMessageCatalogToSocketIoEvents<TEmitEvents>>;
};
interface ZodSocketConnectionOptions<TClientMessages extends ZodSocketMessageCatalogSchema, TServerMessages extends ZodSocketMessageCatalogSchema> {
    host: string;
    port?: number;
    secure?: boolean;
    namespace: string;
    clientMessages: TClientMessages;
    serverMessages: TServerMessages;
    extraHeaders?: {
        [header: string]: string;
    };
    handlers?: ZodSocketMessageHandlers<TServerMessages>;
    authToken?: string;
    ioOptions?: Partial<ManagerOptions & SocketOptions>;
    onConnection?: (socket: ZodSocket<TServerMessages, TClientMessages>, handler: ZodSocketMessageHandler<TServerMessages>, sender: ZodSocketMessageSender<TClientMessages>, logger: StructuredLogger) => Promise<void>;
    onDisconnect?: (socket: ZodSocket<TServerMessages, TClientMessages>, reason: Socket.DisconnectReason, description: any, logger: StructuredLogger) => Promise<void>;
    onError?: (socket: ZodSocket<TServerMessages, TClientMessages>, err: Error, logger: StructuredLogger) => Promise<void>;
}
export declare class ZodSocketConnection<TClientMessages extends ZodSocketMessageCatalogSchema, TServerMessages extends ZodSocketMessageCatalogSchema> {
    #private;
    socket: ZodSocket<TServerMessages, TClientMessages>;
    constructor(opts: ZodSocketConnectionOptions<TClientMessages, TServerMessages>);
    close(): void;
    connect(): void;
    get send(): <K extends GetSocketMessagesWithoutCallback<TClientMessages>>(type: K, payload: z.input<GetSocketMessageSchema<TClientMessages, K>>) => void;
    get sendWithAck(): <K extends GetSocketMessagesWithCallback<TClientMessages>>(type: K, payload: z.input<GetSocketMessageSchema<TClientMessages, K>>) => Promise<z.TypeOf<GetSocketCallbackSchema<TClientMessages, K>>>;
}
export {};
